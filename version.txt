backend:

src/controllers/authController.js:

const User = require('../models/User');
const { generateToken, hashPassword, comparePassword } = require('../utils/auth');

// Register admin (untuk pertama kali)
const registerAdmin = async (req, res) => {
  try {
    const { username, password, email } = req.body;

    // Check if admin already exists
    const existingAdmin = await User.findOne({ role: 'admin' });
    if (existingAdmin) {
      return res.status(400).json({
        success: false,
        message: 'Admin already registered'
      });
    }

    // Create new admin
    const hashedPassword = await hashPassword(password);
    
    const admin = new User({
      username,
      password: hashedPassword,
      email,
      role: 'admin'
    });

    await admin.save();

    // Generate token
    const token = generateToken(admin._id, admin.username, admin.role);

    res.status(201).json({
      success: true,
      message: 'Admin registered successfully',
      token,
      user: {
        id: admin._id,
        username: admin.username,
        role: admin.role,
        email: admin.email
      }
    });

  } catch (error) {
    console.error('Register error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message
    });
  }
};

// Login
const login = async (req, res) => {
  try {
    const { username, password, role } = req.body;

    // Find user
    const user = await User.findOne({ username });
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    // Check if user is active
    if (!user.isActive) {
      return res.status(403).json({
        success: false,
        message: 'Account is disabled'
      });
    }

    // Check role (admin harus login sebagai admin, user sebagai user)
    if (role && user.role !== role) {
      return res.status(401).json({
        success: false,
        message: 'Invalid role selection'
      });
    }

    // Verify password
    const isPasswordValid = await comparePassword(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    // Update last login
    user.lastLogin = new Date();
    await user.save();

    // Generate token
    const token = generateToken(user._id, user.username, user.role);

    res.json({
      success: true,
      message: 'Login successful',
      token,
      user: {
        id: user._id,
        username: user.username,
        role: user.role,
        email: user.email
      }
    });

  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message
    });
  }
};

// Get current user profile
const getProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    res.json({
      success: true,
      user
    });

  } catch (error) {
    console.error('Get profile error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// Check if admin is registered (untuk frontend)
const checkAdminRegistered = async (req, res) => {
  try {
    const admin = await User.findOne({ role: 'admin' });
    
    res.json({
      success: true,
      isRegistered: !!admin
    });

  } catch (error) {
    console.error('Check admin error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

module.exports = {
  registerAdmin,
  login,
  getProfile,
  checkAdminRegistered
};

---------------------------------------------------------------------------------------------------------------------------------------
src/middleware/authMiddleware.js:

const { verifyToken } = require('../utils/auth');

const authMiddleware = (req, res, next) => {
  // Get token from header
  const token = req.header('Authorization')?.replace('Bearer ', '');

  if (!token) {
    return res.status(401).json({ 
      success: false, 
      message: 'Access denied. No token provided.' 
    });
  }

  try {
    // Verify token
    const decoded = verifyToken(token);
    
    if (!decoded) {
      return res.status(401).json({ 
        success: false, 
        message: 'Invalid or expired token.' 
      });
    }

    // Add user info to request
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ 
      success: false, 
      message: 'Invalid token.' 
    });
  }
};

const adminMiddleware = (req, res, next) => {
  if (req.user.role !== 'admin') {
    return res.status(403).json({ 
      success: false, 
      message: 'Access denied. Admin only.' 
    });
  }
  next();
};

module.exports = { authMiddleware, adminMiddleware };

---------------------------------------------------------------------------------------------------------------------------------------
src/models/Building.js:

const mongoose = require('mongoose');

const buildingSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  code: {
    type: String,
    unique: true,
    trim: true,
    uppercase: true
  },
  description: {
    type: String,
    trim: true
  },
  roomCount: {
    type: Number,
    default: 0
  },
  createdAt: {
    type: Date,
    default: Date.now,
    immutable: true
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// KOMENTARI SEMUA HOOKS UNTUK SEKARANG
// buildingSchema.pre('save', function(next) {
//   this.updatedAt = Date.now();
//   next();
// });

// buildingSchema.pre('findOneAndUpdate', function(next) {
//   this.set({ updatedAt: Date.now() });
//   next();
// });

module.exports = mongoose.model('Building', buildingSchema);


---------------------------------------------------------------------------------------------------------------------------------------
src/models/IotDevice.js:

const mongoose = require('mongoose');

const iotDeviceSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  // HAPUS field building dan buildingName
  apiEndpoint: {
    type: String,
    required: true,
    trim: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  lastUpdate: {
    type: Date
  },
  status: {
    type: String,
    enum: ['online', 'offline', 'error'],
    default: 'offline'
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('IoTDevice', iotDeviceSchema);

---------------------------------------------------------------------------------------------------------------------------------------
src/models/Room.js:

const mongoose = require('mongoose');

const roomSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true
  },
  buildingName: {
    type: String,
    required: true
  },
  dataSource: {
    type: String,
    enum: ['simulation', 'iot'],
    default: 'simulation'
  },
  iotDeviceId: {
    type: String,
    default: null
  },
  isActive: {
    type: Boolean,
    default: true
  },
  currentAQI: {
    type: Number,
    default: 0
  },
  currentData: {
    pm25: { type: Number, default: 0 },
    pm10: { type: Number, default: 0 },
    co2: { type: Number, default: 0 },
    temperature: { type: Number, default: 0 },
    humidity: { type: Number, default: 0 },
    updatedAt: { type: Date }
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// KOMENTARI SEMUA HOOKS UNTUK SEKARANG
// buildingSchema.pre('save', function(next) {
//   this.updatedAt = Date.now();
//   next();
// });

// buildingSchema.pre('findOneAndUpdate', function(next) {
//   this.set({ updatedAt: Date.now() });
//   next();
// });

module.exports = mongoose.model('Room', roomSchema);

---------------------------------------------------------------------------------------------------------------------------------------
src/models/SensorData.js:

const mongoose = require('mongoose');

const sensorDataSchema = new mongoose.Schema({
  roomId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Room',
    required: true
  },
  roomName: {
    type: String,
    required: true
  },
  buildingName: {
    type: String,
    required: true
  },
  aqi: {
    type: Number,
    required: true
  },
  pm25: {
    type: Number,
    required: true
  },
  pm10: {
    type: Number,
    required: true
  },
  co2: {
    type: Number,
    required: true
  },
  temperature: {
    type: Number,
    required: true
  },
  humidity: {
    type: Number,
    required: true
  },
  category: {
    type: String,
    enum: ['baik', 'sedang', 'tidak_sehat', 'sangat_tidak_sehat', 'berbahaya', 'error'], // TAMBAH 'error'
    required: true
  },
  timestamp: {
    type: Date,
    default: Date.now,
    index: true
  }
});

// Create index untuk query yang cepat
sensorDataSchema.index({ roomId: 1, timestamp: -1 });
sensorDataSchema.index({ timestamp: -1 });

module.exports = mongoose.model('SensorData', sensorDataSchema);

---------------------------------------------------------------------------------------------------------------------------------------
src/models/User.js:

const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  password: {
    type: String,
    required: true
  },
  role: {
    type: String,
    enum: ['admin', 'user'],
    default: 'user'
  },
  email: {
    type: String,
    trim: true,
    lowercase: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  lastLogin: {
    type: Date
  }
});

module.exports = mongoose.model('User', userSchema);

---------------------------------------------------------------------------------------------------------------------------------------
src/routes/authRoute.js:

const express = require('express');
const router = express.Router();
const {
  registerAdmin,
  login,
  getProfile,
  checkAdminRegistered
} = require('../controllers/authController');
const { authMiddleware } = require('../middleware/authMiddleware');

// Public routes
router.get('/check-admin', checkAdminRegistered);
router.post('/register-admin', registerAdmin);
router.post('/login', login);

// Protected routes
router.get('/profile', authMiddleware, getProfile);

module.exports = router;

---------------------------------------------------------------------------------------------------------------------------------------
src/routes/buildingRoutes.js

// File: src/routes/buildingRoutes.js
const express = require('express');
const router = express.Router();
const Building = require('../models/Building');
const Room = require('../models/Room');
const { authMiddleware, adminMiddleware } = require('../middleware/authMiddleware');

// Helper untuk broadcast building update
const broadcastBuildingUpdate = (io, building, action, updatedRooms = []) => {
  if (io) {
    io.emit('building-updated', {
      action: action, // 'created', 'updated', 'deleted'
      building: building,
      updatedRooms: updatedRooms,
      timestamp: new Date()
    });
    
    // Broadcast ke room-specific channels untuk semua room yang terpengaruh
    updatedRooms.forEach(room => {
      io.to(room._id.toString()).emit('room-building-updated', {
        buildingId: building._id,
        oldBuildingName: room.buildingName,
        newBuildingName: building.name,
        timestamp: new Date()
      });
    });
  }
};

// GET all buildings (PUBLIC - untuk semua user)
router.get('/', async (req, res) => {
  try {
    const buildings = await Building.find().sort({ name: 1 });
    
    res.json({
      success: true,
      count: buildings.length,
      data: buildings
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching buildings',
      error: error.message
    });
  }
});

// GET single building (PUBLIC - untuk semua user)
router.get('/:id', async (req, res) => {
  try {
    const building = await Building.findById(req.params.id);
    
    if (!building) {
      return res.status(404).json({
        success: false,
        message: 'Building not found'
      });
    }
    
    res.json({
      success: true,
      data: building
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching building',
      error: error.message
    });
  }
});

// POST create building (ADMIN ONLY)
router.post('/', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const { name, code, description } = req.body;
    
    // Validate required fields
    if (!name) {
      return res.status(400).json({
        success: false,
        message: 'Building name is required'
      });
    }
    
    // Check if code is unique
    if (code) {
      const existingBuilding = await Building.findOne({ code });
      if (existingBuilding) {
        return res.status(400).json({
          success: false,
          message: 'Building code already exists'
        });
      }
    }
    
    const building = new Building({
      name,
      code,
      description,
      roomCount: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    });
    
    await building.save();
    
    // Broadcast via Socket.io
    const io = req.app.get('socketio');
    if (io) {
      broadcastBuildingUpdate(io, building, 'created');
    }
    
    res.status(201).json({
      success: true,
      message: 'Building created successfully',
      data: building
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error creating building',
      error: error.message
    });
  }
});

// PUT update building (ADMIN ONLY) - PERBAIKAN UTAMA
router.put('/:id', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const { name, code, description } = req.body;
    const io = req.app.get('socketio');
    
    const building = await Building.findById(req.params.id);
    
    if (!building) {
      return res.status(404).json({
        success: false,
        message: 'Building not found'
      });
    }
    
    // Simpan nama lama untuk perbandingan
    const oldName = building.name;
    
    // Check if new code is unique (if being changed)
    if (code && code !== building.code) {
      const existingBuilding = await Building.findOne({ code });
      if (existingBuilding) {
        return res.status(400).json({
          success: false,
          message: 'Building code already exists'
        });
      }
    }
    
    // Update fields
    if (name) building.name = name;
    if (code !== undefined) building.code = code;
    if (description !== undefined) building.description = description;
    building.updatedAt = new Date();
    
    await building.save();
    
    // **PERBAIKAN UTAMA: Update buildingName di semua room yang terkait**
    let updatedRooms = [];
    if (name && name !== oldName) {
      // Find all rooms in this building
      const rooms = await Room.find({ building: building._id });
      
      // Update buildingName for each room
      const updatePromises = rooms.map(async (room) => {
        room.buildingName = building.name;
        room.updatedAt = new Date();
        await room.save();
        return room;
      });
      
      updatedRooms = await Promise.all(updatePromises);
      
      console.log(`âœ… Updated building name for ${updatedRooms.length} rooms in ${building.name}`);
    }
    
    // **Broadcast via Socket.io untuk semua perubahan**
    if (io) {
      // Broadcast building update
      broadcastBuildingUpdate(io, building, 'updated', updatedRooms);
      
      // Broadcast individual room updates
      updatedRooms.forEach(room => {
        io.to(room._id.toString()).emit('room-update', {
          roomId: room._id,
          data: {
            currentAQI: room.currentAQI,
            currentData: room.currentData,
            updatedAt: room.updatedAt,
            buildingName: room.buildingName // Include updated building name
          },
          timestamp: new Date(),
          source: 'building-update',
          type: 'building-name-changed'
        });
        
        // Broadcast to dashboard untuk refresh
        io.emit('dashboard-update', {
          type: 'building-name-changed',
          buildingId: building._id,
          oldBuildingName: oldName,
          newBuildingName: building.name,
          affectedRooms: updatedRooms.map(r => r._id),
          timestamp: new Date()
        });
      });
    }
    
    res.json({
      success: true,
      message: 'Building updated successfully',
      data: building,
      updatedRoomsCount: updatedRooms.length
    });
  } catch (error) {
    console.error('Error updating building:', error);
    res.status(500).json({
      success: false,
      message: 'Error updating building',
      error: error.message
    });
  }
});

// DELETE building (ADMIN ONLY) - Perbaiki untuk broadcast
router.delete('/:id', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const buildingId = req.params.id;
    const io = req.app.get('socketio');
    
    // Check if building has rooms
    const roomCount = await Room.countDocuments({ building: buildingId });
    
    if (roomCount > 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete building with existing rooms',
        roomCount: roomCount
      });
    }
    
    const building = await Building.findByIdAndDelete(buildingId);
    
    if (!building) {
      return res.status(404).json({
        success: false,
        message: 'Building not found'
      });
    }
    
    // Broadcast via Socket.io
    if (io) {
      broadcastBuildingUpdate(io, building, 'deleted');
    }
    
    res.json({
      success: true,
      message: 'Building deleted successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error deleting building',
      error: error.message
    });
  }
});

router.post('/:id/sync-rooms', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const buildingId = req.params.id;
    const io = req.app.get('socketio');
    
    const building = await Building.findById(buildingId);
    if (!building) {
      return res.status(404).json({
        success: false,
        message: 'Building not found'
      });
    }
    
    // Find all rooms in this building
    const rooms = await Room.find({ building: buildingId });
    
    // Update buildingName for each room
    const updatePromises = rooms.map(async (room) => {
      if (room.buildingName !== building.name) {
        room.buildingName = building.name;
        room.updatedAt = new Date();
        return await room.save();
      }
      return room;
    });
    
    const updatedRooms = (await Promise.all(updatePromises))
      .filter(room => room.buildingName === building.name);
    
    // Broadcast updates
    if (io && updatedRooms.length > 0) {
      updatedRooms.forEach(room => {
        io.to(room._id.toString()).emit('room-update', {
          roomId: room._id,
          data: {
            currentAQI: room.currentAQI,
            currentData: room.currentData,
            updatedAt: room.updatedAt,
            buildingName: room.buildingName
          },
          timestamp: new Date(),
          source: 'building-sync'
        });
      });
    }
    
    res.json({
      success: true,
      message: `Synced building name for ${updatedRooms.length} rooms`,
      building: building.name,
      updatedCount: updatedRooms.length
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error syncing building rooms',
      error: error.message
    });
  }
});

module.exports = router;roomRoutes.js

---------------------------------------------------------------------------------------------------------------------------------------
routes/iotDeviceRoutes.js

const express = require('express');
const router = express.Router();
const IoTDevice = require('../models/IoTDevice');
const { authMiddleware, adminMiddleware } = require('../middleware/authMiddleware');

// GET all IoT devices
router.get('/', authMiddleware, async (req, res) => {
  try {
    const devices = await IoTDevice.find().sort({ name: 1 });
    
    res.json({
      success: true,
      count: devices.length,
      data: devices
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching IoT devices',
      error: error.message
    });
  }
});

// GET single IoT device
router.get('/:id', authMiddleware, async (req, res) => {
  try {
    const device = await IoTDevice.findById(req.params.id);
    
    if (!device) {
      return res.status(404).json({
        success: false,
        message: 'IoT device not found'
      });
    }
    
    res.json({
      success: true,
      data: device
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching IoT device',
      error: error.message
    });
  }
});

// POST create IoT device (admin only)
router.post('/', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const { name, description, apiEndpoint, isActive } = req.body;
    
    // Validate required fields
    if (!name) {
      return res.status(400).json({
        success: false,
        message: 'Device name is required'
      });
    }
    
    if (!apiEndpoint) {
      return res.status(400).json({
        success: false,
        message: 'API endpoint is required'
      });
    }
    
    // Validate API endpoint format (basic URL validation)
    try {
      new URL(apiEndpoint);
    } catch (error) {
      return res.status(400).json({
        success: false,
        message: 'Invalid API endpoint URL format'
      });
    }
    
    // Check if device name already exists
    const existingDevice = await IoTDevice.findOne({ name: name.trim() });
    if (existingDevice) {
      return res.status(400).json({
        success: false,
        message: 'Device name already exists'
      });
    }
    
    const device = new IoTDevice({
      name: name.trim(),
      description: description?.trim(),
      apiEndpoint: apiEndpoint.trim(),
      isActive: isActive !== undefined ? isActive : true,
      status: 'offline',
      createdAt: new Date(),
      updatedAt: new Date()
    });
    
    await device.save();
    
    res.status(201).json({
      success: true,
      message: 'IoT device created successfully',
      data: device
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error creating IoT device',
      error: error.message
    });
  }
});

// PUT update IoT device (admin only)
router.put('/:id', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const { name, description, apiEndpoint, isActive } = req.body;
    
    const device = await IoTDevice.findById(req.params.id);
    
    if (!device) {
      return res.status(404).json({
        success: false,
        message: 'IoT device not found'
      });
    }
    
    // Validate API endpoint format if provided
    if (apiEndpoint) {
      try {
        new URL(apiEndpoint);
      } catch (error) {
        return res.status(400).json({
          success: false,
          message: 'Invalid API endpoint URL format'
        });
      }
    }
    
    // Check if new device name already exists (if changing)
    if (name && name !== device.name) {
      const existingDevice = await IoTDevice.findOne({ 
        name: name.trim(),
        _id: { $ne: device._id }
      });
      
      if (existingDevice) {
        return res.status(400).json({
          success: false,
          message: 'Device name already exists'
        });
      }
    }
    
    // Update fields
    if (name) device.name = name.trim();
    if (description !== undefined) device.description = description?.trim();
    if (apiEndpoint) device.apiEndpoint = apiEndpoint.trim();
    if (isActive !== undefined) device.isActive = isActive;
    device.updatedAt = new Date();
    
    await device.save();
    
    res.json({
      success: true,
      message: 'IoT device updated successfully',
      data: device
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error updating IoT device',
      error: error.message
    });
  }
});

// DELETE IoT device (admin only)
router.delete('/:id', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const device = await IoTDevice.findById(req.params.id);
    
    if (!device) {
      return res.status(404).json({
        success: false,
        message: 'IoT device not found'
      });
    }
    
    // Check if device is being used by any room
    const Room = require('../models/Room');
    const roomCount = await Room.countDocuments({ iotDeviceId: device._id.toString() });
    
    if (roomCount > 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete device that is being used by rooms',
        roomCount: roomCount
      });
    }
    
    await device.deleteOne();
    
    res.json({
      success: true,
      message: 'IoT device deleted successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error deleting IoT device',
      error: error.message
    });
  }
});

// PATCH update device status (for simulation or real IoT device)
router.patch('/:id/status', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const { status, lastUpdate } = req.body;
    
    const device = await IoTDevice.findById(req.params.id);
    
    if (!device) {
      return res.status(404).json({
        success: false,
        message: 'IoT device not found'
      });
    }
    
    const validStatuses = ['online', 'offline', 'error'];
    if (status && !validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid status. Must be online, offline, or error'
      });
    }
    
    if (status) device.status = status;
    if (lastUpdate) device.lastUpdate = new Date(lastUpdate);
    device.updatedAt = new Date();
    
    await device.save();
    
    res.json({
      success: true,
      message: 'Device status updated successfully',
      data: device
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error updating device status',
      error: error.message
    });
  }
});

router.post('/force-poll', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const iotService = require('../services/iotService');
    const result = await iotService.forcePollAll();
    
    res.json({
      success: true,
      message: 'Force polling initiated',
      ...result
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error forcing poll',
      error: error.message
    });
  }
});

// Get IoT service status
router.get('/service/status', authMiddleware, async (req, res) => {
  try {
    const iotService = require('../services/iotService');
    const simulationService = require('../services/simulationService'); // TAMBAH
    
    const iotStatus = iotService.getStatus();
    const simulationStatus = simulationService.getStatus(); // TAMBAH
    
    res.json({
      success: true,
      data: {
        iot: iotStatus,
        simulation: simulationStatus, // TAMBAH
        summary: {
          iotRunning: iotStatus.isRunning,
          simulationRunning: simulationStatus.isRunning,
          totalServices: (iotStatus.isRunning ? 1 : 0) + (simulationStatus.isRunning ? 1 : 0)
        }
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error getting service status',
      error: error.message
    });
  }
});

module.exports = router;

---------------------------------------------------------------------------------------------------------------------------------------
src/routes/roomRoutes.js

// File: src/routes/roomRoutes.js
const express = require('express');
const router = express.Router();
const Room = require('../models/Room');
const Building = require('../models/Building');
const { authMiddleware, adminMiddleware } = require('../middleware/authMiddleware');

// Helper untuk broadcast room update - DIPERBAIKI LENGKAP
const broadcastRoomUpdate = (io, room, action, oldData = null) => {
  if (io) {
    const updateData = {
      action: action, // 'created', 'updated', 'deleted'
      room: {
        id: room._id,
        name: room.name,
        buildingId: room.building,
        buildingName: room.buildingName,
        dataSource: room.dataSource,
        iotDeviceId: room.iotDeviceId,
        isActive: room.isActive,
        currentAQI: room.currentAQI,
        currentData: room.currentData,
        createdAt: room.createdAt,
        updatedAt: room.updatedAt
      },
      oldData: oldData, // Untuk tracking perubahan
      timestamp: new Date()
    };
    
    // Broadcast ke channel spesifik room
    io.to(room._id.toString()).emit('room-updated', updateData);
    
    // Broadcast ke semua client di dashboard
    io.emit('dashboard-room-updated', updateData);
    
    // ðŸ”¥ PERBAIKAN UTAMA: Broadcast perubahan spesifik jika ada
    if (oldData) {
      // Jika nama berubah
      if (oldData.name !== room.name) {
        console.log(`ðŸ”„ Broadcasting room name change: ${oldData.name} -> ${room.name}`);
        
        io.emit('room-name-changed', {
          roomId: room._id,
          oldName: oldData.name,
          newName: room.name,
          buildingName: room.buildingName,
          timestamp: new Date()
        });
        
        // Juga broadcast ke channel spesifik room
        io.to(room._id.toString()).emit('room-name-updated', {
          roomId: room._id,
          oldName: oldData.name,
          newName: room.name,
          buildingName: room.buildingName,
          timestamp: new Date()
        });
      }
      
      // Jika building berubah
      if (oldData.buildingId !== room.building.toString()) {
        io.emit('room-building-changed', {
          roomId: room._id,
          oldBuildingId: oldData.buildingId,
          newBuildingId: room.building,
          oldBuildingName: oldData.buildingName,
          newBuildingName: room.buildingName,
          timestamp: new Date()
        });
      }
      
      // Jika status aktif berubah
      if (oldData.isActive !== room.isActive) {
        io.emit('room-status-changed', {
          roomId: room._id,
          oldStatus: oldData.isActive,
          newStatus: room.isActive,
          roomName: room.name,
          buildingName: room.buildingName,
          timestamp: new Date()
        });
      }
    }
    
    console.log(`ðŸ“¢ Broadcast room ${action}: ${room.name} (${room._id})`);
  }
};

// GET all rooms
router.get('/', async (req, res) => {
  try {
    const rooms = await Room.find()
      .populate('building', 'name code')
      .sort({ name: 1 });
    
    res.json({
      success: true,
      count: rooms.length,
      data: rooms
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching rooms',
      error: error.message
    });
  }
});

// GET single room
router.get('/:id', async (req, res) => {
  try {
    const room = await Room.findById(req.params.id)
      .populate('building', 'name code');
    
    if (!room) {
      return res.status(404).json({
        success: false,
        message: 'Room not found'
      });
    }
    
    res.json({
      success: true,
      data: room
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching room',
      error: error.message
    });
  }
});

// POST create room (admin only)
router.post('/', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const { name, buildingId, dataSource, iotDeviceId, isActive } = req.body;
    const io = req.app.get('socketio');
    
    // Validate required fields
    if (!name) {
      return res.status(400).json({
        success: false,
        message: 'Room name is required'
      });
    }
    
    if (!buildingId) {
      return res.status(400).json({
        success: false,
        message: 'Building ID is required'
      });
    }
    
    // Check if building exists
    const building = await Building.findById(buildingId);
    if (!building) {
      return res.status(404).json({
        success: false,
        message: 'Building not found'
      });
    }
    
    // Validate dataSource
    const validDataSources = ['simulation', 'iot'];
    if (dataSource && !validDataSources.includes(dataSource)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid data source. Must be "simulation" or "iot"'
      });
    }
    
    // For IoT source, iotDeviceId is required
    if (dataSource === 'iot' && !iotDeviceId) {
      return res.status(400).json({
        success: false,
        message: 'IoT Device ID is required for IoT data source'
      });
    }
    
    // Check if room name already exists in the same building
    const existingRoom = await Room.findOne({
      name: name.trim(),
      building: buildingId
    });
    
    if (existingRoom) {
      return res.status(400).json({
        success: false,
        message: 'Room name already exists in this building'
      });
    }
    
    // Create room with synced building name
    const room = new Room({
      name: name.trim(),
      building: buildingId,
      buildingName: building.name, // Get building name from Building collection
      dataSource: dataSource || 'simulation',
      iotDeviceId: dataSource === 'iot' ? iotDeviceId : null,
      isActive: isActive !== undefined ? isActive : true,
      currentAQI: 0,
      currentData: {
        pm25: 0,
        pm10: 0,
        co2: 0,
        temperature: 0,
        humidity: 0,
        updatedAt: new Date()
      },
      createdAt: new Date(),
      updatedAt: new Date()
    });
    
    await room.save();
    
    // Update building room count
    building.roomCount = await Room.countDocuments({ building: buildingId });
    await building.save();
    
    // ðŸ”¥ PERBAIKAN: Broadcast room creation
    if (io) {
      broadcastRoomUpdate(io, room, 'created');
    }
    
    res.status(201).json({
      success: true,
      message: 'Room created successfully',
      data: room
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error creating room',
      error: error.message
    });
  }
});

// PUT update room (admin only) - PERBAIKAN UTAMA LENGKAP
router.put('/:id', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const { name, buildingId, dataSource, iotDeviceId, isActive } = req.body;
    const io = req.app.get('socketio');
    
    const room = await Room.findById(req.params.id)
      .populate('building', 'name');
    
    if (!room) {
      return res.status(404).json({
        success: false,
        message: 'Room not found'
      });
    }
    
    // ðŸ”¥ SIMPAN DATA LAMA UNTUK PERBANDINGAN
    const oldData = {
      name: room.name,
      buildingId: room.building._id ? room.building._id.toString() : room.building.toString(),
      buildingName: room.buildingName,
      dataSource: room.dataSource,
      isActive: room.isActive,
      iotDeviceId: room.iotDeviceId
    };
    
    console.log(`ðŸ”„ Room update request for: ${room.name}`);
    console.log(`   Old data:`, oldData);
    console.log(`   New data:`, { name, buildingId, dataSource, iotDeviceId, isActive });
    
    // Validate dataSource if provided
    const validDataSources = ['simulation', 'iot'];
    if (dataSource && !validDataSources.includes(dataSource)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid data source. Must be "simulation" or "iot"'
      });
    }
    
    // For IoT source, iotDeviceId is required
    if (dataSource === 'iot' && !iotDeviceId) {
      return res.status(400).json({
        success: false,
        message: 'IoT Device ID is required for IoT data source'
      });
    }
    
    let buildingChanged = false;
    let oldBuildingId = null;
    let newBuilding = null;
    
    // If building is being changed
    if (buildingId && buildingId !== room.building.toString()) {
      newBuilding = await Building.findById(buildingId);
      if (!newBuilding) {
        return res.status(404).json({
          success: false,
          message: 'Building not found'
        });
      }
      
      // Check if room name already exists in the new building
      const existingRoom = await Room.findOne({
        name: name || room.name,
        building: buildingId,
        _id: { $ne: room._id }
      });
      
      if (existingRoom) {
        return res.status(400).json({
          success: false,
          message: 'Room name already exists in the new building'
        });
      }
      
      oldBuildingId = room.building;
      room.building = buildingId;
      room.buildingName = newBuilding.name; // Update building name from new building
      buildingChanged = true;
      console.log(`   Building changed: ${oldData.buildingName} -> ${newBuilding.name}`);
    } else if (name && name !== room.name) {
      // Check if room name already exists in the same building
      const existingRoom = await Room.findOne({
        name: name,
        building: room.building,
        _id: { $ne: room._id }
      });
      
      if (existingRoom) {
        return res.status(400).json({
          success: false,
          message: 'Room name already exists in this building'
        });
      }
    }
    
    // Update fields
    if (name) {
      console.log(`   Name changed: ${room.name} -> ${name}`);
      room.name = name.trim();
    }
    if (dataSource !== undefined) {
      console.log(`   Data source changed: ${room.dataSource} -> ${dataSource}`);
      room.dataSource = dataSource;
      room.iotDeviceId = dataSource === 'iot' ? iotDeviceId : null;
    }
    if (iotDeviceId !== undefined && dataSource === 'iot') {
      room.iotDeviceId = iotDeviceId;
    }
    if (isActive !== undefined) {
      console.log(`   Status changed: ${room.isActive} -> ${isActive}`);
      room.isActive = isActive;
    }
    room.updatedAt = new Date();
    
    // If building didn't change, ensure buildingName is synced
    if (!buildingChanged) {
      const currentBuilding = await Building.findById(room.building);
      if (currentBuilding && room.buildingName !== currentBuilding.name) {
        console.log(`   Syncing building name: ${room.buildingName} -> ${currentBuilding.name}`);
        room.buildingName = currentBuilding.name;
      }
    }
    
    await room.save();
    
    // Update building room counts if building changed
    if (buildingChanged) {
      // Update old building count
      if (oldBuildingId) {
        const oldBuilding = await Building.findById(oldBuildingId);
        if (oldBuilding) {
          oldBuilding.roomCount = await Room.countDocuments({ building: oldBuildingId });
          await oldBuilding.save();
          
          // Broadcast old building update
          if (io) {
            io.emit('building-updated', {
              action: 'room-removed',
              buildingId: oldBuildingId,
              roomId: room._id,
              roomName: room.name,
              timestamp: new Date()
            });
          }
        }
      }
      
      // Update new building count
      if (newBuilding) {
        newBuilding.roomCount = await Room.countDocuments({ building: buildingId });
        await newBuilding.save();
        
        // Broadcast new building update
        if (io) {
          io.emit('building-updated', {
            action: 'room-added',
            buildingId: buildingId,
            roomId: room._id,
            roomName: room.name,
            timestamp: new Date()
          });
        }
      }
    } else {
      // Update current building count
      const currentBuilding = await Building.findById(room.building);
      if (currentBuilding) {
        currentBuilding.roomCount = await Room.countDocuments({ building: room.building });
        await currentBuilding.save();
      }
    }
    
    // ðŸ”¥ PERBAIKAN UTAMA: Broadcast room update melalui WebSocket
    if (io) {
      console.log(`ðŸ“¢ Broadcasting room update via WebSocket...`);
      broadcastRoomUpdate(io, room, 'updated', oldData);
      
      // Special handling for name changes
      if (name && name !== oldData.name) {
        console.log(`   ðŸš€ Sending room-name-changed event`);
        
        // Additional broadcast for immediate UI update
        io.emit('room-name-changed-immediate', {
          roomId: room._id,
          oldName: oldData.name,
          newName: room.name,
          buildingName: room.buildingName,
          timestamp: new Date()
        });
      }
    }
    
    // Log perubahan
    const changes = {
      nameChanged: name && name !== oldData.name,
      buildingChanged: buildingChanged,
      dataSourceChanged: dataSource && dataSource !== oldData.dataSource,
      statusChanged: isActive !== undefined && isActive !== oldData.isActive
    };
    
    console.log(`âœ… Room updated successfully. Changes:`, changes);
    
    res.json({
      success: true,
      message: 'Room updated successfully',
      data: room,
      changes: changes
    });
  } catch (error) {
    console.error('âŒ Error updating room:', error);
    res.status(500).json({
      success: false,
      message: 'Error updating room',
      error: error.message
    });
  }
});

// DELETE room (admin only)
router.delete('/:id', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const io = req.app.get('socketio');
    const room = await Room.findById(req.params.id);
    
    if (!room) {
      return res.status(404).json({
        success: false,
        message: 'Room not found'
      });
    }
    
    const buildingId = room.building;
    const roomData = {
      id: room._id,
      name: room.name,
      buildingName: room.buildingName
    };
    
    await room.deleteOne();
    
    // Update building room count
    const building = await Building.findById(buildingId);
    if (building) {
      building.roomCount = await Room.countDocuments({ building: buildingId });
      await building.save();
      
      // Broadcast building update
      if (io) {
        io.emit('building-updated', {
          action: 'room-deleted',
          buildingId: buildingId,
          room: roomData,
          timestamp: new Date()
        });
      }
    }
    
    // Broadcast room deletion
    if (io) {
      io.emit('room-deleted', {
        roomId: room._id,
        roomName: room.name,
        buildingName: room.buildingName,
        timestamp: new Date()
      });
      
      // Juga kirim ke channel spesifik room
      io.to(room._id.toString()).emit('room-updated', {
        action: 'deleted',
        room: roomData,
        timestamp: new Date()
      });
    }
    
    res.json({
      success: true,
      message: 'Room deleted successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error deleting room',
      error: error.message
    });
  }
});

// ðŸ”¥ BARU: Endpoint untuk force refresh room data
router.post('/:id/force-refresh', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const io = req.app.get('socketio');
    const room = await Room.findById(req.params.id);
    
    if (!room) {
      return res.status(404).json({
        success: false,
        message: 'Room not found'
      });
    }
    
    if (io) {
      // Broadcast refresh event
      io.emit('room-force-refresh', {
        roomId: room._id,
        roomName: room.name,
        timestamp: new Date()
      });
      
      io.to(room._id.toString()).emit('room-refresh-requested', {
        timestamp: new Date()
      });
    }
    
    res.json({
      success: true,
      message: 'Force refresh broadcasted',
      roomId: room._id,
      roomName: room.name
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error forcing refresh',
      error: error.message
    });
  }
});

// ðŸ”¥ BARU: Endpoint untuk sync room dengan building name
router.post('/:id/sync-building', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const io = req.app.get('socketio');
    const room = await Room.findById(req.params.id).populate('building', 'name');
    
    if (!room) {
      return res.status(404).json({
        success: false,
        message: 'Room not found'
      });
    }
    
    const oldBuildingName = room.buildingName;
    const newBuildingName = room.building.name;
    
    if (oldBuildingName !== newBuildingName) {
      room.buildingName = newBuildingName;
      room.updatedAt = new Date();
      await room.save();
      
      // Broadcast update
      if (io) {
        io.emit('room-building-synced', {
          roomId: room._id,
          oldBuildingName: oldBuildingName,
          newBuildingName: newBuildingName,
          timestamp: new Date()
        });
      }
      
      res.json({
        success: true,
        message: 'Building name synced',
        oldBuildingName,
        newBuildingName
      });
    } else {
      res.json({
        success: true,
        message: 'Building name already synced',
        buildingName: newBuildingName
      });
    }
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error syncing building name',
      error: error.message
    });
  }
});

module.exports = router;

---------------------------------------------------------------------------------------------------------------------------------------
src/routes/seedRoute.js:

const express = require('express');
const router = express.Router();
const { seedSampleData, clearSampleData } = require('../utils/seedData');
const { authMiddleware, adminMiddleware } = require('../middleware/authMiddleware');

// Seed sample data (admin only)
router.post('/seed', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const result = await seedSampleData();
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: 'Error seeding data',
      error: error.message 
    });
  }
});

// Clear sample data (admin only)
router.post('/clear', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const result = await clearSampleData();
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: 'Error clearing data',
      error: error.message 
    });
  }
});

module.exports = router;

---------------------------------------------------------------------------------------------------------------------------------------
seedRoutes.js

const express = require('express');
const router = express.Router();
const { seedSampleData, clearSampleData } = require('../utils/seedData');
const { authMiddleware, adminMiddleware } = require('../middleware/authMiddleware');
const SensorData = require('../models/SensorData');
const Room = require('../models/Room');

// Seed sample data (admin only)
router.post('/seed', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const result = await seedSampleData();
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: 'Error seeding data',
      error: error.message 
    });
  }
});

// Clear sample data (admin only)
router.post('/clear', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const result = await clearSampleData();
    res.json(result);
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: 'Error clearing data',
      error: error.message 
    });
  }
});


module.exports = router;

---------------------------------------------------------------------------------------------------------------------------------------
sensorDataRoutes.js

const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');
const SensorData = require('../models/SensorData');
const { authMiddleware } = require('../middleware/authMiddleware');

// Helper function untuk convert string ke ObjectId
const toObjectId = (id) => {
  try {
    return new mongoose.Types.ObjectId(id);
  } catch (error) {
    return null;
  }
};

// GET sensor data for a room dengan data aggregation
router.get('/:roomId', authMiddleware, async (req, res) => {
  try {
    const { roomId } = req.params;
    
    // Validasi roomId
    if (!mongoose.Types.ObjectId.isValid(roomId)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid room ID format'
      });
    }
    
    // Ambil data 24 jam terakhir
    const now = new Date();
    const dateFilter = { timestamp: { $gte: new Date(now - 24 * 60 * 60 * 1000) } };
    
    // Ambil SEMUA data 24 jam (tanpa limit)
    const sensorData = await SensorData.find({
      roomId: toObjectId(roomId),
      ...dateFilter
    })
    .sort({ timestamp: 1 });
    
    res.json({
      success: true,
      data: sensorData,
      count: sensorData.length,
      message: '24 hours data loaded'
    });
  } catch (error) {
    console.error('Error fetching sensor data:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching sensor data',
      error: error.message
    });
  }
});

// NEW: GET sensor data by date untuk grafik history
router.get('/:roomId/history', authMiddleware, async (req, res) => {
  try {
    const { roomId } = req.params;
    const { date, interval = 30 } = req.query; // interval dalam menit
    
    // Validasi roomId
    if (!mongoose.Types.ObjectId.isValid(roomId)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid room ID format'
      });
    }
    
    // Parse tanggal
    let startDate, endDate;
    if (date) {
      // Jika ada tanggal spesifik
      const selectedDate = new Date(date);
      startDate = new Date(selectedDate.setHours(0, 0, 0, 0));
      endDate = new Date(selectedDate.setHours(23, 59, 59, 999));
    } else {
      // Default: hari ini
      const today = new Date();
      startDate = new Date(today.setHours(0, 0, 0, 0));
      endDate = new Date(today.setHours(23, 59, 59, 999));
    }
    
    console.log(`ðŸ“Š Fetching history data for room ${roomId} from ${startDate} to ${endDate}`);
    
    // Aggregation pipeline untuk data per interval
    const aggregationPipeline = [
      {
        $match: {
          roomId: toObjectId(roomId),
          timestamp: { $gte: startDate, $lte: endDate }
        }
      },
      {
        $addFields: {
          // Buat interval waktu (misal: 30 menit)
          timeInterval: {
            $subtract: [
              { $minute: "$timestamp" },
              { $mod: [{ $minute: "$timestamp" }, parseInt(interval)] }
            ]
          }
        }
      },
      {
        $group: {
          _id: {
            hour: { $hour: "$timestamp" },
            interval: "$timeInterval"
          },
          // Ambil data terakhir di setiap interval
          timestamp: { $last: "$timestamp" },
          aqi: { $last: "$aqi" },
          pm25: { $last: "$pm25" },
          pm10: { $last: "$pm10" },
          co2: { $last: "$co2" },
          temperature: { $last: "$temperature" },
          humidity: { $last: "$humidity" },
          category: { $last: "$category" },
          // Juga simpan data mentah untuk tooltip
          rawData: { $push: "$$ROOT" }
        }
      },
      {
        $sort: { "timestamp": 1 }
      },
      {
        $project: {
          _id: 0,
          timestamp: 1,
          hour: "$_id.hour",
          interval: "$_id.interval",
          timeLabel: {
            $concat: [
              { $toString: "$_id.hour" },
              ":",
              { 
                $cond: {
                  if: { $lt: ["$_id.interval", 10] },
                  then: "0",
                  else: ""
                }
              },
              { $toString: "$_id.interval" }
            ]
          },
          aqi: 1,
          pm25: 1,
          pm10: 1,
          co2: 1,
          temperature: 1,
          humidity: 1,
          category: 1,
          rawData: 1
        }
      }
    ];
    
    const aggregatedData = await SensorData.aggregate(aggregationPipeline);
    
    // Jika tidak ada data, coba ambil data mentah
    if (aggregatedData.length === 0) {
      const rawData = await SensorData.find({
        roomId: toObjectId(roomId),
        timestamp: { $gte: startDate, $lte: endDate }
      })
      .sort({ timestamp: 1 });
      
      return res.json({
        success: true,
        data: rawData.map(item => ({
          ...item.toObject(),
          timeLabel: `${item.timestamp.getHours()}:${item.timestamp.getMinutes().toString().padStart(2, '0')}`
        })),
        aggregated: false,
        count: rawData.length,
        message: 'Raw data loaded'
      });
    }
    
    res.json({
      success: true,
      data: aggregatedData, // Atau rawData
      aggregated: true, // Atau false
      count: aggregatedData.length,
      startDate: startDate,
      endDate: endDate,
      message: 'Aggregated history data loaded'
    });
    
  } catch (error) {
    console.error('Error fetching history data:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching history data',
      error: error.message
    });
  }
});

module.exports = router;

---------------------------------------------------------------------------------------------------------------------------------------
src/routes/testRoute.js:

const express = require('express');
const router = express.Router();
const Building = require('../models/Building');
const Room = require('../models/Room');
const SensorData = require('../models/SensorData');

// Test endpoint untuk cek data
router.get('/status', async (req, res) => {
  try {
    const buildingCount = await Building.countDocuments();
    const roomCount = await Room.countDocuments();
    const sensorDataCount = await SensorData.countDocuments();
    
    // Get latest sensor data
    const latestData = await SensorData.findOne().sort({ timestamp: -1 });
    
    res.json({
      success: true,
      data: {
        buildings: buildingCount,
        rooms: roomCount,
        sensorData: sensorDataCount,
        latestUpdate: latestData ? latestData.timestamp : null,
        serverTime: new Date(),
        simulationRunning: true
      }
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: error.message 
    });
  }
});

// Get all buildings
router.get('/buildings', async (req, res) => {
  try {
    const buildings = await Building.find().sort({ name: 1 });
    res.json({
      success: true,
      count: buildings.length,
      data: buildings
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: error.message 
    });
  }
});

// Get all rooms
router.get('/rooms', async (req, res) => {
  try {
    const rooms = await Room.find()
      .populate('building', 'name code')
      .sort({ name: 1 });
    
    res.json({
      success: true,
      count: rooms.length,
      data: rooms
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: error.message 
    });
  }
});

module.exports = router;

---------------------------------------------------------------------------------------------------------------------------------------
iotService.js

const axios = require('axios');
const cron = require('node-cron');
const Room = require('../models/Room');
const IoTDevice = require('../models/IoTDevice');
const SensorData = require('../models/SensorData');
const { getAQICategory } = require('../utils/aqiCalculator');

class IoTService {
  constructor() {
    this.isRunning = false;
    this.task = null;
    this.io = null;
    this.deviceLastData = new Map();
    this.pollingInterval = 10000; // 60 detik untuk IoT
  }

  /**
   * Start IoT polling service
   */
  start(io) {
    if (this.isRunning) {
      console.log('âš ï¸ IoT Service is already running');
      return;
    }

    this.io = io;
    console.log(`ðŸš€ Starting IoT Service (polling every ${this.pollingInterval/1000}s)...`);

    // Schedule task to run every 10 seconds
    this.task = cron.schedule('*/10 * * * * *', async () => {
      await this.pollAllIoTDevices();
    });

    this.isRunning = true;
    console.log('âœ… IoT Service started');

    // Initial poll immediately
    this.pollAllIoTDevices();
  }

  /**
   * Stop IoT service
   */
  stop() {
    if (this.task) {
      this.task.stop();
      this.isRunning = false;
      console.log('â¹ï¸ IoT Service stopped');
    }
  }

  /**
   * Poll all IoT devices
   */
  async pollAllIoTDevices() {
    try {
      // Get all active IoT devices
      const devices = await IoTDevice.find({ 
        isActive: true
      });

      if (devices.length === 0) {
        console.log('â„¹ï¸ No active IoT devices to poll');
        return;
      }

      console.log(`ðŸ”„ Polling ${devices.length} IoT devices...`);

      // Poll devices in parallel
      const pollPromises = devices.map(device => 
        this.pollDevice(device).catch(error => {
          console.error(`âŒ Error polling device ${device.name}:`, error.message);
          return null;
        })
      );

      const results = await Promise.allSettled(pollPromises);
      
      const successfulPolls = results.filter(r => r.status === 'fulfilled' && r.value).length;
      console.log(`âœ… IoT polling completed: ${successfulPolls}/${devices.length} successful`);
      console.log(`âœ… Updated at ${new Date().toLocaleTimeString()}`);
      
    } catch (error) {
      console.error('âŒ Error in pollAllIoTDevices:', error.message);
    }
  }

  /**
   * Poll single IoT device
   */
  async pollDevice(device) {
    try {
      console.log(`ðŸ“¡ Polling device: ${device.name} (${device.apiEndpoint})`);
      const response = await axios.get(device.apiEndpoint, { timeout: 5000 });
      
      if (response.data?.success === true) {
        const iotData = response.data.data;
        
        // Validate IoT data structure
        if (!this.isValidIoTData(iotData)) {
          throw new Error('Invalid IoT data structure');
        }
        
        // Check if data has changed
        const lastData = this.deviceLastData.get(device._id.toString());
        const hasChanged = this._hasDataChanged(lastData, iotData);
        
        // Save last data
        this.deviceLastData.set(device._id.toString(), iotData);
        
        // Update device status
        device.status = 'online';
        device.lastUpdate = new Date();
        await device.save();
        
        // Broadcast if data changed
        if (hasChanged || !lastData) {
          console.log(`ðŸ”„ Data changed for device ${device.name}, broadcasting...`);
          
          // Find rooms using this device
          const rooms = await Room.find({ 
            iotDeviceId: device._id.toString(),
            isActive: true 
          });
          
          // Update and broadcast each room
          for (const room of rooms) {
            await this.updateRoomFromIoT(room, iotData, device.name);
          }
        } else {
          console.log(`â„¹ï¸ No data change for device ${device.name}, skipping broadcast`);
        }
        
        return { success: true, changed: hasChanged };
      }
    } catch (error) {
      // Handle error
      device.status = error.code === 'ECONNABORTED' ? 'offline' : 'error';
      await device.save();
      
      console.error(`âŒ Error polling device ${device.name}:`, error.message);
      return { success: false, error: error.message };
    }
  }

  /**
   * Validate IoT data structure
   */
  isValidIoTData(data) {
    return data && 
           typeof data.aqi === 'number' &&
           typeof data.pm25 === 'number' &&
           typeof data.pm10 === 'number' &&
           typeof data.co2 === 'number' &&
           typeof data.temperature === 'number' &&
           typeof data.humidity === 'number';
  }

  /**
   * Check if data has changed significantly
   */
  _hasDataChanged(oldData, newData) {
    if (!oldData || !newData) return true;
    
    const thresholds = {
      aqi: 1,
      pm25: 1.0,
      pm10: 1.0,
      co2: 1,
      temperature: 0.5,
      humidity: 1.0
    };
    
    return (
      Math.abs(newData.aqi - (oldData.aqi || 0)) > thresholds.aqi ||
      Math.abs(newData.pm25 - (oldData.pm25 || 0)) > thresholds.pm25 ||
      Math.abs(newData.pm10 - (oldData.pm10 || 0)) > thresholds.pm10 ||
      Math.abs(newData.co2 - (oldData.co2 || 0)) > thresholds.co2 ||
      Math.abs(newData.temperature - (oldData.temperature || 0)) > thresholds.temperature ||
      Math.abs(newData.humidity - (oldData.humidity || 0)) > thresholds.humidity
    );
  }

  /**
   * Update room from IoT data
   */
  async updateRoomFromIoT(room, iotData, deviceName) {
    try {
      // Check if room data has changed
      const currentData = room.currentData;
      const hasRoomDataChanged = this._hasDataChanged(
        {
          aqi: room.currentAQI,
          pm25: currentData.pm25,
          pm10: currentData.pm10,
          co2: currentData.co2,
          temperature: currentData.temperature,
          humidity: currentData.humidity
        },
        iotData
      );
      
      if (!hasRoomDataChanged) {
        console.log(`â„¹ï¸ Room ${room.name} data unchanged, skipping update`);
        return;
      }
      
      // Update room data
      const aqiInfo = getAQICategory(iotData.aqi);
      
      room.currentAQI = iotData.aqi;
      room.currentData = {
        pm25: iotData.pm25,
        pm10: iotData.pm10,
        co2: iotData.co2,
        temperature: iotData.temperature,
        humidity: iotData.humidity,
        updatedAt: new Date()
      };
      room.updatedAt = new Date();
      
      await room.save();
      
      // Save historical data
      const historicalData = new SensorData({
        roomId: room._id,
        roomName: room.name,
        buildingName: room.buildingName,
        ...iotData,
        category: aqiInfo.category,
        timestamp: new Date()
      });
      
      await historicalData.save();
      
      // Broadcast via WebSocket
      this.broadcastRoomUpdate(room, iotData, 'iot', deviceName);
      
      console.log(`âœ… Updated & broadcasted IoT room ${room.name}: AQI ${iotData.aqi}`);
      
    } catch (error) {
      console.error(`âŒ Error updating IoT room ${room.name}:`, error.message);
    }
  }

  /**
   * Broadcast room update via Socket.io
   */
  broadcastRoomUpdate(room, data, source, deviceName = null) {
    if (this.io) {
      const updateData = {
        roomId: room._id,
        data: {
          currentAQI: room.currentAQI,
          currentData: room.currentData,
          updatedAt: room.updatedAt
        },
        timestamp: new Date(),
        source: source,
        deviceName: deviceName
      };

      // Broadcast to room-specific channel
      this.io.to(room._id.toString()).emit('room-update', updateData);
      
      // Also broadcast to general updates channel for dashboard
      this.io.emit('dashboard-update', {
        type: 'room-data-updated',
        roomId: room._id,
        aqi: room.currentAQI,
        building: room.buildingName,
        timestamp: new Date()
      });

      console.log(`ðŸ“¢ Broadcast IoT update for room ${room.name}: AQI ${room.currentAQI}`);
    }
  }

  /**
   * Manually trigger polling
   */
  async forcePollAll() {
    console.log('ðŸ”„ Force polling all IoT devices...');
    await this.pollAllIoTDevices();
    return { success: true, message: 'Force poll completed' };
  }

  /**
   * Get IoT service status
   */
  getStatus() {
    return {
      isRunning: this.isRunning,
      lastUpdate: new Date(),
      nextUpdate: new Date(Date.now() + this.pollingInterval),
      socketConnected: this.io !== null,
      pollingInterval: this.pollingInterval
    };
  }
}

// Create singleton instance
const iotService = new IoTService();

module.exports = iotService;

---------------------------------------------------------------------------------------------------------------------------------------
src/services/simulationService.js:

const cron = require('node-cron');
const Room = require('../models/Room');
const SensorData = require('../models/SensorData');
const { getAQICategory } = require('../utils/aqiCalculator');
const { generateSensorData } = require('../utils/dataGenerator');

class SimulationService {
  constructor() {
    this.isRunning = false;
    this.task = null;
    this.io = null;
    this.updateInterval = 60000; // 1 menit
  }

  /**
   * Start simulation service
   */
  start(io) {
    if (this.isRunning) {
      console.log('âš ï¸ Simulation Service is already running');
      return;
    }

    this.io = io;
    console.log(`ðŸš€ Starting Simulation Service (update every ${this.updateInterval/1000}s)...`);

    // Schedule task to run every 1 minute
    this.task = cron.schedule(`*/${this.updateInterval/1000} * * * * *`, async () => {
      await this.updateAllRooms();
    });

    this.isRunning = true;
    console.log('âœ… Simulation Service started');

    // Initial update immediately
    this.updateAllRooms();
  }

  /**
   * Stop simulation service
   */
  stop() {
    if (this.task) {
      this.task.stop();
      this.isRunning = false;
      console.log('â¹ï¸ Simulation Service stopped');
    }
  }

  /**
   * Update all rooms with simulation data
   */
  async updateAllRooms() {
    try {
      // Get all active rooms with simulation data source
      const rooms = await Room.find({ 
        isActive: true,
        dataSource: 'simulation'
      });

      if (rooms.length === 0) {
        console.log('â„¹ï¸ No active simulation rooms to update');
        return;
      }

      console.log(`ðŸ”„ Updating ${rooms.length} simulation rooms...`);

      // Update each room with simulation data
      for (const room of rooms) {
        await this.updateRoom(room);
      }

      console.log(`âœ… Updated ${rooms.length} rooms at ${new Date().toLocaleTimeString()}`);

    } catch (error) {
      console.error('âŒ Error in updateAllRooms:', error.message);
    }
  }

  /**
   * Update single room with simulation data
   */
  async updateRoom(room) {
    try {
      const roomType = this.getRoomType(room.name);
      const sensorData = generateSensorData(roomType);

      // Check if data has changed significantly
      const hasChanged = this._hasDataChanged(room, sensorData);
      
      if (!hasChanged) {
        console.log(`â„¹ï¸ Room ${room.name} data unchanged, skipping update`);
        return;
      }

      // Update room data
      room.currentAQI = sensorData.aqi;
      room.currentData = {
        pm25: sensorData.pm25,
        pm10: sensorData.pm10,
        co2: sensorData.co2,
        temperature: sensorData.temperature,
        humidity: sensorData.humidity,
        updatedAt: new Date()
      };
      room.updatedAt = new Date();

      await room.save();

      // Save historical data
      const historicalData = new SensorData({
        roomId: room._id,
        roomName: room.name,
        buildingName: room.buildingName,
        aqi: sensorData.aqi,
        pm25: sensorData.pm25,
        pm10: sensorData.pm10,
        co2: sensorData.co2,
        temperature: sensorData.temperature,
        humidity: sensorData.humidity,
        category: sensorData.category,
        timestamp: new Date()
      });

      await historicalData.save();

      // Broadcast update via Socket.io
      this.broadcastRoomUpdate(room, sensorData);

    } catch (error) {
      console.error(`âŒ Error updating room ${room.name}:`, error.message);
    }
  }

  /**
   * Check if data has changed significantly
   */
  _hasDataChanged(room, newData) {
    const currentData = room.currentData;
    
    // Define thresholds for significant change
    const thresholds = {
      aqi: 1,
      pm25: 1.0,
      pm10: 1.0,
      co2: 1,
      temperature: 0.5,
      humidity: 1.0
    };
    
    return (
      Math.abs(newData.aqi - room.currentAQI) > thresholds.aqi ||
      Math.abs(newData.pm25 - (currentData.pm25 || 0)) > thresholds.pm25 ||
      Math.abs(newData.pm10 - (currentData.pm10 || 0)) > thresholds.pm10 ||
      Math.abs(newData.co2 - (currentData.co2 || 0)) > thresholds.co2 ||
      Math.abs(newData.temperature - (currentData.temperature || 0)) > thresholds.temperature ||
      Math.abs(newData.humidity - (currentData.humidity || 0)) > thresholds.humidity
    );
  }

  /**
   * Broadcast room update via Socket.io
   */
  broadcastRoomUpdate(room, data) {
    if (this.io) {
      const updateData = {
        roomId: room._id,
        data: {
          currentAQI: room.currentAQI,
          currentData: room.currentData,
          updatedAt: room.updatedAt
        },
        timestamp: new Date(),
        source: 'simulation'
      };

      // Broadcast to room-specific channel
      this.io.to(room._id.toString()).emit('room-update', updateData);
      
      // Also broadcast to general updates channel for dashboard
      this.io.emit('dashboard-update', {
        type: 'room-data-updated',
        roomId: room._id,
        aqi: room.currentAQI,
        building: room.buildingName,
        timestamp: new Date()
      });

      console.log(`ðŸ“¢ Broadcast simulation update for room ${room.name}: AQI ${room.currentAQI}`);
    }
  }

  /**
   * Determine room type based on name
   */
  getRoomType(roomName) {
    const name = roomName.toLowerCase();
    
    if (name.includes('lab') || name.includes('praktikum')) {
      return 'laboratory';
    } else if (name.includes('kelas') || name.includes('ruang') || name.includes('r.') || name.includes('gd.')) {
      return 'classroom';
    } else if (name.includes('perpustakaan') || name.includes('library')) {
      return 'library';
    } else if (name.includes('aula') || name.includes('auditorium') || name.includes('hall')) {
      return 'crowded';
    }
    
    return 'normal';
  }

  /**
   * Manually trigger simulation update
   */
  async forceUpdate() {
    console.log('ðŸ”„ Force updating all simulation rooms...');
    await this.updateAllRooms();
    return { success: true, message: 'Force simulation update completed' };
  }

  /**
   * Get service status
   */
  getStatus() {
    return {
      isRunning: this.isRunning,
      lastUpdate: new Date(),
      nextUpdate: new Date(Date.now() + this.updateInterval),
      socketConnected: this.io !== null,
      updateInterval: this.updateInterval
    };
  }
}

// Create singleton instance
const simulationService = new SimulationService();

module.exports = simulationService;

---------------------------------------------------------------------------------------------------------------------------------------
src/utils/aqiCalculator.js:

/**
 * Calculate AQI based on PM2.5 concentration (US EPA Standard)
 * @param {number} pm25 - PM2.5 concentration in Î¼g/mÂ³
 * @returns {Object} {aqi, category, color}
 */
const calculateAQIFromPM25 = (pm25) => {
  let aqi, category, color;

  // US EPA AQI Breakpoints for PM2.5
  if (pm25 >= 0 && pm25 <= 12.0) {
    aqi = linearScale(pm25, 0, 12.0, 0, 50);
    category = 'baik';
    color = '#00E400'; // Hijau
  } else if (pm25 <= 35.4) {
    aqi = linearScale(pm25, 12.1, 35.4, 51, 100);
    category = 'sedang';
    color = '#FFFF00'; // Kuning
  } else if (pm25 <= 55.4) {
    aqi = linearScale(pm25, 35.5, 55.4, 101, 150);
    category = 'tidak_sehat';
    color = '#FF7E00'; // Oranye
  } else if (pm25 <= 150.4) {
    aqi = linearScale(pm25, 55.5, 150.4, 151, 200);
    category = 'sangat_tidak_sehat';
    color = '#FF0000'; // Merah
  } else if (pm25 <= 250.4) {
    aqi = linearScale(pm25, 150.5, 250.4, 201, 300);
    category = 'berbahaya';
    color = '#8F3F97'; // Ungu
  } else {
    aqi = linearScale(pm25, 250.5, 500.4, 301, 500);
    category = 'berbahaya';
    color = '#7E0023'; // Merah marun
  }

  return {
    aqi: Math.round(aqi),
    category,
    color
  };
};

/**
 * Linear interpolation for AQI calculation
 */
const linearScale = (C, Clow, Chigh, Ilow, Ihigh) => {
  return ((Ihigh - Ilow) / (Chigh - Clow)) * (C - Clow) + Ilow;
};

/**
 * Get category info based on AQI value
 */
const getAQICategory = (aqi) => {
  if (aqi <= 50) {
    return { category: 'baik', color: '#00E400', label: 'Baik' };
  } else if (aqi <= 100) {
    return { category: 'sedang', color: '#FFFF00', label: 'Sedang' };
  } else if (aqi <= 150) {
    return { category: 'tidak_sehat', color: '#FF7E00', label: 'Tidak Sehat' };
  } else if (aqi <= 200) {
    return { category: 'sangat_tidak_sehat', color: '#FF0000', label: 'Sangat Tidak Sehat' };
  } else if (aqi <= 300) {
    return { category: 'berbahaya', color: '#8F3F97', label: 'Berbahaya' };
  } else {
    return { category: 'berbahaya', color: '#7E0023', label: 'Berbahaya' };
  }
};

/**
 * Evaluate parameter status
 */
const evaluateParameter = (type, value) => {
  switch (type) {
    case 'pm25':
      if (value <= 12) return { status: 'baik', color: '#00E400' };
      if (value <= 35.4) return { status: 'sedang', color: '#FFFF00' };
      if (value <= 55.4) return { status: 'tidak_sehat', color: '#FF7E00' };
      if (value <= 150.4) return { status: 'sangat_tidak_sehat', color: '#FF0000' };
      return { status: 'berbahaya', color: '#8F3F97' };

    case 'pm10':
      if (value <= 54) return { status: 'baik', color: '#00E400' };
      if (value <= 154) return { status: 'sedang', color: '#FFFF00' };
      if (value <= 254) return { status: 'tidak_sehat', color: '#FF7E00' };
      if (value <= 354) return { status: 'sangat_tidak_sehat', color: '#FF0000' };
      return { status: 'berbahaya', color: '#8F3F97' };

    case 'co2':
      if (value <= 600) return { status: 'baik', color: '#00E400' };
      if (value <= 1000) return { status: 'sedang', color: '#FFFF00' };
      if (value <= 1500) return { status: 'tidak_sehat', color: '#FF7E00' };
      if (value <= 2000) return { status: 'sangat_tidak_sehat', color: '#FF0000' };
      return { status: 'berbahaya', color: '#8F3F97' };

    case 'temperature':
      if (value >= 22 && value <= 26) return { status: 'ideal', color: '#0066CC' };
      if (value >= 20 && value <= 28) return { status: 'normal', color: '#00E400' };
      if (value >= 18 && value <= 30) return { status: 'sedang', color: '#FFFF00' };
      return { status: 'tidak_ideal', color: '#FF7E00' };

    case 'humidity':
      if (value >= 40 && value <= 60) return { status: 'ideal', color: '#0066CC' };
      if (value >= 30 && value <= 70) return { status: 'normal', color: '#00E400' };
      if (value >= 20 && value <= 80) return { status: 'sedang', color: '#FFFF00' };
      return { status: 'tidak_ideal', color: '#FF7E00' };

    default:
      return { status: 'unknown', color: '#CCCCCC' };
  }
};

module.exports = {
  calculateAQIFromPM25,
  getAQICategory,
  evaluateParameter
};

---------------------------------------------------------------------------------------------------------------------------------------
src/utils/auth.js:

const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

// Generate JWT token
const generateToken = (userId, username, role) => {
  return jwt.sign(
    { id: userId, username, role },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );
};

// Hash password
const hashPassword = async (password) => {
  const salt = await bcrypt.genSalt(10);
  return await bcrypt.hash(password, salt);
};

// Compare password
const comparePassword = async (password, hashedPassword) => {
  return await bcrypt.compare(password, hashedPassword);
};

// Verify JWT token
const verifyToken = (token) => {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch (error) {
    return null;
  }
};

module.exports = {
  generateToken,
  hashPassword,
  comparePassword,
  verifyToken
};

---------------------------------------------------------------------------------------------------------------------------------------
src/utils/dataGenerator.js:

const { calculateAQIFromPM25 } = require('./aqiCalculator');

/**
 * Generate random sensor data within realistic ranges
 */
const generateSensorData = (roomType = 'normal') => {
  // Base values depending on room type
  let basePM25, basePM10, baseCO2, baseTemp, baseHumidity;

  switch (roomType) {
    case 'laboratory':
      basePM25 = 8;
      basePM10 = 15;
      baseCO2 = 500;
      baseTemp = 23;
      baseHumidity = 50;
      break;
    case 'classroom':
      basePM25 = 12;
      basePM10 = 25;
      baseCO2 = 700;
      baseTemp = 25;
      baseHumidity = 55;
      break;
    case 'library':
      basePM25 = 6;
      basePM10 = 12;
      baseCO2 = 450;
      baseTemp = 22;
      baseHumidity = 48;
      break;
    case 'crowded':
      basePM25 = 25;
      basePM10 = 45;
      baseCO2 = 1200;
      baseTemp = 27;
      baseHumidity = 65;
      break;
    default: // normal
      basePM25 = 15;
      basePM10 = 30;
      baseCO2 = 600;
      baseTemp = 24;
      baseHumidity = 52;
  }

  // Add randomness (Â±30% of base value)
  const randomFactor = () => (Math.random() * 0.6) + 0.7; // 0.7 to 1.3

  const pm25 = Math.max(0, basePM25 * randomFactor());
  const pm10 = Math.max(0, basePM10 * randomFactor());
  const co2 = Math.max(300, baseCO2 * randomFactor());
  const temperature = baseTemp + (Math.random() * 4 - 2); // Â±2Â°C
  const humidity = Math.max(20, Math.min(90, baseHumidity + (Math.random() * 10 - 5))); // Â±5%

  // Calculate AQI from PM2.5
  const { aqi, category } = calculateAQIFromPM25(pm25);

  return {
    pm25: parseFloat(pm25.toFixed(1)),
    pm10: parseFloat(pm10.toFixed(1)),
    co2: Math.round(co2),
    temperature: parseFloat(temperature.toFixed(1)),
    humidity: Math.round(humidity),
    aqi,
    category,
    timestamp: new Date()
  };
};

const simulateAnomaly = (normalData) => {
  const anomalyType = Math.random();
  
  if (anomalyType < 0.05) { // 5% chance of anomaly
    // High pollution
    const highPollutionData = {
      ...normalData,
      pm25: normalData.pm25 * (3 + Math.random() * 2),
      pm10: normalData.pm10 * (3 + Math.random() * 2),
      co2: normalData.co2 * (1.5 + Math.random())
    };
    
    // Recalculate AQI for high pollution
    const { aqi, category } = calculateAQIFromPM25(highPollutionData.pm25);
    highPollutionData.aqi = Math.min(500, aqi);
    highPollutionData.category = category;
    
    return highPollutionData;
    
  } else if (anomalyType < 0.08) { // 3% chance
    // Sensor error (negative or extreme values)
    return {
      ...normalData,
      pm25: -1,
      pm10: -1,
      co2: -1,
      aqi: -1,
      category: 'error' // PASTIKAN 'error' ada di enum
    };
  }
  
  return normalData;
};

module.exports = {
  generateSensorData,
  simulateAnomaly
};

---------------------------------------------------------------------------------------------------------------------------------------
src/utils/seedData.js:

const Building = require('../models/Building');
const Room = require('../models/Room');
const IoTDevice = require('../models/IoTDevice');

const sampleBuildings = [
  {
    name: 'Gedung H',
    code: 'H',
    description: 'Gedung Fakultas Teknik'
  },
  {
    name: 'Gedung M',
    code: 'M',
    description: 'Gedung Fakultas MIPA'
  },
  {
    name: 'Gedung A',
    code: 'A',
    description: 'Gedung Administrasi'
  },
  {
    name: 'Perpustakaan Pusat',
    code: 'LIB',
    description: 'Perpustakaan Universitas'
  }
];

const sampleRooms = [
  // Gedung H
  { name: 'H101', buildingCode: 'H', dataSource: 'simulation' },
  { name: 'H102', buildingCode: 'H', dataSource: 'simulation' },
  { name: 'H201', buildingCode: 'H', dataSource: 'simulation' },
  { name: 'Lab Komputer H', buildingCode: 'H', dataSource: 'simulation' },
  
  // Gedung M
  { name: 'M101', buildingCode: 'M', dataSource: 'simulation' },
  { name: 'M102', buildingCode: 'M', dataSource: 'simulation' },
  { name: 'Lab Kimia M', buildingCode: 'M', dataSource: 'simulation' },
  
  // Gedung A
  { name: 'A101', buildingCode: 'A', dataSource: 'simulation' },
  { name: 'Ruang Rapat A', buildingCode: 'A', dataSource: 'simulation' },
  
  // Perpustakaan
  { name: 'Lobi Perpustakaan', buildingCode: 'LIB', dataSource: 'simulation' },
  { name: 'Ruang Baca', buildingCode: 'LIB', dataSource: 'simulation' }
];

const seedSampleData = async () => {
  try {
    console.log('ðŸŒ± Seeding sample data...');

    // CREATE BUILDINGS tanpa menggunakan save() yang trigger hooks
    const buildings = {};
    
    for (const buildingData of sampleBuildings) {
      try {
        // Cek apakah building sudah ada
        const existingBuilding = await Building.findOne({ code: buildingData.code });
        
        if (existingBuilding) {
          console.log(`â© Building ${buildingData.code} already exists, skipping`);
          buildings[buildingData.code] = existingBuilding;
          continue;
        }

        // Gunakan insertOne untuk bypass hooks
        const result = await Building.collection.insertOne({
          ...buildingData,
          roomCount: 0,
          createdAt: new Date(),
          updatedAt: new Date()
        });
        
        const building = await Building.findById(result.insertedId);
        buildings[buildingData.code] = building;
        console.log(`âœ… Created building: ${building.name} (${building.code})`);
      } catch (error) {
        console.error(`âŒ Error creating building ${buildingData.code}:`, error.message);
      }
    }

    // CREATE ROOMS dengan buildingName yang benar
    let roomCount = 0;
    for (const roomData of sampleRooms) {
      try {
        const building = buildings[roomData.buildingCode];
        if (building) {
          // Cek apakah room sudah ada
          const existingRoom = await Room.findOne({ 
            name: roomData.name, 
            building: building._id 
          });
          
          if (existingRoom) {
            console.log(`â© Room ${roomData.name} already exists, skipping`);
            continue;
          }

          // Gunakan insertOne untuk bypass hooks dengan buildingName yang benar
          const result = await Room.collection.insertOne({
            name: roomData.name,
            building: building._id,
            buildingName: building.name, // Menggunakan nama building yang benar
            dataSource: roomData.dataSource,
            isActive: true,
            currentAQI: 0,
            currentData: {
              pm25: 0,
              pm10: 0,
              co2: 0,
              temperature: 0,
              humidity: 0,
              updatedAt: new Date()
            },
            createdAt: new Date(),
            updatedAt: new Date()
          });
          
          // Update building room count secara manual
          await Building.collection.updateOne(
            { _id: building._id },
            { $inc: { roomCount: 1 } }
          );
          
          roomCount++;
          console.log(`âœ… Created room: ${roomData.name} in ${building.name}`);
        }
      } catch (error) {
        console.error(`âŒ Error creating room ${roomData.name}:`, error.message);
      }
    }

    console.log(`ðŸŽ‰ Sample data seeding completed! Created ${roomCount} rooms.`);
    return { success: true, message: `Created ${roomCount} rooms` };
    
  } catch (error) {
    console.error('âŒ Error seeding sample data:', error);
    return { success: false, message: error.message };
  }
};

const clearSampleData = async () => {
  try {
    await Room.deleteMany({});
    await Building.deleteMany({});
    console.log('ðŸ—‘ï¸  Sample data cleared');
    return { success: true, message: 'Data cleared' };
  } catch (error) {
    console.error('âŒ Error clearing data:', error);
    return { success: false, message: error.message };
  }
};

// Fungsi untuk sync building names
const syncBuildingNames = async () => {
  try {
    console.log('ðŸ”„ Syncing building names in rooms...');
    
    const rooms = await Room.find().populate('building', 'name');
    let updatedCount = 0;
    
    for (const room of rooms) {
      if (room.building && room.buildingName !== room.building.name) {
        room.buildingName = room.building.name;
        await room.save();
        updatedCount++;
      }
    }
    
    console.log(`âœ… Synced building names for ${updatedCount} rooms`);
    return { success: true, message: `Synced ${updatedCount} rooms` };
  } catch (error) {
    console.error('âŒ Error syncing building names:', error);
    return { success: false, message: error.message };
  }
};

// PERHATIAN: Ekspor dengan nama yang benar!
module.exports = {
  seedSampleData,
  clearSampleData,
  syncBuildingNames  // Tambahkan fungsi sync
};

---------------------------------------------------------------------------------------------------------------------------------------
src/app.js:

const mongoose = require('mongoose');
const express = require('express');
const cors = require('cors');
const http = require('http');
const socketIo = require('socket.io');
const simulationService = require('./services/simulationService');
const iotService = require('./services/iotService');
const { seedSampleData } = require('./utils/seedData');
const seedRoutes = require('./routes/seedRoutes');
const testRoutes = require('./routes/testRoutes');
const buildingRoutes = require('./routes/buildingRoutes');
const roomRoutes = require('./routes/roomRoutes');
const iotDeviceRoutes = require('./routes/iotDeviceRoutes');
const sensorDataRoutes = require('./routes/sensorDataRoutes');

require('dotenv').config();

const User = require('./models/User');
const Building = require('./models/Building');
const Room = require('./models/Room');
const SensorData = require('./models/SensorData');
const IoTDevice = require('./models/IoTDevice');
const authRoutes = require('./routes/authRoutes');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: "*", // Allow all origins for development
    methods: ["GET", "POST", "PUT", "DELETE"],
    credentials: true
  }
});

// Middleware
app.use(cors());
app.use(express.json());

// Routesf
app.use('/api/auth', authRoutes);
app.use('/api/seed', seedRoutes);
app.use('/api/test', testRoutes);
app.use('/api/buildings', buildingRoutes);
app.use('/api/rooms', roomRoutes);
app.use('/api/iot-devices', iotDeviceRoutes);
app.use('/api/sensor-data', sensorDataRoutes);

// Basic route for testing
app.get('/', (req, res) => {
  res.json({ 
    message: 'UNILA AQI Backend API is running',
    database: process.env.MONGODB_URI ? 'Connected' : 'Not configured',
    timestamp: new Date(),
    socketIO: 'Active'
  });
});

// Socket.io Connection Handler
io.on('connection', (socket) => {
  console.log(`ðŸ”Œ New client connected: ${socket.id}`);
  
  // Join specific room
  socket.on('join-room', (roomId) => {
    socket.join(roomId);
    console.log(`ðŸ“¡ Socket ${socket.id} joined room: ${roomId}`);
    
    // Send welcome message to this room
    socket.emit('room-joined', {
      roomId: roomId,
      message: `Connected to room ${roomId}`,
      timestamp: new Date()
    });
  });
  
    // Leave room
  socket.on('leave-room', (roomId) => {
    socket.leave(roomId);
    console.log(`ðŸ“¡ Socket ${socket.id} left room: ${roomId}`);
  });

  // Subscribe to dashboard updates
  socket.on('subscribe-dashboard', () => {
    socket.join('dashboard');
    console.log(`ðŸ“Š Socket ${socket.id} subscribed to dashboard updates`);
    
    socket.emit('dashboard-subscribed', {
      message: 'Subscribed to dashboard updates',
      timestamp: new Date()
    });
  });
  
  // Unsubscribe from dashboard
  socket.on('unsubscribe-dashboard', () => {
    socket.leave('dashboard');
    console.log(`ðŸ“Š Socket ${socket.id} unsubscribed from dashboard`);
  });

    // Subscribe to room updates
   socket.on('subscribe-room-updates', (roomId) => {
    socket.join(`room-updates-${roomId}`);
    console.log(`ðŸ“¡ Socket ${socket.id} subscribed to room ${roomId} updates`);
  });

    // Request manual refre
    socket.on('request-refresh', (data) => {
    const roomId = data?.roomId;
    console.log(`ðŸ”„ Socket ${socket.id} requested refresh${roomId ? ` for room ${roomId}` : ''}`);
    
    if (roomId) {
      // Trigger refresh for specific room
      socket.to(roomId).emit('room-refresh-requested', {
        requestedBy: socket.id,
        timestamp: new Date()
      });
    } else {
      // Trigger general refresh
      simulationService.updateAllRooms();
      iotService.pollAllIoTDevices();
      
      // Broadcast refresh started
      io.emit('refresh-started', {
        requestedBy: socket.id,
        timestamp: new Date()
      });
    }
    
    socket.emit('refresh-acknowledged', {
      message: 'Refresh request received',
      timestamp: new Date()
    });
  });

  // Handle disconnection
  socket.on('disconnect', (reason) => {
    console.log(`ðŸ”Œ Client disconnected: ${socket.id} (reason: ${reason})`);
    
    // Notify dashboard about disconnection
    socket.to('dashboard').emit('client-disconnected', {
      socketId: socket.id,
      timestamp: new Date(),
      reason: reason
    });
  });
  
  // Ping for connection testing
    socket.on('ping', (data) => {
    const clientTime = data?.timestamp;
    socket.emit('pong', {
      serverTime: new Date(),
      clientTime: clientTime,
      latency: clientTime ? Date.now() - new Date(clientTime).getTime() : null
    });
  });

     // Send connection confirmation
  socket.emit('connected', {
    socketId: socket.id,
    message: 'Connected to UNILA AQI WebSocket server',
    timestamp: new Date(),
    serverInfo: {
      name: 'UNILA AQI Backend',
      version: '1.0.0',
      features: ['real-time-updates', 'room-monitoring', 'dashboard-updates']
    }
  });

});

// Make io accessible to other modules
app.set('socketio', io);

// Function to broadcast room updates
const broadcastRoomUpdate = (roomId, data) => {
  if (io) {
    io.to(roomId).emit('room-update', {
      roomId,
      data,
      timestamp: new Date()
    });
    console.log(`ðŸ“¢ Broadcast update to room ${roomId}: AQI ${data.aqi}`);
  }
};

// Function to broadcast to all connected clients
const broadcastToAll = (event, data) => {
  if (io) {
    io.emit(event, data);
  }
};

// Export for use in other modules
module.exports = {
  broadcastRoomUpdate,
  broadcastToAll
};

// MongoDB connection
mongoose.connect(process.env.MONGODB_URI)
  .then(async () => {
    console.log('âœ… Connected to MongoDB Atlas');
    console.log(`ðŸ“Š Database: ${mongoose.connection.db.databaseName}`);
    console.log(`ðŸ“ Host: ${mongoose.connection.host}`);
    
    // Seed admin user
    await seedInitialAdmin();
    
    // Sync building names in rooms
    await syncBuildingNames();
    
    // Seed sample buildings and rooms
    const buildingCount = await Building.countDocuments();
    if (buildingCount === 0) {
      console.log('ðŸŒ± Seeding sample data...');
      await seedSampleData();
    } else {
      console.log(`ðŸ“Š Database already has ${buildingCount} buildings, skipping sample seeding`);
    }
    
    // Start services with socket.io instance
    simulationService.start(io);  // GANTI: gunakan simulationService
    iotService.start(io);        // GANTI: gunakan iotService yang sudah diperbaiki

    console.log('âœ… All services started');
    console.log('   - Simulation Service: ACTIVE (1 minute intervals)');
    console.log('   - IoT Service: ACTIVE (30 second intervals)');
  })
  .catch((err) => {
    console.error('âŒ MongoDB connection error:', err.message);
    const uri = process.env.MONGODB_URI || '';
    const maskedUri = uri.replace(/:[^:@]*@/, ':****@');
    console.error('Connection string:', maskedUri);
  });

// Function to sync building names
async function syncBuildingNames() {
  try {
    console.log('ðŸ”„ Syncing building names in rooms...');
    
    const rooms = await Room.find().populate('building', 'name');
    let updatedCount = 0;
    
    for (const room of rooms) {
      if (room.building && room.buildingName !== room.building.name) {
        room.buildingName = room.building.name;
        await room.save();
        updatedCount++;
      }
    }
    
    if (updatedCount > 0) {
      console.log(`âœ… Synced building names for ${updatedCount} rooms`);
    } else {
      console.log('âœ… All room building names are already synced');
    }
  } catch (error) {
    console.error('âŒ Error syncing building names:', error.message);
  }
}

// Start server
const PORT = process.env.PORT || 5000;

const seedInitialAdmin = async () => {
  try {
    const User = require('./models/User');
    const { hashPassword } = require('./utils/auth');
    
    // Cek apakah sudah ada admin
    const adminExists = await User.findOne({ role: 'admin' });
    
    if (!adminExists) {
      const hashedPassword = await hashPassword('admin123');
      const admin = new User({
        username: 'admin',
        password: hashedPassword,
        email: 'admin@unila-aqi.ac.id',
        role: 'admin'
      });
      
      await admin.save();
      console.log('âœ… Initial admin user created');
      console.log('ðŸ‘¤ Username: admin');
      console.log('ðŸ”‘ Password: admin123');
    } else {
      console.log('âœ… Admin user already exists');
    }
  } catch (error) {
    console.error('âŒ Error seeding admin:', error);
  }
};

app.get('/api/simple-test', (req, res) => {
  res.json({
    message: 'Simple test endpoint working',
    timestamp: new Date(),
    status: 'OK',
    dbConnected: mongoose.connection.readyState === 1,
    socketConnected: io !== undefined
  });
});


app.post('/api/force-refresh', async (req, res) => {
  try {
    // Force simulation service to update
    simulationService.forceUpdate();  // GANTI
    
    // Force IoT service to poll
    iotService.forcePollAll();
    
    res.json({
      success: true,
      message: 'Force refresh initiated for both services',
      timestamp: new Date(),
      services: {
        simulation: 'Forced update started',
        iot: 'Forced polling started'
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error forcing refresh',
      error: error.message
    });
  }
});

server.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
  console.log(`ðŸŒ API Base URL: http://localhost:${PORT}/api`);
  console.log(`ðŸ“¡ WebSocket URL: ws://localhost:${PORT}`);
  console.log(`ðŸ”Œ Socket.IO ready for real-time updates`);
});

app.use((req, res, next) => {
  req.io = io;
  next();
});

// Export io for use in other modules
app.set('socketio', io);

---------------------------------------------------------------------------------------------------------------------------------------
src/checkDatabase.js

const mongoose = require('mongoose');
require('dotenv').config();

async function checkDatabase() {
  try {
    console.log('ðŸ” Checking MongoDB Atlas Connection...');
    
    // Check if MONGODB_URI is set
    if (!process.env.MONGODB_URI) {
      throw new Error('MONGODB_URI is not set in environment variables');
    }
    
    // Mask password for logging (before connection attempt)
    const uri = process.env.MONGODB_URI;
    const maskedUri = uri.replace(/:[^:@]*@/, ':****@');
    console.log(`Using connection string: ${maskedUri}`);
    
    // Connect with timeout
    await mongoose.connect(process.env.MONGODB_URI, {
      serverSelectionTimeoutMS: 10000, // 10 seconds timeout
      socketTimeoutMS: 45000, // 45 seconds socket timeout
    });
    
    console.log('âœ… Connected to MongoDB Atlas');
    console.log(`ðŸ“ Host: ${mongoose.connection.host}`);
    console.log(`ðŸ“Š Database: ${mongoose.connection.db.databaseName}`);
    console.log(`ðŸ“¡ State: ${mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected'}`);
    
    // List all collections
    console.log('\nðŸ“š Collections:');
    const collections = await mongoose.connection.db.listCollections().toArray();
    
    if (collections.length === 0) {
      console.log('   No collections found in database');
    } else {
      collections.forEach(col => {
        console.log(`   - ${col.name}`);
      });
    }
    
    // Count documents in each collection (including dynamically found ones)
    console.log('\nðŸ“Š Document Counts:');
    
    // Use the actual collection names we found, or fall back to expected ones
    const collectionNames = collections.length > 0 
      ? collections.map(col => col.name)
      : ['buildings', 'rooms', 'users', 'iotdevices', 'sensordatas'];
    
    for (const colName of collectionNames) {
      try {
        const count = await mongoose.connection.db.collection(colName).countDocuments();
        console.log(`   ${colName}: ${count} documents`);
      } catch (err) {
        if (err.codeName === 'NamespaceNotFound') {
          console.log(`   ${colName}: Collection doesn't exist`);
        } else {
          console.log(`   ${colName}: Error - ${err.message}`);
        }
      }
    }
    
    // Additional info with safer version checking
    console.log('\nðŸ”§ Additional Info:');
    console.log(`   Mongoose version: ${mongoose.version}`);
    
    // Safer way to get MongoDB driver version
    try {
      const client = mongoose.connection.getClient();
      let driverVersion = 'Unknown';
      
      // Try different ways to get driver version
      if (client && client.options && client.options.metadata && client.options.metadata.driver) {
        driverVersion = client.options.metadata.driver.version;
      } else if (client && client.options && client.options.driverInfo) {
        driverVersion = client.options.driverInfo.version || 'Available in driverInfo';
      } else if (client && client.topology && client.topology.s && client.topology.s.options) {
        driverVersion = client.topology.s.options.metadata?.driver?.version || 'Available in topology';
      }
      
      console.log(`   MongoDB driver version: ${driverVersion}`);
    } catch (driverErr) {
      console.log(`   MongoDB driver version: Could not retrieve (${driverErr.message})`);
    }
    
    // Get server info
    try {
      const serverStatus = await mongoose.connection.db.admin().serverStatus();
      console.log(`   MongoDB server version: ${serverStatus.version}`);
      console.log(`   MongoDB storage engine: ${serverStatus.storageEngine?.name || 'Unknown'}`);
    } catch (statusErr) {
      console.log(`   MongoDB server info: Could not retrieve (${statusErr.message})`);
    }
    
    // Close connection gracefully
    await mongoose.disconnect();
    console.log('\nðŸ”Œ Disconnected from MongoDB');
    
    process.exit(0);
  } catch (error) {
    console.error('\nâŒ Connection Error:', error.message);
    
    // More detailed error analysis
    if (error.name === 'MongooseServerSelectionError') {
      console.error('   This is a connection error. Possible causes:');
      console.error('   - Network connectivity issues');
      console.error('   - Incorrect connection string');
      console.error('   - IP not whitelisted in Atlas');
      console.error('   - Database cluster is paused or down');
    } else if (error.name === 'MongooseError') {
      console.error('   Mongoose-specific error occurred');
    }
    
    console.error('\nðŸ”§ Debug Information:');
    console.error(`   Error name: ${error.name}`);
    console.error(`   Error code: ${error.code || 'N/A'}`);
    
    // Check if it's an authentication error
    if (error.message.includes('authentication')) {
      console.error('   Authentication failed. Check username/password in connection string.');
    }
    
    // Check if it's a DNS error
    if (error.message.includes('getaddrinfo') || error.message.includes('ENOTFOUND')) {
      console.error('   DNS resolution failed. Check the hostname in your connection string.');
    }
    
    // Try to parse the connection string for debugging
    try {
      const uri = process.env.MONGODB_URI || '';
      const match = uri.match(/mongodb\+srv:\/\/([^:]+):[^@]+@([^/]+)\/([^?]+)/);
      if (match) {
        console.error('\nðŸ“‹ Connection String Analysis:');
        console.error(`   Username: ${match[1]}`);
        console.error(`   Cluster: ${match[2]}`);
        console.error(`   Database: ${match[3]}`);
      }
    } catch (parseErr) {
      // Ignore parse errors
    }
    
    process.exit(1);
  }
}

// Handle script termination
process.on('SIGINT', async () => {
  console.log('\n\nâš ï¸  Script interrupted by user');
  try {
    if (mongoose.connection.readyState === 1) {
      await mongoose.disconnect();
      console.log('ðŸ”Œ Disconnected from MongoDB');
    }
  } catch (err) {
    console.error('Error during disconnect:', err.message);
  }
  process.exit(0);
});

checkDatabase();

---------------------------------------------------------------------------------------------------------------------------------------
src/resetDatabase.js

const mongoose = require('mongoose');
const { seedSampleData, clearSampleData } = require('./utils/seedData');
const User = require('./models/User');
const { hashPassword } = require('./utils/auth');
require('dotenv').config();

async function resetDatabase() {
  try {
    console.log('ðŸ”„ Resetting database...');
    
    // Connect to MongoDB Atlas - SIMPLIFIED
    await mongoose.connect(process.env.MONGODB_URI);
    
    console.log('âœ… Connected to MongoDB Atlas');
    console.log(`ðŸ“Š Database: ${mongoose.connection.db.databaseName}`);
    
    // Clear all existing data
    console.log('ðŸ—‘ï¸  Clearing existing data...');
    await clearSampleData();
    
    // Seed admin user
    console.log('ðŸ‘¤ Creating admin user...');
    const adminExists = await User.findOne({ role: 'admin' });
    
    if (!adminExists) {
      const hashedPassword = await hashPassword('admin123');
      const admin = new User({
        username: 'admin',
        password: hashedPassword,
        email: 'admin@unila-aqi.ac.id',
        role: 'admin'
      });
      
      await admin.save();
      console.log('âœ… Admin user created');
      console.log('ðŸ‘¤ Username: admin');
      console.log('ðŸ”‘ Password: admin123');
    } else {
      console.log('âœ… Admin user already exists');
    }
    
    // Seed sample data
    console.log('ðŸŒ± Seeding sample data...');
    const result = await seedSampleData();
    
    console.log('ðŸŽ‰ Database reset completed!');
    console.log(result.message || '');
    
    // Count documents
    const Building = require('./models/Building');
    const Room = require('./models/Room');
    const IoTDevice = require('./models/IoTDevice');
    
    const buildingCount = await Building.countDocuments();
    const roomCount = await Room.countDocuments();
    const deviceCount = await IoTDevice.countDocuments();
    
    console.log('\nðŸ“Š Database Statistics:');
    console.log(`ðŸ¢ Buildings: ${buildingCount}`);
    console.log(`ðŸšª Rooms: ${roomCount}`);
    console.log(`ðŸ“¡ IoT Devices: ${deviceCount}`);
    
    // Show sample data
    console.log('\nðŸ¢ Sample Buildings:');
    const buildings = await Building.find().limit(3);
    buildings.forEach(b => {
      console.log(`   - ${b.name} (${b.code || 'No code'})`);
    });
    
    console.log('\nðŸšª Sample Rooms:');
    const rooms = await Room.find().populate('building', 'name').limit(3);
    rooms.forEach(r => {
      console.log(`   - ${r.name} in ${r.building?.name || r.buildingName}`);
    });
    
    process.exit(0);
  } catch (error) {
    console.error('âŒ Error resetting database:', error.message);
    console.error('Stack:', error.stack);
    
    // Show connection string for debugging
    const uri = process.env.MONGODB_URI || '';
    const maskedUri = uri.replace(/:[^:@]*@/, ':****@');
    console.error('Connection string:', maskedUri);
    
    process.exit(1);
  }
}

resetDatabase();

---------------------------------------------------------------------------------------------------------------------------------------
syncBuildingNames.js

const mongoose = require('mongoose');
require('dotenv').config();

async function syncBuildingNames() {
  try {
    console.log('ðŸ”„ Starting building name sync...');
    
    // Connect to MongoDB
    console.log('ðŸ”— Connecting to MongoDB...');
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('âœ… Connected to MongoDB');
    
    // Import models after connection
    const Building = require('./models/Building');
    const Room = require('./models/Room');
    
    // Get all buildings
    const buildings = await Building.find();
    console.log(`ðŸ“Š Found ${buildings.length} buildings`);
    
    let totalUpdated = 0;
    
    // For each building, update all related rooms
    for (const building of buildings) {
      try {
        const result = await Room.updateMany(
          { building: building._id },
          { $set: { buildingName: building.name } }
        );
        
        if (result.modifiedCount > 0) {
          console.log(`âœ… Updated ${result.modifiedCount} rooms in ${building.name}`);
          totalUpdated += result.modifiedCount;
        }
      } catch (buildingError) {
        console.error(`âŒ Error updating rooms in ${building.name}:`, buildingError.message);
      }
    }
    
    console.log(`ðŸŽ‰ Sync completed! Total ${totalUpdated} rooms updated.`);
    
    // Verify sync
    console.log('ðŸ” Verifying sync...');
    const rooms = await Room.find();
    let mismatched = 0;
    
    for (const room of rooms) {
      try {
        if (room.building) {
          const building = await Building.findById(room.building);
          if (building && room.buildingName !== building.name) {
            mismatched++;
            console.log(`âŒ Mismatch: Room "${room.name}" has "${room.buildingName}" but building is "${building.name}"`);
            
            // Auto-fix mismatch
            room.buildingName = building.name;
            await room.save();
            console.log(`   â†³ Fixed: Updated to "${building.name}"`);
          }
        }
      } catch (roomError) {
        console.error(`âŒ Error checking room ${room.name}:`, roomError.message);
      }
    }
    
    if (mismatched > 0) {
      console.log(`âš ï¸  Found and fixed ${mismatched} mismatches`);
    } else {
      console.log('âœ… All room building names are correctly synced!');
    }
    
    // Show summary
    console.log('\nðŸ“Š SYNC SUMMARY:');
    console.log('----------------');
    console.log(`Total buildings: ${buildings.length}`);
    console.log(`Total rooms: ${rooms.length}`);
    console.log(`Rooms updated: ${totalUpdated}`);
    console.log(`Mismatches fixed: ${mismatched}`);
    
    await mongoose.disconnect();
    console.log('ðŸ”Œ Disconnected from MongoDB');
    process.exit(0);
  } catch (error) {
    console.error('âŒ Error:', error.message);
    console.error('Stack:', error.stack);
    
    // Show connection string for debugging
    const uri = process.env.MONGODB_URI || '';
    const maskedUri = uri.replace(/:[^:@]*@/, ':****@');
    console.error('Connection string:', maskedUri);
    
    process.exit(1);
  }
}

// Run the sync
syncBuildingNames();

---------------------------------------------------------------------------------------------------------------------------------------
src/testApi.js

const axios = require('axios');

async function testApi() {
  const baseUrl = 'http://localhost:5000/api';
  
  console.log('ðŸ§ª Testing API Endpoints...\n');
  
  try {
    // Test 1: Public endpoints
    console.log('1. Testing public endpoints...');
    const statusRes = await axios.get(`${baseUrl}/test/status`);
    console.log(`   Status: ${JSON.stringify(statusRes.data.data)}`);
    
    // Test 2: Get buildings
    console.log('\n2. Testing buildings endpoint...');
    const buildingsRes = await axios.get(`${baseUrl}/test/buildings`);
    console.log(`   Buildings count: ${buildingsRes.data.count}`);
    
    // Test 3: Get rooms
    console.log('\n3. Testing rooms endpoint...');
    const roomsRes = await axios.get(`${baseUrl}/test/rooms`);
    console.log(`   Rooms count: ${roomsRes.data.count}`);
    
    // Test 4: Auth check
    console.log('\n4. Testing auth endpoint...');
    const authRes = await axios.get(`${baseUrl}/auth/check-admin`);
    console.log(`   Admin registered: ${authRes.data.isRegistered}`);
    
    console.log('\nâœ… All API tests passed!');
  } catch (error) {
    console.error('âŒ API Test failed:', error.message);
  }
}

testApi();

---------------------------------------------------------------------------------------------------------------------------------------
.env:

PORT=5000
MONGODB_URI=mongodb+srv://fathannursidiq:9KqOgqTElMa6XyzA@unila-aqi-cluster.b4zcdqm.mongodb.net/?appName=unila-aqi-cluster
JWT_SECRET=unila_aqi_secret_key_2025_vvyynnssxx141
NODE_ENV=development


---------------------------------------------------------------------------------------------------------------------------------------

package-lock.json:

{
  "name": "unila-aqi-backend",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "unila-aqi-backend",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "axios": "^1.13.2",
        "bcryptjs": "^3.0.3",
        "cors": "^2.8.5",
        "dotenv": "^17.2.3",
        "express": "^5.2.1",
        "jsonwebtoken": "^9.0.3",
        "mongodb": "^7.0.0",
        "mongoose": "^9.0.2",
        "node-cron": "^4.2.1",
        "socket.io": "^4.8.1"
      },
      "devDependencies": {
        "nodemon": "^3.1.11"
      }
    },
    "node_modules/@mongodb-js/saslprep": {
      "version": "1.4.4",
      "resolved": "https://registry.npmjs.org/@mongodb-js/saslprep/-/saslprep-1.4.4.tgz",
      "integrity": "sha512-p7X/ytJDIdwUfFL/CLOhKgdfJe1Fa8uw9seJYvdOmnP9JBWGWHW69HkOixXS6Wy9yvGf1MbhcS6lVmrhy4jm2g==",
      "license": "MIT",
      "dependencies": {
        "sparse-bitfield": "^3.0.3"
      }
    },
    "node_modules/@socket.io/component-emitter": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@socket.io/component-emitter/-/component-emitter-3.1.2.tgz",
      "integrity": "sha512-9BCxFwvbGg/RsZK9tjXd8s4UcwR0MWeFQ1XEKIQVVvAGJyINdrqKMcTRyLoK8Rse1GjzLV9cwjWV1olXRWEXVA==",
      "license": "MIT"
    },
    "node_modules/@types/cors": {
      "version": "2.8.19",
      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.19.tgz",
      "integrity": "sha512-mFNylyeyqN93lfe/9CSxOGREz8cpzAhH+E93xJ4xWQf62V8sQ/24reV2nyzUWM6H6Xji+GGHpkbLe7pVoUEskg==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/node": {
      "version": "25.0.3",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-25.0.3.tgz",
      "integrity": "sha512-W609buLVRVmeW693xKfzHeIV6nJGGz98uCPfeXI1ELMLXVeKYZ9m15fAMSaUPBHYLGFsVRcMmSCksQOrZV9BYA==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.16.0"
      }
    },
    "node_modules/@types/webidl-conversions": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/@types/webidl-conversions/-/webidl-conversions-7.0.3.tgz",
      "integrity": "sha512-CiJJvcRtIgzadHCYXw7dqEnMNRjhGZlYK05Mj9OyktqV8uVT8fD2BFOB7S1uwBE3Kj2Z+4UyPmFw/Ixgw/LAlA==",
      "license": "MIT"
    },
    "node_modules/@types/whatwg-url": {
      "version": "13.0.0",
      "resolved": "https://registry.npmjs.org/@types/whatwg-url/-/whatwg-url-13.0.0.tgz",
      "integrity": "sha512-N8WXpbE6Wgri7KUSvrmQcqrMllKZ9uxkYWMt+mCSGwNc0Hsw9VQTW7ApqI4XNrx6/SaM2QQJCzMPDEXE058s+Q==",
      "license": "MIT",
      "dependencies": {
        "@types/webidl-conversions": "*"
      }
    },
    "node_modules/accepts": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz",
      "integrity": "sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "^3.0.0",
        "negotiator": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/axios": {
      "version": "1.13.5",
      "resolved": "https://registry.npmjs.org/axios/-/axios-1.13.5.tgz",
      "integrity": "sha512-cz4ur7Vb0xS4/KUN0tPWe44eqxrIu31me+fbang3ijiNscE129POzipJJA6zniq2C/Z6sJCjMimjS8Lc/GAs8Q==",
      "license": "MIT",
      "dependencies": {
        "follow-redirects": "^1.15.11",
        "form-data": "^4.0.5",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/base64id": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/base64id/-/base64id-2.0.0.tgz",
      "integrity": "sha512-lGe34o6EHj9y3Kts9R4ZYs/Gr+6N7MCaMlIFA3F1R2O5/m7K06AxfSeO5530PEERE6/WyEg3lsuyw4GHlPZHog==",
      "license": "MIT",
      "engines": {
        "node": "^4.5.0 || >= 5.9"
      }
    },
    "node_modules/bcryptjs": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/bcryptjs/-/bcryptjs-3.0.3.tgz",
      "integrity": "sha512-GlF5wPWnSa/X5LKM1o0wz0suXIINz1iHRLvTS+sLyi7XPbe5ycmYI3DlZqVGZZtDgl4DmasFg7gOB3JYbphV5g==",
      "license": "BSD-3-Clause",
      "bin": {
        "bcrypt": "bin/bcrypt"
      }
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/body-parser": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-2.2.1.tgz",
      "integrity": "sha512-nfDwkulwiZYQIGwxdy0RUmowMhKcFVcYXUU7m4QlKYim1rUtg83xm2yjZ40QjDuc291AJjjeSc9b++AWHSgSHw==",
      "license": "MIT",
      "dependencies": {
        "bytes": "^3.1.2",
        "content-type": "^1.0.5",
        "debug": "^4.4.3",
        "http-errors": "^2.0.0",
        "iconv-lite": "^0.7.0",
        "on-finished": "^2.4.1",
        "qs": "^6.14.0",
        "raw-body": "^3.0.1",
        "type-is": "^2.0.1"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/bson": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/bson/-/bson-7.0.0.tgz",
      "integrity": "sha512-Kwc6Wh4lQ5OmkqqKhYGKIuELXl+EPYSCObVE6bWsp1T/cGkOCBN0I8wF/T44BiuhHyNi1mmKVPXk60d41xZ7kw==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=20.19.0"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/content-disposition": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.1.tgz",
      "integrity": "sha512-oIXISMynqSqm241k6kcQ5UwttDILMK4BiurCfGEREw6+X9jkkpEe5T9FZaApyLGGOnFuyMWZpdolTXMtvEJ08Q==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz",
      "integrity": "sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==",
      "license": "MIT",
      "engines": {
        "node": ">=6.6.0"
      }
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/dotenv": {
      "version": "17.2.3",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-17.2.3.tgz",
      "integrity": "sha512-JVUnt+DUIzu87TABbhPmNfVdBDt18BLOWjMUFJMSi/Qqg7NTYtabbvSNJGOJ7afbRuv9D/lngizHtP7QyLQ+9w==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "license": "MIT"
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/engine.io": {
      "version": "6.6.4",
      "resolved": "https://registry.npmjs.org/engine.io/-/engine.io-6.6.4.tgz",
      "integrity": "sha512-ZCkIjSYNDyGn0R6ewHDtXgns/Zre/NT6Agvq1/WobF7JXgFff4SeDroKiCO3fNJreU9YG429Sc81o4w5ok/W5g==",
      "license": "MIT",
      "dependencies": {
        "@types/cors": "^2.8.12",
        "@types/node": ">=10.0.0",
        "accepts": "~1.3.4",
        "base64id": "2.0.0",
        "cookie": "~0.7.2",
        "cors": "~2.8.5",
        "debug": "~4.3.1",
        "engine.io-parser": "~5.2.1",
        "ws": "~8.17.1"
      },
      "engines": {
        "node": ">=10.2.0"
      }
    },
    "node_modules/engine.io-parser": {
      "version": "5.2.3",
      "resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-5.2.3.tgz",
      "integrity": "sha512-HqD3yTBfnBxIrbnM1DoD6Pcq8NECnh8d4As1Qgh0z5Gg3jRRIqijury0CL3ghu/edArpUYiYqQiDUQBIs4np3Q==",
      "license": "MIT",
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/engine.io/node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/engine.io/node_modules/debug": {
      "version": "4.3.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.7.tgz",
      "integrity": "sha512-Er2nc/H7RrMXZBFCEim6TCmMk02Z8vLC2Rbi1KEBggpo0fS6l0S1nnapwmIi3yW/+GOJap1Krg4w0Hg80oCqgQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/engine.io/node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/engine.io/node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/engine.io/node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "license": "MIT"
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/express/-/express-5.2.1.tgz",
      "integrity": "sha512-hIS4idWWai69NezIdRt2xFVofaF4j+6INOpJlVOLDO8zXGpUVEVzIYk12UUi2JzjEzWL3IOAxcTubgz9Po0yXw==",
      "license": "MIT",
      "dependencies": {
        "accepts": "^2.0.0",
        "body-parser": "^2.2.1",
        "content-disposition": "^1.0.0",
        "content-type": "^1.0.5",
        "cookie": "^0.7.1",
        "cookie-signature": "^1.2.1",
        "debug": "^4.4.0",
        "depd": "^2.0.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "finalhandler": "^2.1.0",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.0",
        "merge-descriptors": "^2.0.0",
        "mime-types": "^3.0.0",
        "on-finished": "^2.4.1",
        "once": "^1.4.0",
        "parseurl": "^1.3.3",
        "proxy-addr": "^2.0.7",
        "qs": "^6.14.0",
        "range-parser": "^1.2.1",
        "router": "^2.2.0",
        "send": "^1.1.0",
        "serve-static": "^2.2.0",
        "statuses": "^2.0.1",
        "type-is": "^2.0.1",
        "vary": "^1.1.2"
      },
      "engines": {
        "node": ">= 18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/finalhandler": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-2.1.1.tgz",
      "integrity": "sha512-S8KoZgRZN+a5rNwqTxlZZePjT/4cnm0ROV70LedRHZ0p8u9fRID0hJUZQpkKLzro8LfmC8sx23bY6tVNxv8pQA==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "on-finished": "^2.4.1",
        "parseurl": "^1.3.3",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/follow-redirects": {
      "version": "1.15.11",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.11.tgz",
      "integrity": "sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.5",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
      "integrity": "sha512-8RipRLol37bNs2bhoV67fiTEvdTrbMUYcFTiy3+wuuOnUog2QBHCZWXDRijWQfAkhBj2Uf5UnVaiWwA5vdd82w==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/form-data/node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/form-data/node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz",
      "integrity": "sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
      "integrity": "sha512-4FbRdAX+bSdmo4AUFuS0WNiPz8NgFt+r8ThgNWmlrjQjt1Q7ZR9+zTlce2859x4KSXrwIsaeTqDoKQmtP8pLmQ==",
      "license": "MIT",
      "dependencies": {
        "depd": "~2.0.0",
        "inherits": "~2.0.4",
        "setprototypeof": "~1.2.0",
        "statuses": "~2.0.2",
        "toidentifier": "~1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.7.1.tgz",
      "integrity": "sha512-2Tth85cXwGFHfvRgZWszZSvdo+0Xsqmw8k8ZwxScfcBneNUraK+dxRxRm24nszx80Y0TVio8kKLt5sLE7ZCLlw==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/ignore-by-default": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/ignore-by-default/-/ignore-by-default-1.0.1.tgz",
      "integrity": "sha512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-promise": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz",
      "integrity": "sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==",
      "license": "MIT"
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.3",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.3.tgz",
      "integrity": "sha512-MT/xP0CrubFRNLNKvxJ2BYfy53Zkm++5bX9dtuPbqAeQpTVe0MQTFhao8+Cp//EmJp244xt6Drw/GVEGCUj40g==",
      "license": "MIT",
      "dependencies": {
        "jws": "^4.0.1",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jwa": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-2.0.1.tgz",
      "integrity": "sha512-hRF04fqJIP8Abbkq5NKGN0Bbr3JxlQ+qhZufXVr0DvujKy93ZCbXZMHDL4EOtodSbCWxOqR8MS1tXA5hwqCXDg==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "^1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/jws/-/jws-4.0.1.tgz",
      "integrity": "sha512-EKI/M/yqPncGUUh44xz0PxSidXFr/+r0pA70+gIYhjv+et7yxM+s29Y+VGDkovRofQem0fs7Uvf4+YmAdyRduA==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^2.0.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/kareem": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/kareem/-/kareem-3.0.0.tgz",
      "integrity": "sha512-RKhaOBSPN8L7y4yAgNhDT2602G5FD6QbOIISbjN9D6mjHPeqeg7K+EB5IGSU5o81/X2Gzm3ICnAvQW3x3OP8HA==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==",
      "license": "MIT"
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "license": "MIT"
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==",
      "license": "MIT"
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==",
      "license": "MIT"
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==",
      "license": "MIT"
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz",
      "integrity": "sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/memory-pager": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/memory-pager/-/memory-pager-1.5.0.tgz",
      "integrity": "sha512-ZS4Bp4r/Zoeq6+NLJpP+0Zzm0pR8whtGPf1XExKLJBAczGMnSi3It14OiNCStjQjM6NU1okjQGSxgEZN8eBYKg==",
      "license": "MIT"
    },
    "node_modules/merge-descriptors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz",
      "integrity": "sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/mime-db": {
      "version": "1.54.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.54.0.tgz",
      "integrity": "sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-3.0.2.tgz",
      "integrity": "sha512-Lbgzdk0h4juoQ9fCKXW4by0UJqj+nOOrI9MJ1sSj4nI8aI2eo1qmvQEie4VD1glsS250n15LsWsYtCugiStS5A==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "^1.54.0"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/mongodb": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/mongodb/-/mongodb-7.0.0.tgz",
      "integrity": "sha512-vG/A5cQrvGGvZm2mTnCSz1LUcbOPl83hfB6bxULKQ8oFZauyox/2xbZOoGNl+64m8VBrETkdGCDBdOsCr3F3jg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@mongodb-js/saslprep": "^1.3.0",
        "bson": "^7.0.0",
        "mongodb-connection-string-url": "^7.0.0"
      },
      "engines": {
        "node": ">=20.19.0"
      },
      "peerDependencies": {
        "@aws-sdk/credential-providers": "^3.806.0",
        "@mongodb-js/zstd": "^7.0.0",
        "gcp-metadata": "^7.0.1",
        "kerberos": "^7.0.0",
        "mongodb-client-encryption": ">=7.0.0 <7.1.0",
        "snappy": "^7.3.2",
        "socks": "^2.8.6"
      },
      "peerDependenciesMeta": {
        "@aws-sdk/credential-providers": {
          "optional": true
        },
        "@mongodb-js/zstd": {
          "optional": true
        },
        "gcp-metadata": {
          "optional": true
        },
        "kerberos": {
          "optional": true
        },
        "mongodb-client-encryption": {
          "optional": true
        },
        "snappy": {
          "optional": true
        },
        "socks": {
          "optional": true
        }
      }
    },
    "node_modules/mongodb-connection-string-url": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/mongodb-connection-string-url/-/mongodb-connection-string-url-7.0.0.tgz",
      "integrity": "sha512-irhhjRVLE20hbkRl4zpAYLnDMM+zIZnp0IDB9akAFFUZp/3XdOfwwddc7y6cNvF2WCEtfTYRwYbIfYa2kVY0og==",
      "license": "Apache-2.0",
      "dependencies": {
        "@types/whatwg-url": "^13.0.0",
        "whatwg-url": "^14.1.0"
      },
      "engines": {
        "node": ">=20.19.0"
      }
    },
    "node_modules/mongoose": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/mongoose/-/mongoose-9.0.2.tgz",
      "integrity": "sha512-+GCaqwE+X//yN9eo2M2L/n+mVti9J6vH5iQKbhD+2AArZd5iaZqK/DkmkE4S6/iYYMyVQPTXsRk7jyVOYEtJzA==",
      "license": "MIT",
      "dependencies": {
        "kareem": "3.0.0",
        "mongodb": "~7.0",
        "mpath": "0.9.0",
        "mquery": "6.0.0",
        "ms": "2.1.3",
        "sift": "17.1.3"
      },
      "engines": {
        "node": ">=20.19.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mongoose"
      }
    },
    "node_modules/mpath": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/mpath/-/mpath-0.9.0.tgz",
      "integrity": "sha512-ikJRQTk8hw5DEoFVxHG1Gn9T/xcjtdnOKIU1JTmGjZZlg9LST2mBLmcX3/ICIbgJydT2GOc15RnNy5mHmzfSew==",
      "license": "MIT",
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/mquery": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/mquery/-/mquery-6.0.0.tgz",
      "integrity": "sha512-b2KQNsmgtkscfeDgkYMcWGn9vZI9YoXh802VDEwE6qc50zxBFQ0Oo8ROkawbPAsXCY1/Z1yp0MagqsZStPWJjw==",
      "license": "MIT",
      "engines": {
        "node": ">=20.19.0"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/negotiator": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz",
      "integrity": "sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/node-cron": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/node-cron/-/node-cron-4.2.1.tgz",
      "integrity": "sha512-lgimEHPE/QDgFlywTd8yTR61ptugX3Qer29efeyWw2rv259HtGBNn1vZVmp8lB9uo9wC0t/AT4iGqXxia+CJFg==",
      "license": "ISC",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/nodemon": {
      "version": "3.1.11",
      "resolved": "https://registry.npmjs.org/nodemon/-/nodemon-3.1.11.tgz",
      "integrity": "sha512-is96t8F/1//UHAjNPHpbsNY46ELPpftGUoSVNXwUfMk/qdjSylYrWSu1XavVTBOn526kFiOR733ATgNBCQyH0g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chokidar": "^3.5.2",
        "debug": "^4",
        "ignore-by-default": "^1.0.1",
        "minimatch": "^3.1.2",
        "pstree.remy": "^1.1.8",
        "semver": "^7.5.3",
        "simple-update-notifier": "^2.0.0",
        "supports-color": "^5.5.0",
        "touch": "^3.1.0",
        "undefsafe": "^2.0.5"
      },
      "bin": {
        "nodemon": "bin/nodemon.js"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nodemon"
      }
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "8.3.0",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.3.0.tgz",
      "integrity": "sha512-7jdwVIRtsP8MYpdXSwOS0YdD0Du+qOoF/AEPIt88PcCFrZCzx41oxku1jD88hZBwbNUIEfpqvuhjFaMAqMTWnA==",
      "license": "MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "license": "MIT"
    },
    "node_modules/pstree.remy": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/pstree.remy/-/pstree.remy-1.1.8.tgz",
      "integrity": "sha512-77DZwxQmxKnu3aR542U+X8FypNzbfJ+C5XQDk3uWjWxn6151aIMGthWYRXTqT1E5oJvg+ljaa2OJi+VfvCOQ8w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/qs": {
      "version": "6.15.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.15.0.tgz",
      "integrity": "sha512-mAZTtNCeetKMH+pSjrb76NAM8V9a05I9aBZOHztWy/UqcJdQYNsf59vrRKWnojAT9Y+GbIvoTBC++CPHqpDBhQ==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.2.tgz",
      "integrity": "sha512-K5zQjDllxWkf7Z5xJdV0/B0WTNqx6vxG70zJE4N0kBs4LovmEYWJzQGxC9bS9RAKu3bgM40lrd5zoLJ12MQ5BA==",
      "license": "MIT",
      "dependencies": {
        "bytes": "~3.1.2",
        "http-errors": "~2.0.1",
        "iconv-lite": "~0.7.0",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/router": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/router/-/router-2.2.0.tgz",
      "integrity": "sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "depd": "^2.0.0",
        "is-promise": "^4.0.0",
        "parseurl": "^1.3.3",
        "path-to-regexp": "^8.0.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.3",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.3.tgz",
      "integrity": "sha512-SdsKMrI9TdgjdweUSR9MweHA4EJ8YxHn8DFaDisvhVlUOe4BF1tLD7GAj0lIqWVl+dPb/rExr0Btby5loQm20Q==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/send/-/send-1.2.1.tgz",
      "integrity": "sha512-1gnZf7DFcoIcajTjTwjwuDjzuz4PPcY2StKPlsGAQ1+YH20IRVrBaXSWmdjowTJ6u8Rc01PoYOGHXfP1mYcZNQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.3",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.1",
        "mime-types": "^3.0.2",
        "ms": "^2.1.3",
        "on-finished": "^2.4.1",
        "range-parser": "^1.2.1",
        "statuses": "^2.0.2"
      },
      "engines": {
        "node": ">= 18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/serve-static": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-2.2.1.tgz",
      "integrity": "sha512-xRXBn0pPqQTVQiC8wyQrKs2MOlX24zQ0POGaj0kultvoOCstBQM5yvOhAVSUwOMjQtTvsPWoNCHfPGwaaQJhTw==",
      "license": "MIT",
      "dependencies": {
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "parseurl": "^1.3.3",
        "send": "^1.2.0"
      },
      "engines": {
        "node": ">= 18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "license": "ISC"
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/sift": {
      "version": "17.1.3",
      "resolved": "https://registry.npmjs.org/sift/-/sift-17.1.3.tgz",
      "integrity": "sha512-Rtlj66/b0ICeFzYTuNvX/EF1igRbbnGSvEyT79McoZa/DeGhMyC5pWKOEsZKnpkqtSeovd5FL/bjHWC3CIIvCQ==",
      "license": "MIT"
    },
    "node_modules/simple-update-notifier": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-2.0.0.tgz",
      "integrity": "sha512-a2B9Y0KlNXl9u/vsW6sTIu9vGEpfKu2wRV6l1H3XEas/0gUIzGzBoP/IouTcUQbm9JWZLH3COxyn03TYlFax6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/socket.io": {
      "version": "4.8.1",
      "resolved": "https://registry.npmjs.org/socket.io/-/socket.io-4.8.1.tgz",
      "integrity": "sha512-oZ7iUCxph8WYRHHcjBEc9unw3adt5CmSNlppj/5Q4k2RIrhl8Z5yY2Xr4j9zj0+wzVZ0bxmYoGSzKJnRl6A4yg==",
      "license": "MIT",
      "dependencies": {
        "accepts": "~1.3.4",
        "base64id": "~2.0.0",
        "cors": "~2.8.5",
        "debug": "~4.3.2",
        "engine.io": "~6.6.0",
        "socket.io-adapter": "~2.5.2",
        "socket.io-parser": "~4.2.4"
      },
      "engines": {
        "node": ">=10.2.0"
      }
    },
    "node_modules/socket.io-adapter": {
      "version": "2.5.5",
      "resolved": "https://registry.npmjs.org/socket.io-adapter/-/socket.io-adapter-2.5.5.tgz",
      "integrity": "sha512-eLDQas5dzPgOWCk9GuuJC2lBqItuhKI4uxGgo9aIV7MYbk2h9Q6uULEh8WBzThoI7l+qU9Ast9fVUmkqPP9wYg==",
      "license": "MIT",
      "dependencies": {
        "debug": "~4.3.4",
        "ws": "~8.17.1"
      }
    },
    "node_modules/socket.io-adapter/node_modules/debug": {
      "version": "4.3.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.7.tgz",
      "integrity": "sha512-Er2nc/H7RrMXZBFCEim6TCmMk02Z8vLC2Rbi1KEBggpo0fS6l0S1nnapwmIi3yW/+GOJap1Krg4w0Hg80oCqgQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/socket.io-parser": {
      "version": "4.2.4",
      "resolved": "https://registry.npmjs.org/socket.io-parser/-/socket.io-parser-4.2.4.tgz",
      "integrity": "sha512-/GbIKmo8ioc+NIWIhwdecY0ge+qVBSMdgxGygevmdHj24bsfgtCmcUUcQ5ZzcylGFHsN3k4HB4Cgkl96KVnuew==",
      "license": "MIT",
      "dependencies": {
        "@socket.io/component-emitter": "~3.1.0",
        "debug": "~4.3.1"
      },
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/socket.io-parser/node_modules/debug": {
      "version": "4.3.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.7.tgz",
      "integrity": "sha512-Er2nc/H7RrMXZBFCEim6TCmMk02Z8vLC2Rbi1KEBggpo0fS6l0S1nnapwmIi3yW/+GOJap1Krg4w0Hg80oCqgQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/socket.io/node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/socket.io/node_modules/debug": {
      "version": "4.3.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.7.tgz",
      "integrity": "sha512-Er2nc/H7RrMXZBFCEim6TCmMk02Z8vLC2Rbi1KEBggpo0fS6l0S1nnapwmIi3yW/+GOJap1Krg4w0Hg80oCqgQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/socket.io/node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/socket.io/node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/socket.io/node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/sparse-bitfield": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/sparse-bitfield/-/sparse-bitfield-3.0.3.tgz",
      "integrity": "sha512-kvzhi7vqKTfkh0PZU+2D2PIllw2ymqJKujUcyPMd9Y75Nv4nPbGJZXNhxsgdQab2BmlDct1YnfQCguEvHr7VsQ==",
      "license": "MIT",
      "dependencies": {
        "memory-pager": "^1.0.2"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz",
      "integrity": "sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/touch": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/touch/-/touch-3.1.1.tgz",
      "integrity": "sha512-r0eojU4bI8MnHr8c5bNo7lJDdI2qXlWWJk6a9EAFG7vbhTjElYhBVS3/miuE0uOuoLdb8Mc/rVfsmm6eo5o9GA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "nodetouch": "bin/nodetouch.js"
      }
    },
    "node_modules/tr46": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-5.1.1.tgz",
      "integrity": "sha512-hdF5ZgjTqgAntKkklYw0R03MG2x/bSzTtkxmIRw/sTNV8YXsCJ1tfLAX23lhxhHJlEf3CRCOCGGWw3vI3GaSPw==",
      "license": "MIT",
      "dependencies": {
        "punycode": "^2.3.1"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/type-is": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-2.0.1.tgz",
      "integrity": "sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==",
      "license": "MIT",
      "dependencies": {
        "content-type": "^1.0.5",
        "media-typer": "^1.1.0",
        "mime-types": "^3.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/undefsafe": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/undefsafe/-/undefsafe-2.0.5.tgz",
      "integrity": "sha512-WxONCrssBM8TSPRqN5EmsjVrsv4A8X12J4ArBiiayv3DyyG3ZlIg6yysuuSYdZsVz3TKcTg2fd//Ujd4CHV1iA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/undici-types": {
      "version": "7.16.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.16.0.tgz",
      "integrity": "sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==",
      "license": "MIT"
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-7.0.0.tgz",
      "integrity": "sha512-VwddBukDzu71offAQR975unBIGqfKZpM+8ZX6ySk8nYhVoo5CYaZyzt3YBvYtRtO+aoGlqxPg/B87NGVZ/fu6g==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/whatwg-url": {
      "version": "14.2.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-14.2.0.tgz",
      "integrity": "sha512-De72GdQZzNTUBBChsXueQUnPKDkg/5A5zp7pFDuQAj5UFoENpiACU0wlCvzpAGnTkj++ihpKwKyYewn/XNUbKw==",
      "license": "MIT",
      "dependencies": {
        "tr46": "^5.1.0",
        "webidl-conversions": "^7.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    },
    "node_modules/ws": {
      "version": "8.17.1",
      "resolved": "https://registry.npmjs.org/ws/-/ws-8.17.1.tgz",
      "integrity": "sha512-6XQFvXTkbfUOZOKKILFG1PDK2NDQs4azKQl26T0YS5CxqWLgXajbPZ+h4gZekJyRqFU8pvnbAbbs/3TgRPy+GQ==",
      "license": "MIT",
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": ">=5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    }
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
package.json:

{
  "name": "unila-aqi-backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "reset-db": "node src/resetDatabase.js",
    "check-db": "node src/checkDatabase.js",
    "seed": "node src/seedOnly.js",
    "test-api": "node src/testApi.js",
    "test-socket": "node src/testSocket.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "axios": "^1.13.2",
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.3",
    "mongodb": "^7.0.0",
    "mongoose": "^9.0.2",
    "node-cron": "^4.2.1",
    "socket.io": "^4.8.1"
  },
  "devDependencies": {
    "nodemon": "^3.1.11"
  }
}



---------------------------------------------------------------------------------------------------------------------------------------
lib/core/constants/colors.dart:

import 'package:flutter/material.dart';

class AppColors {
  // Primary Colors
  static const Color primary = Color(0xFF0066CC);
  static const Color primaryDark = Color(0xFF0052A3);
  static const Color primaryLight = Color(0xFF3388FF);
  
  // Secondary Colors
  static const Color secondary = Color(0xFF00B894);
  static const Color secondaryDark = Color(0xFF00A085);
  static const Color secondaryLight = Color(0xFF55EFC4);
  
  // AQI Colors (from US EPA standard)
  static const Color aqiGood = Color(0xFF00E400); // Green
  static const Color aqiModerate = Color(0xFFFF7E00); // Yellow
  static const Color aqiUnhealthySensitive = Color(0xFFFF0000); // Orange
  static const Color aqiUnhealthy = Color(0xFF7E0023); // Red
  static const Color aqiVeryUnhealthy = Color(0xFF8F3F97); // Purple
  static const Color aqiHazardous = Colors.black; // black
  
  // Neutral Colors
  static const Color background = Color(0xFFF8F9FA);
  static const Color cardBackground = Color(0xFFFFFFFF);
  static const Color surface = Color(0xFFF1F3F5);
  static const Color border = Color(0xFFDEE2E6);
  
  // Text Colors
  static const Color textPrimary = Color(0xFF212529);
  static const Color textSecondary = Color(0xFF495057);
  static const Color textHint = Color(0xFF6C757D);
  static const Color textDisabled = Color(0xFFADB5BD);
  
  // Status Colors
  static const Color success = Color(0xFF28A745);
  static const Color warning = Color(0xFFFFC107);
  static const Color error = Color(0xFFDC3545);
  static const Color info = Color(0xFF17A2B8);

  
  // Gradient Colors
  static const LinearGradient primaryGradient = LinearGradient(
    colors: [primary, primaryLight],
    begin: Alignment.topLeft,
    end: Alignment.bottomRight,
  );
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/core/services/api_service.dart:

import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';
import '../../core/constants/app_constants.dart';

class ApiService {
  static final ApiService _instance = ApiService._internal();
  factory ApiService() => _instance;
  ApiService._internal();

  // Base configuration
  static const String baseUrl = AppConstants.apiBaseUrl;
  static const Duration timeout = Duration(seconds: 30);

  // HTTP client
  final http.Client _client = http.Client();

  // Headers
  Future<Map<String, String>> _getHeaders() async {
    final prefs = await SharedPreferences.getInstance();
    final token = prefs.getString('auth_token');

    final headers = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };

    if (token != null) {
      headers['Authorization'] = 'Bearer $token';
    }

    return headers;
  }

  // Generic request method
  Future<http.Response> _request(
    String method,
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? queryParams,
  }) async {
    final headers = await _getHeaders();
    final uri = Uri.parse('$baseUrl/$endpoint').replace(queryParameters: queryParams);

    try {
      switch (method) {
        case 'GET':
          return await _client.get(uri, headers: headers).timeout(timeout);
        case 'POST':
          return await _client.post(
            uri,
            headers: headers,
            body: body != null ? jsonEncode(body) : null,
          ).timeout(timeout);
        case 'PUT':
          return await _client.put(
            uri,
            headers: headers,
            body: body != null ? jsonEncode(body) : null,
          ).timeout(timeout);
        case 'DELETE':
          return await _client.delete(uri, headers: headers).timeout(timeout);
        default:
          throw Exception('Unsupported HTTP method: $method');
      }
    } catch (e) {
      throw Exception('Network error: $e');
    }
  }

  // API Methods
  Future<dynamic> get(String endpoint, {Map<String, String>? queryParams}) async {
    final response = await _request('GET', endpoint, queryParams: queryParams);
    return _handleResponse(response);
  }

  Future<dynamic> post(String endpoint, Map<String, dynamic> body) async {
    final response = await _request('POST', endpoint, body: body);
    return _handleResponse(response);
  }

  Future<dynamic> put(String endpoint, Map<String, dynamic> body) async {
    final response = await _request('PUT', endpoint, body: body);
    return _handleResponse(response);
  }

  Future<dynamic> delete(String endpoint) async {
    final response = await _request('DELETE', endpoint);
    return _handleResponse(response);
  }

  // Response handler
  dynamic _handleResponse(http.Response response) {
    final statusCode = response.statusCode;
    final responseBody = response.body;

    try {
      final jsonResponse = jsonDecode(responseBody);

      if (statusCode >= 200 && statusCode < 300) {
        return jsonResponse;
      } else {
        final errorMessage = jsonResponse['message'] ?? 'Request failed with status $statusCode';
        throw Exception(errorMessage);
      }
    } catch (e) {
      if (statusCode >= 200 && statusCode < 300) {
        return responseBody;
      }
      throw Exception('Failed to parse response: $e');
    }
  }

  // ==================== AUTH ENDPOINTS ====================
  Future<dynamic> checkAdminRegistered() async {
    return await get('auth/check-admin');
  }

  Future<dynamic> adminLogin(String username, String password) async {
    return await post('auth/login', {
      'username': username,
      'password': password,
      'role': 'admin',
    });
  }

  Future<dynamic> getUserProfile() async {
    return await get('auth/profile');
  }

  // ==================== REAL DATA ENDPOINTS ====================
  
  // REAL: Get all buildings from database
  Future<dynamic> getBuildings() async {
    return await get('buildings');
  }

  // REAL: Get single building by ID
  Future<dynamic> getBuildingById(String id) async {
    return await get('buildings/$id');
  }

  // REAL: Create building
  Future<dynamic> createBuilding(Map<String, dynamic> data) async {
    return await post('buildings', data);
  }

  // REAL: Update building
  Future<dynamic> updateBuilding(String id, Map<String, dynamic> data) async {
    return await put('buildings/$id', data);
  }

  // REAL: Delete building
  Future<dynamic> deleteBuilding(String id) async {
    return await delete('buildings/$id');
  }

  // REAL: Get all rooms from database
  Future<dynamic> getRooms() async {
    return await get('rooms');
  }

  // REAL: Get single room by ID
  Future<dynamic> getRoomById(String id) async {
    return await get('rooms/$id');
  }

  // REAL: Create room
  Future<dynamic> createRoom(Map<String, dynamic> data) async {
    return await post('rooms', data);
  }

  // REAL: Update room
  Future<dynamic> updateRoom(String id, Map<String, dynamic> data) async {
    return await put('rooms/$id', data);
  }

  // REAL: Delete room
  Future<dynamic> deleteRoom(String id) async {
    return await delete('rooms/$id');
  }

  // REAL: Get all IoT devices
  Future<dynamic> getIoTDevices() async {
    return await get('iot-devices');
  }

  // REAL: Get single IoT device
  Future<dynamic> getIoTDeviceById(String id) async {
    return await get('iot-devices/$id');
  }

  // REAL: Create IoT device
  Future<dynamic> createIoTDevice(Map<String, dynamic> data) async {
    return await post('iot-devices', data);
  }

  // REAL: Update IoT device
  Future<dynamic> updateIoTDevice(String id, Map<String, dynamic> data) async {
    return await put('iot-devices/$id', data);
  }

  // REAL: Delete IoT device
  Future<dynamic> deleteIoTDevice(String id) async {
    return await delete('iot-devices/$id');
  }

  // REAL: Get sensor data for room
  Future<dynamic> getSensorData(String roomId) async {
  try {
    final headers = await _getHeaders();
    
    final response = await http.get(
      Uri.parse('$baseUrl/sensor-data/$roomId'),
      headers: headers,
    );
    
    if (response.statusCode == 200) {
      return jsonDecode(response.body);
    } else {
      // Return data kosong jika gagal
      return {
        'success': false,
        'data': []
      };
    }
  } catch (e) {
    return {
      'success': false,
      'data': [],
      'error': e.toString()
    };
  }
}

  // ==================== TEST/DEBUG ENDPOINTS ====================
  // (Keep for debugging but not used in production)
  Future<dynamic> getTestBuildings() async {
    return await get('test/buildings');
  }

  Future<dynamic> getTestRooms() async {
    return await get('test/rooms');
  }

  Future<dynamic> getTestStatus() async {
    return await get('test/status');
  }

  // ==================== UTILITY ENDPOINTS ====================
  Future<dynamic> seedSampleData() async {
    return await post('seed/seed', {});
  }

  Future<dynamic> clearSampleData() async {
    return await post('seed/clear', {});
  }

  Future<dynamic> syncBuildingNames() async {
    return await post('rooms/sync-building-names', {});
  }

Future<dynamic> forceRefresh() async {
  return await post('force-refresh', {});
}

// REAL: Get sensor history data untuk grafik
Future<dynamic> getSensorHistory(String roomId, String date, {int interval = 30}) async {
  try {
    final headers = await _getHeaders();
    
    final response = await http.get(
      Uri.parse('$baseUrl/sensor-data/$roomId/history?date=$date&interval=$interval'),
      headers: headers,
    );
    
    if (response.statusCode == 200) {
      final jsonResponse = jsonDecode(response.body);
      return jsonResponse;
    } else {
      return {
        'success': false,
        'data': [],
        'error': 'Failed to fetch history data: ${response.statusCode}'
      };
    }
  } catch (e) {
    return {
      'success': false,
      'data': [],
      'error': e.toString()
    };
  }
}

Future<dynamic> get24HoursSensorData(String roomId) async {
  try {
    final headers = await _getHeaders();
    
    final response = await http.get(
      Uri.parse('$baseUrl/sensor-data/$roomId'),
      headers: headers,
    );
    
    if (response.statusCode == 200) {
      return jsonDecode(response.body);
    } else {
      return {
        'success': false,
        'data': [],
        'error': 'Failed to fetch 24h data: ${response.statusCode}'
      };
    }
  } catch (e) {
    return {
      'success': false,
      'data': [],
      'error': e.toString()
    };
  }
}

  // Dispose
  void dispose() {
    _client.close();
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/core/services/auth_service.dart:

import 'package:shared_preferences/shared_preferences.dart';
import 'api_service.dart';

class AuthService {
  static final AuthService _instance = AuthService._internal();
  factory AuthService() => _instance;
  AuthService._internal();

  final ApiService _apiService = ApiService();

  // Check if admin is already registered
  Future<bool> isAdminRegistered() async {
    try {
      final response = await _apiService.checkAdminRegistered();
      return response['isRegistered'] ?? false;
    } catch (e) {
      return false;
    }
  }

  // Admin login
  Future<Map<String, dynamic>> loginAdmin(String username, String password) async {
    try {
      final response = await _apiService.adminLogin(username, password);
      
      if (response['success'] == true) {
        await _saveAuthData(response);
      }
      
      return response;
    } catch (e) {
      rethrow;
    }
  }

  // Save authentication data
  Future<void> _saveAuthData(Map<String, dynamic> response) async {
    final prefs = await SharedPreferences.getInstance();
    
    await prefs.setString('auth_token', response['token']);
    await prefs.setString('user_id', response['user']['id']);
    await prefs.setString('username', response['user']['username']);
    await prefs.setString('role', response['user']['role']);
    await prefs.setBool('is_logged_in', true);
  }

  // Check if user is logged in
  Future<bool> isLoggedIn() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool('is_logged_in') ?? false;
  }

  // Get current user
  Future<Map<String, dynamic>> getCurrentUser() async {
    final prefs = await SharedPreferences.getInstance();
    
    return {
      'id': prefs.getString('user_id'),
      'username': prefs.getString('username'),
      'role': prefs.getString('role'),
    };
  }

  // Get auth token
  Future<String?> getToken() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString('auth_token');
  }

  // Logout
  Future<void> logout() async {
    final prefs = await SharedPreferences.getInstance();
    
    await prefs.remove('auth_token');
    await prefs.remove('user_id');
    await prefs.remove('username');
    await prefs.remove('role');
    await prefs.setBool('is_logged_in', false);
  }

  // Change password
  Future<Map<String, dynamic>> changePassword(
    String oldPassword,
    String newPassword,
  ) async {
    try {
      final token = await getToken();
      if (token == null) {
        throw Exception('Not authenticated');
      }

      // This would call your backend API
      // For now, return a mock response
      return {
        'success': true,
        'message': 'Password changed successfully',
      };
    } catch (e) {
      rethrow;
    }
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/core/services/socket_service.dart:

import 'dart:async';

import 'package:socket_io_client/socket_io_client.dart' as IO;
import 'package:flutter/foundation.dart';
import 'package:unila_aqi/core/services/storage_service.dart';

class SocketService {
  static final SocketService _instance = SocketService._internal();
  factory SocketService() => _instance;
  SocketService._internal();

  IO.Socket? _socket;
  bool _isConnected = false;
  String? _currentRoomId;
  final Map<String, List<Function(dynamic)>> _eventHandlers = {};
  Timer? _reconnectTimer;
  int _reconnectAttempts = 0;
  final int _maxReconnectAttempts = 5;
  final Duration _reconnectInterval = Duration(seconds: 3);
  bool _isConnecting = false;
  
  // Connection state management
  final StreamController<bool> _connectionController = StreamController<bool>.broadcast();
  final StreamController<Map<String, dynamic>> _dataController = StreamController<Map<String, dynamic>>.broadcast();

  // Getters
  bool get isConnected => _isConnected;
  bool get isConnecting => _isConnecting;
  IO.Socket? get socket => _socket;
  Stream<bool> get connectionStream => _connectionController.stream;
  Stream<Map<String, dynamic>> get dataStream => _dataController.stream;

  // Connect to server
  Future<void> connect({String? token}) async {
    if (_isConnecting || _isConnected) {
      if (kDebugMode) {
        print('âš ï¸ Socket is already connecting or connected');
      }
      return;
    }

    try {
      _isConnecting = true;
      
      if (kDebugMode) {
        print('ðŸ”„ Connecting to WebSocket server...');
      }

      // Disconnect existing socket if any
      disconnect();

      // Create new socket connection with optimized settings
      _socket = IO.io(
        'http://10.0.2.2:5000', // Use localhost for emulator
        IO.OptionBuilder()
          .setTransports(['websocket', 'polling']) // Prefer WebSocket
          .enableAutoConnect()
          .setReconnectionDelay(1000)
          .setReconnectionDelayMax(5000)
          .setReconnectionAttempts(_maxReconnectAttempts)
          .setTimeout(30000)
          .setExtraHeaders({
            if (token != null) 'Authorization': 'Bearer $token',
            'Cache-Control': 'no-cache'
          })
          .build(),
      );

      // Setup event listeners
      _setupEventListeners();

      // Connect manually with timeout
      _socket!.connect();
      
      // Set connection timeout
      Timer(Duration(seconds: 10), () {
        if (_isConnecting && !_isConnected) {
          if (kDebugMode) {
            print('âŒ Connection timeout');
          }
          _handleConnectionError('Connection timeout');
        }
      });

    } catch (e) {
      if (kDebugMode) {
        print('âŒ Error connecting to WebSocket: $e');
      }
      _handleConnectionError(e.toString());
    }
  }

  // Setup event listeners
  void _setupEventListeners() {
    if (_socket == null) return;

    // Connection established
    _socket!.onConnect((_) {
      _isConnecting = false;
      _isConnected = true;
      _reconnectAttempts = 0;
      
      if (_reconnectTimer != null) {
        _reconnectTimer!.cancel();
        _reconnectTimer = null;
      }
      
      if (kDebugMode) {
        print('âœ… WebSocket Connected: ${_socket!.id}');
      }
      
      _connectionController.add(true);
      
      // Rejoin room if previously joined
      if (_currentRoomId != null) {
        joinRoom(_currentRoomId!);
      }
      
      // Subscribe to dashboard updates
      _socket!.emit('subscribe-dashboard');
    });

    // Connection disconnected
    _socket!.onDisconnect((_) {
      if (kDebugMode) {
        print('âŒ WebSocket Disconnected');
      }
      
      _isConnecting = false;
      _isConnected = false;
      _connectionController.add(false);
      
      // Try to reconnect
      _scheduleReconnect();
    });

    // Connection error
    _socket!.onError((data) {
      if (kDebugMode) {
        print('âŒ WebSocket Error: $data');
      }
      _handleConnectionError(data.toString());
    });

    // Connect error
    _socket!.onConnectError((data) {
      if (kDebugMode) {
        print('âŒ WebSocket Connect Error: $data');
      }
      _handleConnectionError(data.toString());
    });

    // Ping-Pong for connection testing
    _socket!.on('pong', (data) {
      if (kDebugMode) {
        print('ðŸ“ Pong received: $data');
      }
    });

    // Room update handler - OPTIMIZED
     _socket!.on('room-update', (data) {
    if (kDebugMode) {
      print('ðŸ“¡ Room update received: ${data['roomId']}');
    }
    
    // Add timestamp if not present
    if (data['timestamp'] == null) {
      data['timestamp'] = DateTime.now().toIso8601String();
    }
    
    // Call registered handlers for this event
    if (_eventHandlers.containsKey('room-update')) {
      for (final handler in _eventHandlers['room-update']!) {
        try {
          handler(data);
        } catch (e) {
          if (kDebugMode) {
            print('âŒ Error in room-update handler: $e');
          }
        }
      }
    }
    
    // Broadcast to data stream
    _dataController.add({
      'type': 'room-update',
      'data': data,
      'timestamp': DateTime.now()
    });
  });

    // Dashboard update handler
    _socket!.on('dashboard-update', (data) {
      if (kDebugMode) {
        print('ðŸ“Š Dashboard update: ${data['type']}');
      }
      
      // Call registered handlers
      if (_eventHandlers.containsKey('dashboard-update')) {
        for (final handler in _eventHandlers['dashboard-update']!) {
          try {
            handler(data);
          } catch (e) {
            if (kDebugMode) {
              print('âŒ Error in dashboard-update handler: $e');
            }
          }
        }
      }
      
      // Broadcast to data stream
      _dataController.add({
        'type': 'dashboard-update',
        'data': data,
        'timestamp': DateTime.now()
      });
    });

    // ðŸ”¥ BARU: Dashboard room updated handler
  _socket!.on('dashboard-room-updated', (data) {
    if (kDebugMode) {
      print('ðŸ“Š Dashboard room updated: ${data['action']} - ${data['room']['name']}');
    }
    
    // Call registered handlers
    if (_eventHandlers.containsKey('dashboard-room-updated')) {
      for (final handler in _eventHandlers['dashboard-room-updated']!) {
        try {
          handler(data);
        } catch (e) {
          if (kDebugMode) {
            print('âŒ Error in dashboard-room-updated handler: $e');
          }
        }
      }
    }
    
    // Broadcast to data stream
    _dataController.add({
      'type': 'dashboard-room-updated',
      'data': data,
      'timestamp': DateTime.now()
    });
  });

  // ðŸ”¥ BARU: Room name changed handler
  _socket!.on('room-name-changed', (data) {
    if (kDebugMode) {
      print('âœï¸ Room name changed: ${data['oldName']} -> ${data['newName']}');
    }
    
    // Call registered handlers
    if (_eventHandlers.containsKey('room-name-changed')) {
      for (final handler in _eventHandlers['room-name-changed']!) {
        try {
          handler(data);
        } catch (e) {
          if (kDebugMode) {
            print('âŒ Error in room-name-changed handler: $e');
          }
        }
      }
    }
    
    // Broadcast to data stream
    _dataController.add({
      'type': 'room-name-changed',
      'data': data,
      'timestamp': DateTime.now()
    });
  });

  // ðŸ”¥ BARU: Room building changed handler
  _socket!.on('room-building-changed', (data) {
    if (kDebugMode) {
      print('ðŸ¢ Room building changed: ${data['roomId']}');
    }
    
    // Call registered handlers
    if (_eventHandlers.containsKey('room-building-changed')) {
      for (final handler in _eventHandlers['room-building-changed']!) {
        try {
          handler(data);
        } catch (e) {
          if (kDebugMode) {
            print('âŒ Error in room-building-changed handler: $e');
          }
        }
      }
    }
  });

  // Global notification handler
  _socket!.on('notification', (data) {
    if (kDebugMode) {
      print('ðŸ”” Notification received: ${data['message']}');
    }
    
    if (_eventHandlers.containsKey('notification')) {
      for (final handler in _eventHandlers['notification']!) {
        try {
          handler(data);
        } catch (e) {
          if (kDebugMode) {
            print('âŒ Error in notification handler: $e');
          }
        }
      }
    }
  });
  }

  // Handle connection error
  void _handleConnectionError(String error) {
    _isConnecting = false;
    _isConnected = false;
    _connectionController.add(false);
    
    if (kDebugMode) {
      print('âš ï¸ Connection error: $error');
    }
    
    _scheduleReconnect();
  }

  // Schedule reconnection
  void _scheduleReconnect() {
    if (_reconnectAttempts >= _maxReconnectAttempts) {
      if (kDebugMode) {
        print('âš ï¸ Max reconnection attempts reached');
      }
      return;
    }

    if (_reconnectTimer == null || !_reconnectTimer!.isActive) {
      _reconnectAttempts++;
      
      if (kDebugMode) {
        print('ðŸ”„ Scheduling reconnect attempt $_reconnectAttempts in ${_reconnectInterval.inSeconds}s');
      }

      _reconnectTimer = Timer(_reconnectInterval, () async {
        if (!_isConnected && !_isConnecting) {
          if (kDebugMode) {
            print('ðŸ”„ Attempting to reconnect...');
          }
          // Get new token if needed
          final storageService = StorageService();
          final token = await storageService.getString('auth_token');
          await connect(token: token);
        }
      });
    }
  }

  // Join a room
  void joinRoom(String roomId) {
    if (_socket != null && _isConnected) {
      _socket!.emit('join-room', roomId);
      _currentRoomId = roomId;
      
      if (kDebugMode) {
        print('ðŸ“¡ Joined room: $roomId');
      }
    } else {
      if (kDebugMode) {
        print('âš ï¸ Socket not connected, queuing room join');
      }
      _currentRoomId = roomId;
      
      // Try to connect
      if (!_isConnecting) {
        connect();
      }
    }
  }

  // Leave a room
  void leaveRoom(String roomId) {
    if (_socket != null && _isConnected) {
      _socket!.emit('leave-room', roomId);
      if (_currentRoomId == roomId) {
        _currentRoomId = null;
      }
      
      if (kDebugMode) {
        print('ðŸ“¡ Left room: $roomId');
      }
    }
  }

  // Send ping to test connection
  void ping() {
    if (_socket != null && _isConnected) {
      _socket!.emit('ping');
      
      if (kDebugMode) {
        print('ðŸ“ Ping sent');
      }
    }
  }

  // Request manual refresh
  void requestRefresh() {
    if (_socket != null && _isConnected) {
      _socket!.emit('request-refresh');
      
      if (kDebugMode) {
        print('ðŸ”„ Manual refresh requested');
      }
    }
  }

  // Register event handler
  void on(String event, Function(dynamic) handler) {
    if (!_eventHandlers.containsKey(event)) {
      _eventHandlers[event] = [];
    }
    _eventHandlers[event]!.add(handler);
  }

  // Unregister event handler
  void off(String event, [Function(dynamic)? handler]) {
    if (_eventHandlers.containsKey(event)) {
      if (handler != null) {
        _eventHandlers[event]!.remove(handler);
        if (_eventHandlers[event]!.isEmpty) {
          _eventHandlers.remove(event);
        }
      } else {
        _eventHandlers.remove(event);
      }
    }
  }

  // Disconnect from server
  void disconnect() {
    if (_socket != null) {
      // Leave current room
      if (_currentRoomId != null) {
        leaveRoom(_currentRoomId!);
      }
      
      // Cancel reconnect timer
      if (_reconnectTimer != null) {
        _reconnectTimer!.cancel();
        _reconnectTimer = null;
      }
      
      // Disconnect socket
      _socket!.disconnect();
      _socket!.destroy();
      _socket = null;
      
      _isConnecting = false;
      _isConnected = false;
      _currentRoomId = null;
      _eventHandlers.clear();
      _reconnectAttempts = 0;
      
      _connectionController.add(false);
      
      if (kDebugMode) {
        print('ðŸ”Œ WebSocket disconnected');
      }
    }
  }

  // Check connection status
  Future<bool> checkConnection() async {
    if (_socket != null && _isConnected) {
      try {
        // Send ping and wait for pong
        final completer = Completer<bool>();
        
        final tempHandler = (data) {
          completer.complete(true);
        };
        
        _socket!.once('pong', tempHandler);
        ping();
        
        return await completer.future.timeout(
          Duration(seconds: 3),
          onTimeout: () {
            _socket!.off('pong', tempHandler);
            return false;
          },
        );
      } catch (e) {
        return false;
      }
    }
    return false;
  }

  // Clean up resources
  void dispose() {
    disconnect();
    _connectionController.close();
    _dataController.close();
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/core/services/storage_service.dart:

import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';

class StorageService {
  static final StorageService _instance = StorageService._internal();
  factory StorageService() => _instance;
  StorageService._internal();

  late SharedPreferences _prefs;

  Future<void> init() async {
    _prefs = await SharedPreferences.getInstance();
  }

  // Socket.io connection settings
  Future<void> setSocketConnected(bool value) async {
    await _prefs.setBool('socket_connected', value);
  }

  bool getSocketConnected() {
    return _prefs.getBool('socket_connected') ?? false;
  }

  Future<void> setLastSocketConnection(DateTime date) async {
    await _prefs.setString('last_socket_connection', date.toIso8601String());
  }

  DateTime? getLastSocketConnection() {
    final value = _prefs.getString('last_socket_connection');
    return value != null ? DateTime.parse(value) : null;
  }

  // Room subscription management
  Future<void> addSubscribedRoom(String roomId) async {
    final rooms = getSubscribedRooms();
    if (!rooms.contains(roomId)) {
      rooms.add(roomId);
      await _prefs.setStringList('subscribed_rooms', rooms);
    }
  }

  Future<void> removeSubscribedRoom(String roomId) async {
    final rooms = getSubscribedRooms();
    rooms.remove(roomId);
    await _prefs.setStringList('subscribed_rooms', rooms);
  }

  List<String> getSubscribedRooms() {
    return _prefs.getStringList('subscribed_rooms') ?? [];
  }

  Future<void> clearSubscribedRooms() async {
    await _prefs.remove('subscribed_rooms');
  }

  // String operations
  Future<void> setString(String key, String value) async {
    await _prefs.setString(key, value);
  }

  String? getString(String key) {
    return _prefs.getString(key);
  }

  // Bool operations
  Future<void> setBool(String key, bool value) async {
    await _prefs.setBool(key, value);
  }

  bool getBool(String key, {bool defaultValue = false}) {
    return _prefs.getBool(key) ?? defaultValue;
  }

  // Int operations
  Future<void> setInt(String key, int value) async {
    await _prefs.setInt(key, value);
  }

  int getInt(String key, {int defaultValue = 0}) {
    return _prefs.getInt(key) ?? defaultValue;
  }

  // Double operations
  Future<void> setDouble(String key, double value) async {
    await _prefs.setDouble(key, value);
  }

  double getDouble(String key, {double defaultValue = 0.0}) {
    return _prefs.getDouble(key) ?? defaultValue;
  }

  // List operations
  Future<void> setStringList(String key, List<String> value) async {
    await _prefs.setStringList(key, value);
  }

  List<String> getStringList(String key, {List<String> defaultValue = const []}) {
    return _prefs.getStringList(key) ?? defaultValue;
  }

  // JSON operations
  Future<void> setJson(String key, Map<String, dynamic> value) async {
    await _prefs.setString(key, jsonEncode(value));
  }

  Map<String, dynamic>? getJson(String key) {
    final value = _prefs.getString(key);
    if (value != null) {
      return jsonDecode(value);
    }
    return null;
  }

  // Remove key
  Future<void> remove(String key) async {
    await _prefs.remove(key);
  }

  // Clear all data
  Future<void> clear() async {
    await _prefs.clear();
  }

  // Check if key exists
  bool containsKey(String key) {
    return _prefs.containsKey(key);
  }

  // Get all keys
  Set<String> getKeys() {
    return _prefs.getKeys();
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/core/themes/app_theme.dart:

import 'package:flutter/material.dart';
import '../constants/colors.dart';

class AppTheme {
  static ThemeData lightTheme = ThemeData(
    useMaterial3: true,
    brightness: Brightness.light,
    primaryColor: AppColors.primary,
    primarySwatch: _createMaterialColor(AppColors.primary),
    scaffoldBackgroundColor: AppColors.background,
    appBarTheme: const AppBarTheme(
      backgroundColor: Colors.white,
      elevation: 0,
      centerTitle: true,
      iconTheme: IconThemeData(color: AppColors.textPrimary),
      titleTextStyle: TextStyle(
        color: AppColors.textPrimary,
        fontSize: 18,
        fontWeight: FontWeight.w600,
        fontFamily: 'Inter',
      ),
    ),
    cardTheme: CardThemeData(
      color: AppColors.cardBackground,
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: const BorderSide(color: AppColors.border, width: 1),
      ),
      margin: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
    ),
    inputDecorationTheme: InputDecorationTheme(
      filled: true,
      fillColor: Colors.white,
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(8),
        borderSide: const BorderSide(color: AppColors.border),
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(8),
        borderSide: const BorderSide(color: AppColors.border),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(8),
        borderSide: const BorderSide(color: AppColors.primary, width: 2),
      ),
      errorBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(8),
        borderSide: const BorderSide(color: AppColors.error),
      ),
      focusedErrorBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(8),
        borderSide: const BorderSide(color: AppColors.error, width: 2),
      ),
      labelStyle: const TextStyle(color: AppColors.textSecondary),
      hintStyle: const TextStyle(color: AppColors.textHint),
      errorStyle: const TextStyle(color: AppColors.error),
    ),
    buttonTheme: const ButtonThemeData(
      buttonColor: AppColors.primary,
      textTheme: ButtonTextTheme.primary,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.all(Radius.circular(8)),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: AppColors.primary,
        foregroundColor: Colors.white,
        padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 24),
        textStyle: const TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.w600,
          fontFamily: 'Inter',
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        elevation: 2,
      ),
    ),
    textButtonTheme: TextButtonThemeData(
      style: TextButton.styleFrom(
        foregroundColor: AppColors.primary,
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        textStyle: const TextStyle(
          fontSize: 14,
          fontWeight: FontWeight.w500,
          fontFamily: 'Inter',
        ),
      ),
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        foregroundColor: AppColors.primary,
        side: const BorderSide(color: AppColors.primary),
        padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 24),
        textStyle: const TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.w600,
          fontFamily: 'Inter',
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
    ),
    textTheme: const TextTheme(
      displayLarge: TextStyle(
        fontSize: 32,
        fontWeight: FontWeight.w700,
        color: AppColors.textPrimary,
        fontFamily: 'Inter',
      ),
      displayMedium: TextStyle(
        fontSize: 28,
        fontWeight: FontWeight.w600,
        color: AppColors.textPrimary,
        fontFamily: 'Inter',
      ),
      displaySmall: TextStyle(
        fontSize: 24,
        fontWeight: FontWeight.w600,
        color: AppColors.textPrimary,
        fontFamily: 'Inter',
      ),
      headlineMedium: TextStyle(
        fontSize: 20,
        fontWeight: FontWeight.w600,
        color: AppColors.textPrimary,
        fontFamily: 'Inter',
      ),
      headlineSmall: TextStyle(
        fontSize: 18,
        fontWeight: FontWeight.w600,
        color: AppColors.textPrimary,
        fontFamily: 'Inter',
      ),
      titleLarge: TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.w600,
        color: AppColors.textPrimary,
        fontFamily: 'Inter',
      ),
      titleMedium: TextStyle(
        fontSize: 14,
        fontWeight: FontWeight.w500,
        color: AppColors.textSecondary,
        fontFamily: 'Inter',
      ),
      titleSmall: TextStyle(
        fontSize: 12,
        fontWeight: FontWeight.w500,
        color: AppColors.textHint,
        fontFamily: 'Inter',
      ),
      bodyLarge: TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.w400,
        color: AppColors.textPrimary,
        fontFamily: 'Inter',
      ),
      bodyMedium: TextStyle(
        fontSize: 14,
        fontWeight: FontWeight.w400,
        color: AppColors.textPrimary,
        fontFamily: 'Inter',
      ),
      bodySmall: TextStyle(
        fontSize: 12,
        fontWeight: FontWeight.w400,
        color: AppColors.textSecondary,
        fontFamily: 'Inter',
      ),
      labelLarge: TextStyle(
        fontSize: 14,
        fontWeight: FontWeight.w500,
        color: Colors.white,
        fontFamily: 'Inter',
      ),
    ),
    dividerTheme: const DividerThemeData(
      color: AppColors.border,
      thickness: 1,
      space: 16,
    ),
    colorScheme: ColorScheme.fromSwatch(
      primarySwatch: _createMaterialColor(AppColors.primary),
      backgroundColor: AppColors.background,
      cardColor: AppColors.cardBackground,
      errorColor: AppColors.error,
    ).copyWith(
      secondary: AppColors.secondary,
    ),
  );

  static MaterialColor _createMaterialColor(Color color) {
    List strengths = <double>[.05];
    Map<int, Color> swatch = {};
    final int r = color.red, g = color.green, b = color.blue;

    for (int i = 1; i < 10; i++) {
      strengths.add(0.1 * i);
    }

    for (var strength in strengths) {
      final double ds = 0.5 - strength;
      swatch[(strength * 1000).round()] = Color.fromRGBO(
        r + ((ds < 0 ? r : (255 - r)) * ds).round(),
        g + ((ds < 0 ? g : (255 - g)) * ds).round(),
        b + ((ds < 0 ? b : (255 - b)) * ds).round(),
        1,
      );
    }

    return MaterialColor(color.value, swatch);
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/core/utils/date_formatter.dart:

import 'package:intl/intl.dart';

class DateFormatter {
  static String format(DateTime date, {String pattern = 'dd/MM/yyyy'}) {
    return DateFormat(pattern).format(date);
  }

  static String formatTime(DateTime date, {String pattern = 'HH:mm'}) {
    return DateFormat(pattern).format(date);
  }

  static String formatDateTime(DateTime date) {
    return DateFormat('dd/MM/yyyy HH:mm').format(date);
  }

  static String formatRelative(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inSeconds < 60) {
      return 'Baru saja';
    } else if (difference.inMinutes < 60) {
      return '${difference.inMinutes} menit lalu';
    } else if (difference.inHours < 24) {
      return '${difference.inHours} jam lalu';
    } else if (difference.inDays == 1) {
      return 'Kemarin';
    } else if (difference.inDays < 7) {
      return '${difference.inDays} hari lalu';
    } else {
      return format(date);
    }
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/core/utils/helpers.dart:

import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:unila_aqi/data/models/room.dart';
import '../constants/colors.dart';
import '../constants/app_constants.dart';

class Helpers {
  // AQI Helpers
  static Color getAQIColor(int aqi) {
    if (aqi <= 50) return AppColors.aqiGood; // hijau
    if (aqi <= 100) return AppColors.aqiModerate; // orange untuk sedang
    if (aqi <= 150) return AppColors.aqiUnhealthySensitive; // merah
    if (aqi <= 200) return AppColors.aqiUnhealthy; // purple
    if (aqi <= 300) return AppColors.aqiVeryUnhealthy; // hitam
    return AppColors.aqiHazardous; // hitam
  }

  static String getAQILabel(int aqi) {
    if (aqi <= 50) return 'BAIK';
    if (aqi <= 100) return 'SEDANG';
    if (aqi <= 150) return 'TIDAK SEHAT';
    if (aqi <= 200) return 'SANGAT TIDAK SEHAT';
    if (aqi <= 300) return 'BERBAHAYA';
    return 'SANGAT BERBAHAYA';
  }

  static String getAQIHealthMessage(int aqi) {
    if (aqi <= 50) return AppConstants.healthRecommendations['good']!;
    if (aqi <= 100) return AppConstants.healthRecommendations['moderate']!;
    if (aqi <= 150) return AppConstants.healthRecommendations['unhealthy']!;
    if (aqi <= 200) return AppConstants.healthRecommendations['very_unhealthy']!;
    if (aqi <= 300) return AppConstants.healthRecommendations['hazardous']!;
    return AppConstants.healthRecommendations['dangerous']!;
  }

  // Parameter Status Helpers
  static String getPM25Status(double value) {
    if (value <= 12) return 'BAIK';
    if (value <= 35.4) return 'SEDANG';
    if (value <= 55.4) return 'TIDAK SEHAT';
    if (value <= 150.4) return 'SANGAT TIDAK SEHAT';
    if (value <= 250.4) return 'BERBAHAYA';
    return 'BERBAHAYA';
  }

  static Color getPM25Color(double value) {
    if (value <= 12) return AppColors.aqiGood; // hijau
    if (value <= 35.4) return AppColors.aqiModerate; // orange untuk sedang
    if (value <= 55.4) return AppColors.aqiUnhealthySensitive; // merah
    if (value <= 150.4) return AppColors.aqiUnhealthy; // purple
    if (value <= 250.4) return AppColors.aqiVeryUnhealthy; // hitam
    return AppColors.aqiHazardous; // hitam
  }

  static String getPM10Status(double value) {
    if (value <= 50) return 'BAIK';
    if (value <= 100) return 'SEDANG';
    if (value <= 150) return 'TIDAK SEHAT';
    if (value <= 250) return 'SANGAT TIDAK SEHAT';
    if (value <= 350) return 'BERBAHAYA';
    return 'BERBAHAYA';
  }

  static Color getPM10Color(double value) {
    if (value <= 50) return AppColors.aqiGood; // hijau
    if (value <= 100) return AppColors.aqiModerate; // orange untuk sedang
    if (value <= 150) return AppColors.aqiUnhealthySensitive; // merah
    if (value <= 250) return AppColors.aqiUnhealthy; // purple
    if (value <= 350) return AppColors.aqiVeryUnhealthy; // hitam
    return AppColors.aqiHazardous; // hitam
  }
  

  static String getTemperatureStatus(double value) {
    if (value >= 22 && value <= 26) return 'IDEAL';
    if (value >= 20 && value <= 28) return 'NORMAL';
    if (value >= 18 && value <= 30) return 'SEDANG';
    return 'TIDAK IDEAL';
  }

  static Color getTemperatureColor(double value) {
    if (value >= 22 && value <= 26) return AppColors.success; // hijau
    if (value >= 20 && value <= 28) return Colors.orange; // orange
    if (value >= 18 && value <= 30) return AppColors.aqiUnhealthySensitive; // merah
    return AppColors.aqiUnhealthy; // purple
  }

  static String getHumidityStatus(double value) {
    if (value >= 40 && value <= 60) return 'IDEAL';
    if (value >= 30 && value <= 70) return 'NORMAL';
    if (value >= 20 && value <= 80) return 'SEDANG';
    return 'TIDAK IDEAL';
  }

  static Color getHumidityColor(double value) {
    if (value >= 40 && value <= 60) return AppColors.success; // hijau
    if (value >= 30 && value <= 70) return Colors.orange; // orange
    if (value >= 20 && value <= 80) return AppColors.aqiUnhealthySensitive; // merah
    return AppColors.aqiUnhealthy; // purple
  }

  static String getCO2Status(double value) {
    if (value <= 600) return 'BAIK';
    if (value <= 1000) return 'SEDANG';
    if (value <= 1500) return 'TIDAK SEHAT';
    if (value <= 2000) return 'SANGAT TIDAK SEHAT';
    return 'BERBAHAYA';
  }

  static Color getCO2Color(double value) {
    if (value <= 600) return AppColors.aqiGood; // hijau
    if (value <= 1000) return Colors.orange; // orange untuk sedang
    if (value <= 1500) return AppColors.aqiUnhealthySensitive; // merah
    if (value <= 2000) return AppColors.aqiUnhealthy; // purple
    return AppColors.aqiVeryUnhealthy; // hitam
  }

  // Date & Time Helpers
  static String formatDateTime(DateTime dateTime, {String format = 'dd/MM/yyyy HH:mm'}) {
    return DateFormat(format).format(dateTime);
  }

  // Tambah method format baru untuk waktu update
  static String formatLastUpdate(DateTime dateTime) {
    // Konversi ke waktu lokal
    final localTime = dateTime.toLocal();
    return '  ${_formatLocalTime(localTime)}';
  }

  static String formatLastUpdateWithDate(DateTime dateTime) {
    // Konversi ke waktu lokal
    final localTime = dateTime.toLocal();
    final now = DateTime.now().toLocal();
    
    // Jika tanggal sama dengan hari ini
    if (localTime.year == now.year &&
        localTime.month == now.month &&
        localTime.day == now.day) {
      return 'Hari ini ${_formatLocalTime(localTime)}';
    }
    
    // Jika tanggal kemarin
    final yesterday = DateTime(now.year, now.month, now.day - 1);
    if (localTime.year == yesterday.year &&
        localTime.month == yesterday.month &&
        localTime.day == yesterday.day) {
      return 'Kemarin ${_formatLocalTime(localTime)}';
    }
    
    // Format dengan tanggal (menggunakan format lokal)
    return DateFormat('dd/MM HH:mm').format(localTime);
  }

  static String _formatLocalTime(DateTime localTime) {
    // Format 24 jam
    final hour = localTime.hour.toString().padLeft(2, '0');
    final minute = localTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  static String formatLocalTimeForDisplay(DateTime dateTime) {
    final localTime = dateTime.toLocal();
    
    // Cek preferensi waktu 12/24 jam berdasarkan locale
    final format = DateFormat.Hm(); // Otomatis menggunakan 12/24 jam sesuai locale
    return format.format(localTime);
  }

  static String formatLocalTimeWithAmPm(DateTime dateTime) {
    final localTime = dateTime.toLocal();
    final format = DateFormat('hh:mm a'); // Contoh: 02:30 PM
    return format.format(localTime);
  }

  static String formatLocalDateTimeFull(DateTime dateTime) {
    final localTime = dateTime.toLocal();
    return DateFormat('dd MMM yyyy HH:mm').format(localTime); // Contoh: 15 Jan 2024 14:30
  }

  // Method untuk format real-time (akan diupdate setiap detik)
  static String formatRealTimeUpdate(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);
    
    // Format yang berbeda berdasarkan berapa lama yang lalu
    if (difference.inSeconds < 10) {
      return 'Live â€¢ Baru saja';
    } else if (difference.inSeconds < 60) {
      return 'Live â€¢ ${difference.inSeconds} detik lalu';
    } else if (difference.inMinutes < 5) {
      return 'Live â€¢ ${difference.inMinutes} menit lalu';
    } else {
      return 'Terakhir update ${DateFormat('HH:mm').format(dateTime)}';
    }
  }

  // Method untuk format dengan indikator status
  static Map<String, dynamic> formatUpdateWithStatus(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);
    
    String text;
    Color color;
    IconData icon;
    
    if (difference.inSeconds < 30) {
      text = 'Live â€¢ ${DateFormat('HH:mm').format(dateTime)}';
      color = Colors.green;
      icon = Icons.circle;
    } else if (difference.inSeconds < 60) {
      text = 'Baru â€¢ ${DateFormat('HH:mm').format(dateTime)}';
      color = Colors.green;
      icon = Icons.circle;
    } else if (difference.inMinutes < 5) {
      text = 'Terakhir update ${DateFormat('HH:mm').format(dateTime)}';
      color = Colors.blue;
      icon = Icons.circle;
    } else if (difference.inMinutes < 15) {
      text = 'Terakhir update ${DateFormat('HH:mm').format(dateTime)}';
      color = Colors.orange;
      icon = Icons.circle;
    } else {
      text = 'Update lama â€¢ ${DateFormat('dd/MM HH:mm').format(dateTime)}';
      color = Colors.grey;
      icon = Icons.circle;
    }
    
    return {
      'text': text,
      'color': color,
      'icon': icon,
      'isRecent': difference.inMinutes < 5,
      'difference': difference
    };
  }

  static String formatTimeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inSeconds < 60) {
      return '${difference.inSeconds} detik lalu';
    } else if (difference.inMinutes < 60) {
      return '${difference.inMinutes} menit lalu';
    } else if (difference.inHours < 24) {
      return '${difference.inHours} jam lalu';
    } else if (difference.inDays < 7) {
      return '${difference.inDays} hari lalu';
    } else {
      return DateFormat('dd MMM yyyy').format(dateTime);
    }
  }

  // UI Helpers
  static void showSnackBar(BuildContext context, String message, {bool isError = false}) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: isError ? AppColors.error : AppColors.success,
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
    );
  }

  static void showLoadingDialog(BuildContext context, {String message = 'Memuat...'}) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        content: Row(
          children: [
            const CircularProgressIndicator(),
            const SizedBox(width: 16),
            Text(message),
          ],
        ),
      ),
    );
  }

  static void dismissLoadingDialog(BuildContext context) {
    Navigator.of(context, rootNavigator: true).pop();
  }

  // Validation Helpers
  static bool isValidEmail(String email) {
    final emailRegex = RegExp(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$');
    return emailRegex.hasMatch(email);
  }

  static bool isValidPassword(String password) {
    return password.length >= 8;
  }

  // String Helpers
  static String capitalize(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1).toLowerCase();
  }

  static String truncateWithEllipsis(String text, int maxLength) {
    if (text.length <= maxLength) return text;
    return '${text.substring(0, maxLength)}...';
  }

  // JSON Helpers
  static Map<String, dynamic> safeJsonDecode(String jsonString) {
    try {
      return jsonDecode(jsonString);
    } catch (e) {
      return {};
    }
  }

  static String safeJsonEncode(Map<String, dynamic> data) {
    try {
      return jsonEncode(data);
    } catch (e) {
      return '{}';
    }
  }
  
  static String getAQICategory(int aqi) {
    if (aqi <= 50) return 'baik';
    if (aqi <= 100) return 'sedang';
    if (aqi <= 150) return 'tidak_sehat';
    if (aqi <= 200) return 'sangat_tidak_sehat';
    if (aqi <= 300) return 'berbahaya';
    return 'error';
  }
  
  // Network Helpers
  static String formatBytes(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1048576) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    return '${(bytes / 1048576).toStringAsFixed(1)} MB';
  }

  // Color Helpers
  static Color hexToColor(String hexString) {
    final buffer = StringBuffer();
    if (hexString.length == 6 || hexString.length == 7) buffer.write('ff');
    buffer.write(hexString.replaceFirst('#', ''));
    return Color(int.parse(buffer.toString(), radix: 16));
  }

  static String colorToHex(Color color) {
    return '#${color.value.toRadixString(16).padLeft(8, '0').substring(2)}';
  }

  static List<String> getDetailedRecommendations(Room room) {
    final recommendations = <String>[];
    final data = room.currentData;

    // AQI based recommendations
    final aqi = room.currentAQI;
     if (aqi > 300) {
      recommendations.add('KONDISI SANGAT BERBAHAYA - TIDAK ADA AKTIVITAS AKADEMIK TATAP MUKA');
      recommendations.add('Tim manajemen gedung melakukan pemantauan AQI setiap jam');
      recommendations.add('Nyalakan air purifier dengan kecepatan maksimum selama 24 jam non-stop untuk membersihkan ruangan');
    }else if (aqi > 200) {
      recommendations.add('Kualitas udara dalam kelas sangat berbahaya untuk perkuliahan tatap muka');
      recommendations.add('Segera alihkan seluruh perkuliahan ke metode daring atau asynchronous');
      recommendations.add('Nyalakan air purifier dengan kecepatan maksimum selama 24 jam non-stop untuk membersihkan ruangan');
    }else if (aqi > 150) {
      recommendations.add('Kualitas udara dalam kelas buruk dan berisiko bagi semua penghuni ruangan');
      recommendations.add('Gunakan masker ketika berada di ruangan ini');
      recommendations.add('Wjib menyalakan air purifier di setiap kelas yang digunakan');
    } else if (aqi > 100) {
      recommendations.add('Kualitas udara dalam kelas mulai berdampak pada kelompok sensitif');
      recommendations.add('Kurangi aktivitas fisik berat');
      recommendations.add('Jika tersedia, nyalakan air purifier di dalam kelas');
    } else if (aqi > 50) {
      recommendations.add('Kualitas udara masih dapat diterima untuk perkuliahan');
      recommendations.add('Pastikan kelas dalam keadaan bersih, tidak ada debu berlebih di lantai, meja, atau AC');
    } else {
      recommendations.add('Kualitas udara sangat baik dan optimal untuk proses belajar mengajar');
      recommendations.add('Aman untuk perkuliahan dengan durasi berapapun');
    }
    
    // PM2.5 specific
    if (data.pm25 > 35.4) {
      recommendations.add('PM2.5 tinggi: Gunakan air purifier');
    }

     // PM10 specific
    if (data.pm10 > 100) {
      recommendations.add('PM10 tinggi: Bersihkan kelas secara basah sebelum perkuliahan');
    }
    
    // CO2 specific
    if (data.co2 > 1000) {
      recommendations.add('COâ‚‚ tinggi: Buka jendela untuk ventilasi');
    }
    
    // Temperature specific
    if (data.temperature > 28) {
      recommendations.add('Suhu panas: Nyalakan AC atau kipas');
    } else if (data.temperature < 22) {
      recommendations.add('Suhu dingin: Gunakan pemanas ruangan');
    } 
    
    // Humidity specific
    if (data.humidity > 70) {
      recommendations.add('Kelembaban tinggi: Gunakan dehumidifier');
    } else if (data.humidity < 40) {
      recommendations.add('Kelembaban rendah: Gunakan humidifier');
    }
    
    return recommendations;
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/core/utils/validators.dart:

class Validators {
  static String? validateEmail(String? value) {
    if (value == null || value.isEmpty) {
      return 'Email tidak boleh kosong';
    }
    if (!RegExp(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$').hasMatch(value)) {
      return 'Format email tidak valid';
    }
    return null;
  }

  static String? validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Password tidak boleh kosong';
    }
    if (value.length < 8) {
      return 'Password minimal 8 karakter';
    }
    if (!RegExp(r'^(?=.*[a-zA-Z])(?=.*\d)').hasMatch(value)) {
      return 'Password harus mengandung huruf dan angka';
    }
    return null;
  }

  static String? validateConfirmPassword(String? value, String password) {
    if (value == null || value.isEmpty) {
      return 'Konfirmasi password tidak boleh kosong';
    }
    if (value != password) {
      return 'Password tidak cocok';
    }
    return null;
  }

  static String? validateRequired(String? value, String fieldName) {
    if (value == null || value.isEmpty) {
      return '$fieldName tidak boleh kosong';
    }
    return null;
  }

  static String? validateNumeric(String? value, String fieldName) {
    if (value == null || value.isEmpty) {
      return '$fieldName tidak boleh kosong';
    }
    if (!RegExp(r'^\d+$').hasMatch(value)) {
      return '$fieldName harus berupa angka';
    }
    return null;
  }

  static String? validatePositiveNumber(String? value, String fieldName) {
    if (value == null || value.isEmpty) {
      return '$fieldName tidak boleh kosong';
    }
    final num = double.tryParse(value);
    if (num == null) {
      return '$fieldName harus berupa angka';
    }
    if (num <= 0) {
      return '$fieldName harus lebih besar dari 0';
    }
    return null;
  }

  static String? validateRange(String? value, double min, double max, String fieldName) {
    if (value == null || value.isEmpty) {
      return '$fieldName tidak boleh kosong';
    }
    final num = double.tryParse(value);
    if (num == null) {
      return '$fieldName harus berupa angka';
    }
    if (num < min || num > max) {
      return '$fieldName harus antara $min dan $max';
    }
    return null;
  }

  static String? validateUrl(String? value) {
    if (value == null || value.isEmpty) {
      return 'URL tidak boleh kosong';
    }
    if (!RegExp(r'^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$').hasMatch(value)) {
      return 'Format URL tidak valid';
    }
    return null;
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
aqi_info.dart:

import 'dart:ui';

class AQIInfo {
  final String title;
  final String description;
  final String icon;
  final List<AQIParameter> parameters;
  final List<AQICategory> categories;
  final List<UnitInfo> units;

  AQIInfo({
    required this.title,
    required this.description,
    required this.icon,
    required this.parameters,
    required this.categories,
    required this.units,
  });
}

class AQIParameter {
  final String name;
  final String abbreviation;
  final String description;
  final String unit;
  final String impact;
  final String source;
  final String safeRange;
  final String icon;

  AQIParameter({
    required this.name,
    required this.abbreviation,
    required this.description,
    required this.unit,
    required this.impact,
    required this.source,
    required this.safeRange,
    required this.icon,
  });
}

class AQICategory {
  final String name;
  final String description;
  final Color color;
  final int min;
  final int max;
  final String healthEffect;
  final String recommendation;

  AQICategory({
    required this.name,
    required this.description,
    required this.color,
    required this.min,
    required this.max,
    required this.healthEffect,
    required this.recommendation,
  });
}

class UnitInfo {
  final String symbol;
  final String name;
  final String description;
  final String example;

  UnitInfo({
    required this.symbol,
    required this.name,
    required this.description,
    required this.example,
  });
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/data/models/building.dart:

class Building {
  final String id;
  final String name;
  final String? code;
  final String? description;
  final int roomCount;
  final DateTime createdAt;
  final DateTime updatedAt;

  Building({
    required this.id,
    required this.name,
    this.code,
    this.description,
    required this.roomCount,
    required this.createdAt,
    required this.updatedAt,
  });

  factory Building.fromJson(Map<String, dynamic> json) {
    return Building(
      id: json['_id'] ?? json['id'],
      name: json['name'],
      code: json['code'],
      description: json['description'],
      roomCount: json['roomCount'] ?? 0,
      createdAt: DateTime.parse(json['createdAt']),
      updatedAt: DateTime.parse(json['updatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'code': code,
      'description': description,
      'roomCount': roomCount,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
    };
  }

  String get displayName {
    return code != null ? '$name ($code)' : name;
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/data/models/iot_device.dart:

import 'package:flutter/material.dart';

class IoTDevice {
  final String id;
  final String name;
  final String? description;
  final String apiEndpoint; // Hapus buildingId dan buildingName
  final bool isActive;
  final DateTime? lastUpdate;
  final String status; // 'online', 'offline', 'error'
  final DateTime createdAt;
  final DateTime updatedAt;

  IoTDevice({
    required this.id,
    required this.name,
    this.description,
    required this.apiEndpoint,
    required this.isActive,
    this.lastUpdate,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
  });

  factory IoTDevice.fromJson(Map<String, dynamic> json) {
    return IoTDevice(
      id: json['_id'] ?? json['id'],
      name: json['name'],
      description: json['description'],
      apiEndpoint: json['apiEndpoint'],
      isActive: json['isActive'] ?? true,
      lastUpdate: json['lastUpdate'] != null
          ? DateTime.parse(json['lastUpdate'])
          : null,
      status: json['status'] ?? 'offline',
      createdAt: DateTime.parse(json['createdAt']),
      updatedAt: DateTime.parse(json['updatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'apiEndpoint': apiEndpoint,
      'isActive': isActive,
      'lastUpdate': lastUpdate?.toIso8601String(),
      'status': status,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
    };
  }

  String get displayStatus {
    switch (status) {
      case 'online':
        return 'Online';
      case 'offline':
        return 'Offline';
      case 'error':
        return 'Error';
      default:
        return 'Unknown';
    }
  }

  Color get statusColor {
    switch (status) {
      case 'online':
        return Colors.green;
      case 'offline':
        return Colors.grey;
      case 'error':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }

  bool get isOnline => status == 'online';
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/data/models/room.dart:

class Room {
  final String id;
  final String name;
  final String buildingId;
  final String buildingName;
  final String dataSource; // 'simulation' or 'iot'
  final String? iotDeviceId;
  final bool isActive;
  final int currentAQI;
  final RoomData currentData;
  final DateTime createdAt;
  final DateTime updatedAt;

  Room({
    required this.id,
    required this.name,
    required this.buildingId,
    required this.buildingName,
    required this.dataSource,
    this.iotDeviceId,
    required this.isActive,
    required this.currentAQI,
    required this.currentData,
    required this.createdAt,
    required this.updatedAt,
  });

  factory Room.fromJson(Map<String, dynamic> json) {
    return Room(
      id: json['_id'] ?? json['id'],
      name: json['name'],
      buildingId: json['building'] is String
          ? json['building']
          : json['building']['_id'] ?? json['building']['id'],
      buildingName: json['buildingName'] ??
          (json['building'] is Map ? json['building']['name'] : 'Unknown'),
      dataSource: json['dataSource'] ?? 'simulation',
      iotDeviceId: json['iotDeviceId'],
      isActive: json['isActive'] ?? true,
      currentAQI: json['currentAQI'] ?? 0,
      currentData: RoomData.fromJson(json['currentData'] ?? {}),
      createdAt: DateTime.parse(json['createdAt']),
      updatedAt: DateTime.parse(json['updatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'building': buildingId,
      'buildingName': buildingName,
      'dataSource': dataSource,
      'iotDeviceId': iotDeviceId,
      'isActive': isActive,
      'currentAQI': currentAQI,
      'currentData': currentData.toJson(),
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
    };
  }

  String get displayName {
    return '$name - $buildingName';
  }

  bool get isSimulation => dataSource == 'simulation';
  bool get isIot => dataSource == 'iot';
}

class RoomData {
  final double pm25;
  final double pm10;
  final double co2;
  final double temperature;
  final double humidity;
  final DateTime updatedAt;

  RoomData({
    required this.pm25,
    required this.pm10,
    required this.co2,
    required this.temperature,
    required this.humidity,
    required this.updatedAt,
  });

  factory RoomData.fromJson(Map<String, dynamic> json) {
    return RoomData(
      pm25: (json['pm25'] ?? 0).toDouble(),
      pm10: (json['pm10'] ?? 0).toDouble(),
      co2: (json['co2'] ?? 0).toDouble(),
      temperature: (json['temperature'] ?? 0).toDouble(),
      humidity: (json['humidity'] ?? 0).toDouble(),
      updatedAt: json['updatedAt'] != null
          ? DateTime.parse(json['updatedAt'])
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'pm25': pm25,
      'pm10': pm10,
      'co2': co2,
      'temperature': temperature,
      'humidity': humidity,
      'updatedAt': updatedAt.toIso8601String(),
    };
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/data/models/sensor_data.dart:

class SensorData {
  final String id;
  final String roomId;
  final String roomName;
  final String buildingName;
  final int aqi;
  final double pm25;
  final double pm10;
  final double co2;
  final double temperature;
  final double humidity;
  final String category;
  final DateTime timestamp;
  final List<dynamic>? rawData; // Untuk data agregasi
  final String? timeLabel; // Untuk label waktu

  SensorData({
    required this.id,
    required this.roomId,
    required this.roomName,
    required this.buildingName,
    required this.aqi,
    required this.pm25,
    required this.pm10,
    required this.co2,
    required this.temperature,
    required this.humidity,
    required this.category,
    required this.timestamp,
    this.rawData,
    this.timeLabel,
  });

  factory SensorData.fromJson(Map<String, dynamic> json) {
    return SensorData(
      id: json['_id']?.toString() ?? json['id']?.toString() ?? DateTime.now().millisecondsSinceEpoch.toString(),
      roomId: json['roomId']?.toString() ?? '',
      roomName: json['roomName']?.toString() ?? '',
      buildingName: json['buildingName']?.toString() ?? '',
      aqi: (json['aqi'] ?? 0).toInt(),
      pm25: (json['pm25'] ?? 0).toDouble(),
      pm10: (json['pm10'] ?? 0).toDouble(),
      co2: (json['co2'] ?? 0).toDouble(),
      temperature: (json['temperature'] ?? 0).toDouble(),
      humidity: (json['humidity'] ?? 0).toDouble(),
      category: json['category']?.toString() ?? 'baik',
      timestamp: json['timestamp'] != null 
          ? DateTime.parse(json['timestamp'].toString()).toLocal()
          : DateTime.now(),
      rawData: json['rawData'],
      timeLabel: json['timeLabel']?.toString(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'roomId': roomId,
      'roomName': roomName,
      'buildingName': buildingName,
      'aqi': aqi,
      'pm25': pm25,
      'pm10': pm10,
      'co2': co2,
      'temperature': temperature,
      'humidity': humidity,
      'category': category,
      'timestamp': timestamp.toIso8601String(),
      'rawData': rawData,
      'timeLabel': timeLabel,
    };
  }
}



---------------------------------------------------------------------------------------------------------------------------------------
lib/data/models/user.dart:

class User {
  final String id;
  final String username;
  final String email;
  final String role;
  final bool isActive;
  final DateTime? lastLogin;
  final DateTime createdAt;

  User({
    required this.id,
    required this.username,
    required this.email,
    required this.role,
    required this.isActive,
    this.lastLogin,
    required this.createdAt,
  });

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['_id'] ?? json['id'],
      username: json['username'],
      email: json['email'] ?? '',
      role: json['role'],
      isActive: json['isActive'] ?? true,
      lastLogin: json['lastLogin'] != null
          ? DateTime.parse(json['lastLogin'])
          : null,
      createdAt: DateTime.parse(json['createdAt']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'username': username,
      'email': email,
      'role': role,
      'isActive': isActive,
      'lastLogin': lastLogin?.toIso8601String(),
      'createdAt': createdAt.toIso8601String(),
    };
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
qi_info_repository.dart

import 'dart:ui';

import 'package:unila_aqi/data/models/aqi_info.dart';

class AQIInfoRepository {
  Future<AQIInfo> getAQIInfo() async {
    return AQIInfo(
      title: 'Air Quality Index (AQI)',
      description: 'AQI adalah indeks yang digunakan untuk melaporkan kualitas udara harian. '
          'AQI memberitahu Anda seberapa bersih atau tercemar udara Anda, dan apa efek kesehatan '
          'yang mungkin menjadi perhatian Anda.',
      icon: 'ðŸŒ¤ï¸',
      parameters: _getParameters(),
      categories: _getCategories(),
      units: _getUnits(),
    );
  }

  List<AQIParameter> _getParameters() {
    return [
      AQIParameter(
        name: 'PM2.5',
        abbreviation: 'PM2.5',
        description: 'Partikel halus dengan diameter 2.5 mikrometer atau lebih kecil. '
            'Sangat kecil dan dapat menembus jauh ke dalam paru-paru dan sistem peredaran darah.',
        unit: 'Î¼g/mÂ³',
        impact: 'Gangguan pernafasan, penyakit jantung, kanker paru-paru',
        source: 'Asap kendaraan, industri, kebakaran hutan, pembakaran sampah',
        safeRange: '0 - 12 Î¼g/mÂ³',
        icon: 'ðŸ—ï¸',
      ),
      AQIParameter(
        name: 'PM10',
        abbreviation: 'PM10',
        description: 'Partikel dengan diameter 10 mikrometer atau lebih kecil. '
            'Dapat terhirup dan masuk ke dalam sistem pernafasan.',
        unit: 'Î¼g/mÂ³',
        impact: 'Iritasi mata, hidung, tenggorokan, dan paru-paru',
        source: 'Debu jalanan, konstruksi, industri, serbuk sari',
        safeRange: '0 - 54 Î¼g/mÂ³',
        icon: 'ðŸ—ï¸',
      ),
      AQIParameter(
        name: 'Karbon Dioksida',
        abbreviation: 'COâ‚‚',
        description: 'Gas tidak berbau dan tidak berwarna yang dihasilkan dari pembakaran bahan bakar. '
            'Indikator utama ventilasi ruangan.',
        unit: 'ppm',
        impact: 'Sakit kepala, kelelahan, sulit konsentrasi, penurunan produktivitas',
        source: 'Pernafasan manusia, peralatan elektronik, mesin pembakaran',
        safeRange: '350 - 600 ppm',
        icon: 'â˜ï¸',
      ),
      AQIParameter(
        name: 'Suhu',
        abbreviation: 'T',
        description: 'Ukuran panas atau dinginnya udara dalam ruangan. '
            'Suhu yang tepat meningkatkan kenyamanan dan produktivitas.',
        unit: 'Â°C',
        impact: 'Ketidaknyamanan, dehidrasi, penurunan konsentrasi',
        source: 'Cuaca eksternal, peralatan elektronik, manusia',
        safeRange: '22 - 26 Â°C',
        icon: 'ðŸŒ¡ï¸',
      ),
      AQIParameter(
        name: 'Kelembaban',
        abbreviation: 'RH',
        description: 'Jumlah uap air di udara. '
            'Kelembaban yang tepat penting untuk kesehatan pernafasan dan kenyamanan.',
        unit: '%',
        impact: 'Pertumbuhan jamur, alergi, ketidaknyamanan pernafasan',
        source: 'Aktivitas manusia, cuaca, ventilasi',
        safeRange: '40 - 60 %',
        icon: 'ðŸ’§',
      ),
    ];
  }

  List<AQICategory> _getCategories() {
    return [
      AQICategory(
        name: 'Baik',
        description: 'Kualitas udara sangat baik, tidak ada risiko kesehatan',
        color: Color(0xFF00E400),
        min: 0,
        max: 50,
        healthEffect: 'Kualitas udara dianggap memuaskan, dan polusi udara menimbulkan sedikit atau tidak ada risiko',
        recommendation: 'Sangat baik untuk beraktivitas di luar ruangan',
      ),
      AQICategory(
        name: 'Sedang',
        description: 'Kualitas udara dapat diterima, risiko kecil untuk sebagian orang sensitif',
        color: Color(0xFFFFFF00),
        min: 51,
        max: 100,
        healthEffect: 'Orang dengan kondisi pernafasan mungkin merasakan efek ringan',
        recommendation: 'Batasi aktivitas fisik berat di luar ruangan',
      ),
      AQICategory(
        name: 'Tidak Sehat',
        description: 'Setiap orang mungkin mulai mengalami efek kesehatan',
        color: Color(0xFFFF7E00),
        min: 101,
        max: 150,
        healthEffect: 'Anggota kelompok sensitif mungkin mengalami efek kesehatan yang lebih serius',
        recommendation: 'Hindari aktivitas di luar ruangan yang terlalu lama',
      ),
      AQICategory(
        name: 'Sangat Tidak Sehat',
        description: 'Peringatan kesehatan darurat, seluruh populasi terpengaruh',
        color: Color(0xFFFF0000),
        min: 151,
        max: 200,
        healthEffect: 'Setiap orang mungkin mengalami efek kesehatan yang lebih serius',
        recommendation: 'Hindari semua aktivitas di luar ruangan',
      ),
      AQICategory(
        name: 'Berbahaya',
        description: 'Kondisi darurat kesehatan, seluruh populasi akan terpengaruh',
        color: Color(0xFF8F3F97),
        min: 201,
        max: 300,
        healthEffect: 'Peringatan kesehatan darurat, efek kesehatan pada seluruh populasi',
        recommendation: 'Tetap di dalam ruangan dengan ventilasi yang baik',
      ),
    ];
  }

  List<UnitInfo> _getUnits() {
    return [
      UnitInfo(
        symbol: 'Î¼g/mÂ³',
        name: 'Mikrogram per Meter Kubik',
        description: 'Mengukur konsentrasi partikel dalam udara. '
            '1 Î¼g/mÂ³ = 0.000001 gram partikel dalam 1 meter kubik udara.',
        example: 'PM2.5: 15 Î¼g/mÂ³ berarti ada 15 mikrogram partikel halus dalam 1 mÂ³ udara',
      ),
      UnitInfo(
        symbol: 'ppm',
        name: 'Parts Per Million',
        description: 'Mengukur jumlah molekul gas dalam 1 juta molekul udara. '
            'Menggambarkan konsentrasi gas yang sangat kecil.',
        example: 'COâ‚‚: 400 ppm berarti ada 400 molekul COâ‚‚ dalam 1 juta molekul udara',
      ),
      UnitInfo(
        symbol: 'Â°C',
        name: 'Derajat Celsius',
        description: 'Skala suhu yang digunakan secara internasional. '
            '0Â°C adalah titik beku air, 100Â°C adalah titik didih air.',
        example: 'Suhu ruangan ideal: 24Â°C',
      ),
      UnitInfo(
        symbol: '%',
        name: 'Persen',
        description: 'Mengukur kelembaban relatif udara. '
            '100% berarti udara jenuh dengan uap air.',
        example: 'Kelembaban ideal: 50%',
      ),
      UnitInfo(
        symbol: 'AQI',
        name: 'Air Quality Index',
        description: 'Indeks kualitas udara tanpa satuan. '
            'Menggambarkan kondisi kualitas udara secara keseluruhan.',
        example: 'AQI 75 = Kualitas udara sedang',
      ),
    ];
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/data/repositories/building_repository.dart:

// File: lib/data/repositories/building_repository.dart

import 'dart:convert';
import 'package:http/http.dart' as http;
import '../models/building.dart';
import '../../core/constants/app_constants.dart';
import '../../core/services/storage_service.dart';

class BuildingRepository {
  final StorageService _storage = StorageService();
  
  Future<String?> _getToken() async {
    return _storage.getString('auth_token');
  }
  
  Future<Map<String, String>> _getHeaders() async {
    final token = await _getToken();
    
    final headers = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };
    
    if (token != null) {
      headers['Authorization'] = 'Bearer $token';
    }
    
    return headers;
  }
  
  // Get all buildings
  Future<List<Building>> getBuildings() async {
    try {
      print('ðŸ“¡ Fetching buildings from: ${AppConstants.apiBaseUrl}/buildings');
      
      final headers = await _getHeaders();
      print('ðŸ”‘ Token available: ${headers.containsKey('Authorization')}');
      
      final response = await http.get(
        Uri.parse('${AppConstants.apiBaseUrl}/buildings'),
        headers: headers,
      );
      
      print('ðŸ“Š Response status: ${response.statusCode}');
      // print('ðŸ“„ Response body: ${response.body}');
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        print('âœ… API success: ${jsonResponse['success']}');
        
        if (jsonResponse['success'] == true) {
          final List<dynamic> data = jsonResponse['data'];
          final buildings = data.map((json) => Building.fromJson(json)).toList();
          
          print('ðŸŽ¯ Loaded ${buildings.length} buildings');
          return buildings;
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to fetch buildings');
        }
      } else if (response.statusCode == 401) {
        // Try without token (public access)
        print('âš ï¸ Token invalid, trying public access...');
        
        final publicResponse = await http.get(
          Uri.parse('${AppConstants.apiBaseUrl}/buildings'),
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
        );
        
        if (publicResponse.statusCode == 200) {
          final jsonResponse = jsonDecode(publicResponse.body);
          if (jsonResponse['success'] == true) {
            final List<dynamic> data = jsonResponse['data'];
            return data.map((json) => Building.fromJson(json)).toList();
          }
        }
        
        throw Exception('Unauthorized. Please login.');
      } else if (response.statusCode == 404) {
        throw Exception('Buildings endpoint not found (404). Check backend server.');
      } else {
        throw Exception('Failed to fetch buildings: ${response.statusCode}');
      }
    } catch (e) {
      print('âŒ Building repository error: $e');
      rethrow;
    }
  }
  
  // Get building by ID
  Future<Building> getBuildingById(String id) async {
    try {
      final headers = await _getHeaders();
      final response = await http.get(
        Uri.parse('${AppConstants.apiBaseUrl}/buildings/$id'),
        headers: headers,
      );
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        if (jsonResponse['success'] == true) {
          return Building.fromJson(jsonResponse['data']);
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to fetch building');
        }
      } else if (response.statusCode == 404) {
        throw Exception('Building not found (404)');
      } else {
        throw Exception('Failed to fetch building: ${response.statusCode}');
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // Create building
  Future<Building> createBuilding({
    required String name,
    String? code,
    String? description,
  }) async {
    try {
      final headers = await _getHeaders();
      final body = jsonEncode({
        'name': name,
        'code': code,
        'description': description,
      });
      
      print('ðŸ“¤ Creating building: $name');
      print('ðŸ“¤ Request body: $body');
      
      final response = await http.post(
        Uri.parse('${AppConstants.apiBaseUrl}/buildings'),
        headers: headers,
        body: body,
      );
      
      print('ðŸ“Š Create response: ${response.statusCode}');
      print('ðŸ“„ Response body: ${response.body}');
      
      if (response.statusCode == 201) {
        final jsonResponse = jsonDecode(response.body);
        if (jsonResponse['success'] == true) {
          return Building.fromJson(jsonResponse['data']);
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to create building');
        }
      } else {
        final error = jsonDecode(response.body);
        throw Exception(error['message'] ?? 'Failed to create building: ${response.statusCode}');
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // Update building
  Future<Building> updateBuilding({
    required String id,
    required String name,
    String? code,
    String? description,
  }) async {
    try {
      final headers = await _getHeaders();
      final body = jsonEncode({
        'name': name,
        'code': code,
        'description': description,
      });
      
      final response = await http.put(
        Uri.parse('${AppConstants.apiBaseUrl}/buildings/$id'),
        headers: headers,
        body: body,
      );
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        if (jsonResponse['success'] == true) {
          return Building.fromJson(jsonResponse['data']);
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to update building');
        }
      } else {
        final error = jsonDecode(response.body);
        throw Exception(error['message'] ?? 'Failed to update building: ${response.statusCode}');
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // Delete building
  Future<void> deleteBuilding(String id) async {
    try {
      final headers = await _getHeaders();
      final response = await http.delete(
        Uri.parse('${AppConstants.apiBaseUrl}/buildings/$id'),
        headers: headers,
      );
      
      print('ðŸ—‘ï¸ Delete building response: ${response.statusCode}');
      print('ðŸ“„ Delete response body: ${response.body}');
      
      if (response.statusCode != 200) {
        final error = jsonDecode(response.body);
        throw Exception(error['message'] ?? 'Failed to delete building');
      }
    } catch (e) {
      rethrow;
    }
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/data/repositories/history_repository.dar:

import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:unila_aqi/core/constants/app_constants.dart';
import 'package:unila_aqi/core/services/storage_service.dart';
import 'package:unila_aqi/data/models/sensor_data.dart';

class HistoryRepository {
  final StorageService _storage = StorageService();
  
  Future<String?> _getToken() async {
    return _storage.getString('auth_token');
  }
  
  Future<Map<String, String>> _getHeaders() async {
    final token = await _getToken();
    
    final headers = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };
    
    if (token != null) {
      headers['Authorization'] = 'Bearer $token';
    }
    
    return headers;
  }
  
  // Get history data untuk grafik
  Future<HistoryDataResponse> getHistoryData({
    required String roomId,
    required DateTime selectedDate,
    int interval = 30,
  }) async {
    try {
      final headers = await _getHeaders();
      
      // Format tanggal menjadi YYYY-MM-DD
      final formattedDate = '${selectedDate.year}-${selectedDate.month.toString().padLeft(2, '0')}-${selectedDate.day.toString().padLeft(2, '0')}';
      
      final response = await http.get(
        Uri.parse('${AppConstants.apiBaseUrl}/sensor-data/$roomId/history?date=$formattedDate&interval=$interval'),
        headers: headers,
      );
      
      print('ðŸ“Š History API Response: ${response.statusCode}');
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        
        if (jsonResponse['success'] == true) {
          final List<dynamic> data = jsonResponse['data'];
          final aggregated = jsonResponse['aggregated'] ?? false;
          
          // Konversi ke list SensorData
          final sensorData = data.map((json) => SensorData.fromJson(json)).toList();
          
          return HistoryDataResponse(
            success: true,
            data: sensorData,
            aggregated: aggregated,
            count: sensorData.length,
            startDate: jsonResponse['startDate'] != null 
                ? DateTime.parse(jsonResponse['startDate'])
                : selectedDate,
            endDate: jsonResponse['endDate'] != null
                ? DateTime.parse(jsonResponse['endDate'])
                : selectedDate.add(Duration(days: 1)),
          );
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to fetch history data');
        }
      } else {
        throw Exception('Failed to fetch history data: ${response.statusCode}');
      }
    } catch (e) {
      print('âŒ History Repository Error: $e');
      return HistoryDataResponse(
        success: false,
        data: [],
        error: e.toString(),
      );
    }
  }
  
  // Get available dates dengan data
  Future<List<DateTime>> getAvailableDates(String roomId) async {
    try {
      final headers = await _getHeaders();
      
      // Untuk sekarang, kita akan generate 7 hari terakhir
      // Di production, Anda mungkin ingin query database untuk tanggal yang punya data
      final now = DateTime.now();
      final dates = <DateTime>[];
      
      for (int i = 0; i < 7; i++) {
        dates.add(DateTime(now.year, now.month, now.day - i));
      }
      
      return dates;
    } catch (e) {
      print('Error getting available dates: $e');
      return [];
    }
  }
}

class HistoryDataResponse {
  final bool success;
  final List<SensorData> data;
  final bool aggregated;
  final int? count;
  final DateTime? startDate;
  final DateTime? endDate;
  final String? error;
  
  HistoryDataResponse({
    required this.success,
    required this.data,
    this.aggregated = false,
    this.count,
    this.startDate,
    this.endDate,
    this.error,
  });
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/data/repositories/iot_device_repository.dart

import 'dart:convert';
import 'package:http/http.dart' as http;
import '../models/iot_device.dart';
import '../../core/constants/app_constants.dart';
import '../../core/services/storage_service.dart';

class IoTDeviceRepository {
  final StorageService _storage = StorageService();
  
  Future<String?> _getToken() async {
    return _storage.getString('auth_token');
  }
  
  Future<Map<String, String>> _getHeaders() async {
    final token = await _getToken();
    
    final headers = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };
    
    if (token != null) {
      headers['Authorization'] = 'Bearer $token';
    }
    
    return headers;
  }
  
  // Get all IoT devices
  Future<List<IoTDevice>> getDevices() async {
    try {
      final headers = await _getHeaders();
      final response = await http.get(
        Uri.parse('${AppConstants.apiBaseUrl}/iot-devices'),
        headers: headers,
      );
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        if (jsonResponse['success'] == true) {
          final List<dynamic> data = jsonResponse['data'];
          return data.map((json) => IoTDevice.fromJson(json)).toList();
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to fetch devices');
        }
      } else {
        throw Exception('Failed to fetch devices: ${response.statusCode}');
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // Get device by ID
  Future<IoTDevice> getDeviceById(String id) async {
    try {
      final headers = await _getHeaders();
      final response = await http.get(
        Uri.parse('${AppConstants.apiBaseUrl}/iot-devices/$id'),
        headers: headers,
      );
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        if (jsonResponse['success'] == true) {
          return IoTDevice.fromJson(jsonResponse['data']);
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to fetch device');
        }
      } else {
        throw Exception('Failed to fetch device: ${response.statusCode}');
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // Create device - HAPUS buildingId parameter
  Future<IoTDevice> createDevice({
    required String name,
    String? description,
    required String apiEndpoint,
    bool isActive = true,
  }) async {
    try {
      final headers = await _getHeaders();
      final body = jsonEncode({
        'name': name,
        'description': description,
        'apiEndpoint': apiEndpoint,
        'isActive': isActive,
      });
      
      final response = await http.post(
        Uri.parse('${AppConstants.apiBaseUrl}/iot-devices'),
        headers: headers,
        body: body,
      );
      
      if (response.statusCode == 201) {
        final jsonResponse = jsonDecode(response.body);
        if (jsonResponse['success'] == true) {
          return IoTDevice.fromJson(jsonResponse['data']);
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to create device');
        }
      } else {
        final error = jsonDecode(response.body);
        throw Exception(error['message'] ?? 'Failed to create device');
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // Update device - HAPUS buildingId parameter
  Future<IoTDevice> updateDevice({
    required String id,
    required String name,
    String? description,
    required String apiEndpoint,
    bool isActive = true,
  }) async {
    try {
      final headers = await _getHeaders();
      final body = jsonEncode({
        'name': name,
        'description': description,
        'apiEndpoint': apiEndpoint,
        'isActive': isActive,
      });
      
      final response = await http.put(
        Uri.parse('${AppConstants.apiBaseUrl}/iot-devices/$id'),
        headers: headers,
        body: body,
      );
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        if (jsonResponse['success'] == true) {
          return IoTDevice.fromJson(jsonResponse['data']);
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to update device');
        }
      } else {
        final error = jsonDecode(response.body);
        throw Exception(error['message'] ?? 'Failed to update device');
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // Delete device
  Future<void> deleteDevice(String id) async {
    try {
      final headers = await _getHeaders();
      final response = await http.delete(
        Uri.parse('${AppConstants.apiBaseUrl}/iot-devices/$id'),
        headers: headers,
      );
      
      if (response.statusCode != 200) {
        final error = jsonDecode(response.body);
        throw Exception(error['message'] ?? 'Failed to delete device');
      }
    } catch (e) {
      rethrow;
    }
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/data/repositories/room_repository.dart:

import 'dart:convert';
import 'package:http/http.dart' as http;
import '../models/room.dart';
import '../../core/constants/app_constants.dart';
import '../../core/services/storage_service.dart';

class RoomRepository {
  final StorageService _storage = StorageService();
  
  Future<String?> _getToken() async {
    return _storage.getString('auth_token');
  }
  
  Future<Map<String, String>> _getHeaders() async {
    final token = await _getToken();
    
    final headers = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };
    
    if (token != null) {
      headers['Authorization'] = 'Bearer $token';
    }
    
    return headers;
  }
  
  // Get all rooms
  Future<List<Room>> getRooms() async {
  try {
    print('ðŸ“¡ Fetching rooms from: ${AppConstants.apiBaseUrl}/rooms');
    
    // Coba dengan token terlebih dahulu (untuk admin)
    final headers = await _getHeaders();
    
    print('ðŸ”‘ Using token: ${headers.containsKey('Authorization') ? 'YES' : 'NO'}');
    
    final response = await http.get(
      Uri.parse('${AppConstants.apiBaseUrl}/rooms'),
      headers: headers,
    );
    
    print('ðŸ“Š API Status: ${response.statusCode}');
    
    if (response.statusCode == 200) {
      final jsonResponse = jsonDecode(response.body);
      print('âœ… API Success: ${jsonResponse['success']}');
      
      if (jsonResponse['success'] == true) {
        final List<dynamic> data = jsonResponse['data'];
        final rooms = data.map((json) => Room.fromJson(json)).toList();
        
        print('ðŸŽ¯ Loaded ${rooms.length} rooms');
        return rooms;
      } else {
        throw Exception(jsonResponse['message'] ?? 'Failed to fetch rooms');
      }
    } else if (response.statusCode == 401) {
      print('âš ï¸ Token invalid or expired, trying without token...');
      
      // Coba tanpa token (untuk user mode)
      final publicResponse = await http.get(
        Uri.parse('${AppConstants.apiBaseUrl}/rooms'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      );
      
      if (publicResponse.statusCode == 200) {
        final jsonResponse = jsonDecode(publicResponse.body);
        if (jsonResponse['success'] == true) {
          final List<dynamic> data = jsonResponse['data'];
          final rooms = data.map((json) => Room.fromJson(json)).toList();
          
          print('ðŸŽ¯ Loaded ${rooms.length} rooms without token');
          return rooms;
        }
      }
      
      throw Exception('Access denied. Please login as admin or try user mode.');
    } else {
      print('âŒ API Error: ${response.statusCode} - ${response.body}');
      throw Exception('Failed to fetch rooms: ${response.statusCode}');
    }
  } catch (e) {
    print('âŒ Room Repository Error: $e');
    rethrow;
  }
}
  
  // Get room by ID
  Future<Room> getRoomById(String id) async {
    try {
      final headers = await _getHeaders();
      final response = await http.get(
        Uri.parse('${AppConstants.apiBaseUrl}/rooms/$id'),
        headers: headers,
      );
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        if (jsonResponse['success'] == true) {
          return Room.fromJson(jsonResponse['data']);
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to fetch room');
        }
      } else {
        throw Exception('Failed to fetch room: ${response.statusCode}');
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // Create room
  Future<Room> createRoom({
    required String name,
    required String buildingId,
    String dataSource = 'simulation',
    String? iotDeviceId,
    bool isActive = true,
  }) async {
    try {
      final headers = await _getHeaders();
      final body = jsonEncode({
        'name': name,
        'buildingId': buildingId,
        'dataSource': dataSource,
        'iotDeviceId': iotDeviceId,
        'isActive': isActive,
      });
      
      final response = await http.post(
        Uri.parse('${AppConstants.apiBaseUrl}/rooms'),
        headers: headers,
        body: body,
      );
      
      if (response.statusCode == 201) {
        final jsonResponse = jsonDecode(response.body);
        if (jsonResponse['success'] == true) {
          return Room.fromJson(jsonResponse['data']);
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to create room');
        }
      } else {
        final error = jsonDecode(response.body);
        throw Exception(error['message'] ?? 'Failed to create room');
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // Update room
  Future<Room> updateRoom({
    required String id,
    required String name,
    required String buildingId,
    String dataSource = 'simulation',
    String? iotDeviceId,
    bool isActive = true,
  }) async {
    try {
      final headers = await _getHeaders();
      final body = jsonEncode({
        'name': name,
        'buildingId': buildingId,
        'dataSource': dataSource,
        'iotDeviceId': iotDeviceId,
        'isActive': isActive,
      });
      
      final response = await http.put(
        Uri.parse('${AppConstants.apiBaseUrl}/rooms/$id'),
        headers: headers,
        body: body,
      );
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        if (jsonResponse['success'] == true) {
          return Room.fromJson(jsonResponse['data']);
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to update room');
        }
      } else {
        final error = jsonDecode(response.body);
        throw Exception(error['message'] ?? 'Failed to update room');
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // Delete room
  Future<void> deleteRoom(String id) async {
    try {
      final headers = await _getHeaders();
      final response = await http.delete(
        Uri.parse('${AppConstants.apiBaseUrl}/rooms/$id'),
        headers: headers,
      );
      
      if (response.statusCode != 200) {
        final error = jsonDecode(response.body);
        throw Exception(error['message'] ?? 'Failed to delete room');
      }
    } catch (e) {
      rethrow;
    }
  }
}


---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/info/aqi_info_screen.dart

import 'package:flutter/material.dart';
import '../../../data/repositories/aqi_info_repository.dart';
import '../../../data/models/aqi_info.dart';
import '../../../core/constants/colors.dart';

class AQIInfoScreen extends StatefulWidget {
  const AQIInfoScreen({super.key});

  @override
  State<AQIInfoScreen> createState() => _AQIInfoScreenState();
}

class _AQIInfoScreenState extends State<AQIInfoScreen> {
  final AQIInfoRepository _repository = AQIInfoRepository();
  late Future<AQIInfo> _aqiInfoFuture;

  @override
  void initState() {
    super.initState();
    _aqiInfoFuture = _repository.getAQIInfo();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Informasi AQI'),
        centerTitle: true,
        elevation: 0,
      ),
      body: FutureBuilder<AQIInfo>(
        future: _aqiInfoFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Text('Error: ${snapshot.error}'),
            );
          }

          final aqiInfo = snapshot.data!;

          return _buildContent(aqiInfo);
        },
      ),
    );
  }

  Widget _buildContent(AQIInfo aqiInfo) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          _buildHeader(aqiInfo),
          const SizedBox(height: 24),

          // Parameters
          _buildSectionTitle('Parameter yang Dimonitor'),
          const SizedBox(height: 12),
          ...aqiInfo.parameters.map(_buildParameterCard).toList(),
          const SizedBox(height: 24),

          // AQI Categories
          _buildSectionTitle('Kategori Indeks Kualitas Udara (AQI)'),
          const SizedBox(height: 12),
          ...aqiInfo.categories.map(_buildCategoryCard).toList(),
          const SizedBox(height: 24),

          // Units Information
          _buildSectionTitle('Penjelasan Satuan'),
          const SizedBox(height: 12),
          ...aqiInfo.units.map(_buildUnitCard).toList(),
          const SizedBox(height: 24),

          // Additional Information
          _buildSectionTitle('Tips Kesehatan'),
          _buildHealthTips(),
          const SizedBox(height: 32),

          // Footer
          _buildFooter(),
        ],
      ),
    );
  }

  Widget _buildHeader(AQIInfo aqiInfo) {
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            Text(
              aqiInfo.icon,
              style: const TextStyle(fontSize: 48),
            ),
            const SizedBox(height: 16),
            Text(
              aqiInfo.title,
              style: const TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.w700,
                color: AppColors.primary,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            Text(
              aqiInfo.description,
              style: const TextStyle(
                fontSize: 16,
                height: 1.5,
                color: AppColors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Text(
      title,
      style: const TextStyle(
        fontSize: 20,
        fontWeight: FontWeight.w700,
        color: AppColors.textPrimary,
      ),
    );
  }

  Widget _buildParameterCard(AQIParameter parameter) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Text(
                  parameter.icon,
                  style: const TextStyle(fontSize: 24),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        parameter.name,
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      Text(
                        '${parameter.abbreviation} (${parameter.unit})',
                        style: const TextStyle(
                          fontSize: 14,
                          color: AppColors.textSecondary,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Text(
              parameter.description,
              style: const TextStyle(
                fontSize: 14,
                height: 1.5,
              ),
            ),
            const SizedBox(height: 12),
            _buildInfoRow('ðŸ¥ Dampak Kesehatan:', parameter.impact),
            _buildInfoRow('ðŸ“Š Sumber Utama:', parameter.source),
            _buildInfoRow('âœ… Rentang Aman:', parameter.safeRange),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            label,
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w600,
              color: AppColors.textPrimary,
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(
                fontSize: 14,
                color: AppColors.textSecondary,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCategoryCard(AQICategory category) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: category.color, width: 2),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  width: 20,
                  height: 20,
                  decoration: BoxDecoration(
                    color: category.color,
                    shape: BoxShape.circle,
                  ),
                ),
                const SizedBox(width: 12),
                Text(
                  category.name,
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.w700,
                    color: category.color,
                  ),
                ),
                const Spacer(),
                Text(
                  '${category.min} - ${category.max}',
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Text(
              category.description,
              style: const TextStyle(
                fontSize: 14,
                height: 1.5,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 8),
            _buildInfoRow('ðŸ‘¥ Efek Kesehatan:', category.healthEffect),
            _buildInfoRow('ðŸ’¡ Rekomendasi:', category.recommendation),
          ],
        ),
      ),
    );
  }

  Widget _buildUnitCard(UnitInfo unit) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: AppColors.primary.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Text(
                    unit.symbol,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w700,
                      color: AppColors.primary,
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Text(
                  unit.name,
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Text(
              unit.description,
              style: const TextStyle(
                fontSize: 14,
                height: 1.5,
              ),
            ),
            const SizedBox(height: 8),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: AppColors.surface,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  const Icon(Icons.lightbulb_outline, size: 20),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Contoh: ${unit.example}',
                      style: const TextStyle(
                        fontSize: 14,
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildHealthTips() {
    return Card(
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            _buildTipItem(
              'ðŸŒ¬ï¸ Ventilasi yang Baik',
              'Pastikan ruangan memiliki sirkulasi udara yang cukup untuk mengurangi akumulasi COâ‚‚ dan polutan',
            ),
            const SizedBox(height: 12),
            _buildTipItem(
              'ðŸŒ± Tanaman Dalam Ruangan',
              'Beberapa tanaman seperti lidah mertua dan peace lily dapat membantu membersihkan udara',
            ),
            const SizedBox(height: 12),
            _buildTipItem(
              'ðŸ”„ Monitor Rutin',
              'Periksa kualitas udara secara teratur, terutama di ruangan dengan banyak aktivitas',
            ),
            const SizedBox(height: 12),
            _buildTipItem(
              'ðŸƒ Aktivitas Fisik',
              'Hindari aktivitas fisik berat saat kualitas udara sedang atau tidak sehat',
            ),
            const SizedBox(height: 12),
            _buildTipItem(
              'ðŸ©º Kelompok Sensitif',
              'Anak-anak, lansia, dan penderita asma lebih rentan terhadap efek polusi udara',
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTipItem(String title, String description) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          width: 40,
          height: 40,
          decoration: BoxDecoration(
            color: AppColors.primary.withOpacity(0.1),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              title.substring(0, 3),
              style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                style: const TextStyle(
                  fontSize: 15,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                description,
                style: const TextStyle(
                  fontSize: 13,
                  color: AppColors.textSecondary,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildFooter() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: AppColors.surface,
        borderRadius: BorderRadius.circular(12),
      ),
      
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/admin/building_managements.dart:

import 'package:flutter/material.dart';
import '../../../data/repositories/building_repository.dart';
import '../../../data/models/building.dart';
import '../../../core/utils/helpers.dart';
import '../../../core/constants/colors.dart';

class BuildingManagementScreen extends StatefulWidget {
  const BuildingManagementScreen({super.key});

  @override
  State<BuildingManagementScreen> createState() => _BuildingManagementScreenState();
}

class _BuildingManagementScreenState extends State<BuildingManagementScreen> {
  final BuildingRepository _buildingRepository = BuildingRepository();
  final TextEditingController _searchController = TextEditingController();
  
  List<Building> _buildings = [];
  List<Building> _filteredBuildings = [];
  bool _isLoading = false;
  bool _hasError = false;
  String _errorMessage = '';
  
  @override
  void initState() {
    super.initState();
    _loadBuildings();
  }
  
  Future<void> _loadBuildings() async {
    setState(() {
      _isLoading = true;
      _hasError = false;
    });
    
    try {
      final buildings = await _buildingRepository.getBuildings();
      setState(() {
        _buildings = buildings;
        _filteredBuildings = buildings;
      });
    } catch (e) {
      setState(() {
        _hasError = true;
        _errorMessage = e.toString();
      });
      Helpers.showSnackBar(context, 'Gagal memuat data gedung: $e', isError: true);
    } finally {
      setState(() => _isLoading = false);
    }
  }
  
  void _filterBuildings(String query) {
    if (query.isEmpty) {
      setState(() => _filteredBuildings = _buildings);
    } else {
      final filtered = _buildings.where((building) {
        final name = building.name.toLowerCase();
        final code = building.code?.toLowerCase() ?? '';
        final search = query.toLowerCase();
        return name.contains(search) || code.contains(search);
      }).toList();
      setState(() => _filteredBuildings = filtered);
    }
  }
  
  Future<void> _deleteBuilding(String buildingId) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Hapus Gedung'),
        content: const Text('Apakah Anda yakin ingin menghapus gedung ini?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Batal'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Hapus', style: TextStyle(color: AppColors.error)),
          ),
        ],
      ),
    );
    
    if (confirmed != true) return;
    
    try {
      await _buildingRepository.deleteBuilding(buildingId);
      await _loadBuildings();
      Helpers.showSnackBar(context, 'Gedung berhasil dihapus');
    } catch (e) {
      Helpers.showSnackBar(context, 'Gagal menghapus gedung: $e', isError: true);
    }
  }
  
  void _navigateToAddBuilding() {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => AddEditBuildingScreen(
          onBuildingSaved: _loadBuildings,
        ),
      ),
    );
  }
  
  void _navigateToEditBuilding(Building building) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => AddEditBuildingScreen(
          building: building,
          onBuildingSaved: _loadBuildings,
        ),
      ),
    );
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Kelola Gedung'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadBuildings,
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: Column(
        children: [
          // Search Bar
          Padding(
            padding: const EdgeInsets.all(16),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'ðŸ” Cari gedung...',
                filled: true,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide.none,
                ),
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          _searchController.clear();
                          _filterBuildings('');
                        },
                      )
                    : null,
              ),
              onChanged: _filterBuildings,
            ),
          ),
          
          // Add Button
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _navigateToAddBuilding,
                icon: const Icon(Icons.add),
                label: const Text('TAMBAH GEDUNG'),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
              ),
            ),
          ),
          
          const SizedBox(height: 16),
          
          // Loading State
          if (_isLoading)
            const Expanded(
              child: Center(
                child: CircularProgressIndicator(),
              ),
            )
          
          // Error State
          else if (_hasError)
            Expanded(
              child: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(
                      Icons.error_outline,
                      size: 64,
                      color: AppColors.error,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'Error: $_errorMessage',
                      textAlign: TextAlign.center,
                      style: const TextStyle(color: AppColors.error),
                    ),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: _loadBuildings,
                      child: const Text('Coba Lagi'),
                    ),
                  ],
                ),
              ),
            )
          
          // Empty State
          else if (_filteredBuildings.isEmpty)
            Expanded(
              child: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(
                      Icons.location_city_outlined,
                      size: 64,
                      color: Colors.grey,
                    ),
                    const SizedBox(height: 16),
                    const Text(
                      'Tidak ada gedung ditemukan',
                      style: TextStyle(
                        fontSize: 16,
                        color: Colors.grey,
                      ),
                    ),
                    const SizedBox(height: 8),
                    if (_searchController.text.isNotEmpty)
                      TextButton(
                        onPressed: () {
                          _searchController.clear();
                          _filterBuildings('');
                        },
                        child: const Text('Reset Pencarian'),
                      ),
                  ],
                ),
              ),
            )
          
          // Data State
          else
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.all(16),
                itemCount: _filteredBuildings.length,
                itemBuilder: (context, index) {
                  final building = _filteredBuildings[index];
                  return _buildBuildingCard(building);
                },
              ),
            ),
          
          // Footer
          Container(
            padding: const EdgeInsets.all(16),
            child: Text(
              'Total: ${_filteredBuildings.length} gedung',
              style: const TextStyle(
                fontSize: 14,
                color: Colors.grey,
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildBuildingCard(Building building) {
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        building.name,
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      if (building.code != null)
                        Padding(
                          padding: const EdgeInsets.only(top: 4),
                          child: Text(
                            'Kode: ${building.code}',
                            style: const TextStyle(
                              fontSize: 14,
                              color: Colors.grey,
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: AppColors.primary.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: Text(
                    '${building.roomCount} ruangan',
                    style: const TextStyle(
                      fontSize: 12,
                      color: AppColors.primary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ],
            ),
            
            if (building.description != null && building.description!.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 8),
                child: Text(
                  building.description!,
                  style: const TextStyle(
                    fontSize: 14,
                    color: Colors.grey,
                  ),
                ),
              ),
            
            Padding(
              padding: const EdgeInsets.only(top: 12),
              child: Row(
                children: [
                  const Icon(
                    Icons.calendar_today,
                    size: 14,
                    color: Colors.grey,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    'Dibuat: ${Helpers.formatDateTime(building.createdAt)}',
                    style: const TextStyle(
                      fontSize: 12,
                      color: Colors.grey,
                    ),
                  ),
                ],
              ),
            ),
            
            const SizedBox(height: 16),
            
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _navigateToEditBuilding(building),
                    icon: const Icon(Icons.edit, size: 16),
                    label: const Text('Edit'),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: AppColors.primary,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _deleteBuilding(building.id),
                    icon: const Icon(Icons.delete, size: 16),
                    label: const Text('Hapus'),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: AppColors.error,
                      side: const BorderSide(color: AppColors.error),
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class AddEditBuildingScreen extends StatefulWidget {
  final Building? building;
  final VoidCallback onBuildingSaved;
  
  const AddEditBuildingScreen({
    super.key,
    this.building,
    required this.onBuildingSaved,
  });
  
  bool get isEditing => building != null;
  
  @override
  State<AddEditBuildingScreen> createState() => _AddEditBuildingScreenState();
}

class _AddEditBuildingScreenState extends State<AddEditBuildingScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _codeController = TextEditingController();
  final _descriptionController = TextEditingController();
  final BuildingRepository _buildingRepository = BuildingRepository();
  
  bool _isLoading = false;
  
  @override
  void initState() {
    super.initState();
    
    // Prefill fields if editing
    if (widget.isEditing) {
      final building = widget.building!;
      _nameController.text = building.name;
      _codeController.text = building.code ?? '';
      _descriptionController.text = building.description ?? '';
    }
  }
  
  @override
  void dispose() {
    _nameController.dispose();
    _codeController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }
  
  Future<void> _saveBuilding() async {
    if (!_formKey.currentState!.validate()) return;
    
    setState(() => _isLoading = true);
    
    try {
      if (widget.isEditing) {
        await _buildingRepository.updateBuilding(
          id: widget.building!.id,
          name: _nameController.text.trim(),
          code: _codeController.text.trim().isEmpty ? null : _codeController.text.trim(),
          description: _descriptionController.text.trim().isEmpty ? null : _descriptionController.text.trim(),
        );
        Helpers.showSnackBar(context, 'Gedung berhasil diperbarui');
      } else {
        await _buildingRepository.createBuilding(
          name: _nameController.text.trim(),
          code: _codeController.text.trim().isEmpty ? null : _codeController.text.trim(),
          description: _descriptionController.text.trim().isEmpty ? null : _descriptionController.text.trim(),
        );
        Helpers.showSnackBar(context, 'Gedung berhasil ditambahkan');
      }
      
      widget.onBuildingSaved();
      
      if (mounted) {
        Navigator.pop(context);
      }
    } catch (e) {
      Helpers.showSnackBar(context, 'Gagal menyimpan gedung: $e', isError: true);
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.isEditing ? 'Edit Gedung' : 'Tambah Gedung'),
        actions: [
          if (_isLoading)
            const Padding(
              padding: EdgeInsets.all(16),
              child: SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
            ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Nama Gedung*',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(
                  hintText: 'Contoh: Gedung H, Gedung MIPA',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Nama gedung wajib diisi';
                  }
                  return null;
                },
              ),
              
              const SizedBox(height: 16),
              
              const Text(
                'Kode Gedung',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              TextFormField(
                controller: _codeController,
                decoration: const InputDecoration(
                  hintText: 'Contoh: H, M, A (opsional)',
                  border: OutlineInputBorder(),
                ),
              ),
              
              const SizedBox(height: 16),
              
              const Text(
                'Deskripsi',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              TextFormField(
                controller: _descriptionController,
                decoration: const InputDecoration(
                  hintText: 'Deskripsi gedung (opsional)',
                  border: OutlineInputBorder(),
                ),
                maxLines: 3,
              ),
              
              const SizedBox(height: 32),
              
              SizedBox(
                width: double.infinity,
                height: 50,
                child: ElevatedButton(
                  onPressed: _isLoading ? null : _saveBuilding,
                  child: Text(
                    widget.isEditing ? 'SIMPAN PERUBAHAN' : 'SIMPAN GEDUNG',
                    style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                  ),
                ),
              ),
              
              const SizedBox(height: 16),
              
              if (widget.isEditing)
                Text(
                  '*Wajib diisi',
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey[600],
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/admin/iot_management.dart:

import 'package:flutter/material.dart';
import '../../../data/repositories/iot_device_repository.dart';
import '../../../data/models/iot_device.dart';
import '../../../core/utils/helpers.dart';
import '../../../core/constants/colors.dart';

class IoTManagementScreen extends StatefulWidget {
  const IoTManagementScreen({super.key});

  @override
  State<IoTManagementScreen> createState() => _IoTManagementScreenState();
}

class _IoTManagementScreenState extends State<IoTManagementScreen> {
  final IoTDeviceRepository _deviceRepository = IoTDeviceRepository();
  final TextEditingController _searchController = TextEditingController();
  
  List<IoTDevice> _devices = [];
  List<IoTDevice> _filteredDevices = [];
  bool _isLoading = false;
  bool _hasError = false;
  String _errorMessage = '';
  
  @override
  void initState() {
    super.initState();
    _loadData();
  }
  
  Future<void> _loadData() async {
    setState(() {
      _isLoading = true;
      _hasError = false;
    });
    
    try {
      final devices = await _deviceRepository.getDevices();
      
      setState(() {
        _devices = devices;
        _filteredDevices = devices;
      });
    } catch (e) {
      setState(() {
        _hasError = true;
        _errorMessage = e.toString();
      });
      Helpers.showSnackBar(context, 'Gagal memuat data device: $e', isError: true);
    } finally {
      setState(() => _isLoading = false);
    }
  }
  
  void _filterDevices(String query) {
    if (query.isEmpty) {
      setState(() => _filteredDevices = _devices);
    } else {
      final filtered = _devices.where((device) {
        final name = device.name.toLowerCase();
        final description = device.description?.toLowerCase() ?? '';
        final search = query.toLowerCase();
        return name.contains(search) || 
               description.contains(search);
      }).toList();
      setState(() => _filteredDevices = filtered);
    }
  }
  
  Future<void> _deleteDevice(String deviceId) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Hapus Device IoT'),
        content: const Text('Apakah Anda yakin ingin menghapus device ini?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Batal'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Hapus', style: TextStyle(color: AppColors.error)),
          ),
        ],
      ),
    );
    
    if (confirmed != true) return;
    
    try {
      await _deviceRepository.deleteDevice(deviceId);
      await _loadData();
      Helpers.showSnackBar(context, 'Device berhasil dihapus');
    } catch (e) {
      Helpers.showSnackBar(context, 'Gagal menghapus device: $e', isError: true);
    }
  }
  
  void _navigateToAddDevice() {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => AddEditIoTDeviceScreen(
          onDeviceSaved: _loadData,
        ),
      ),
    );
  }
  
  void _navigateToEditDevice(IoTDevice device) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => AddEditIoTDeviceScreen(
          device: device,
          onDeviceSaved: _loadData,
        ),
      ),
    );
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Kelola Device IoT'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadData,
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: Column(
        children: [
          // Search Bar
          Padding(
            padding: const EdgeInsets.all(16),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'ðŸ” Cari device...',
                filled: true,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide.none,
                ),
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          _searchController.clear();
                          _filterDevices('');
                        },
                      )
                    : null,
              ),
              onChanged: _filterDevices,
            ),
          ),
          
          // Add Button
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _navigateToAddDevice,
                icon: const Icon(Icons.add),
                label: const Text('TAMBAH DEVICE'),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
              ),
            ),
          ),
          
          const SizedBox(height: 16),
          
          // Loading State
          if (_isLoading)
            const Expanded(
              child: Center(
                child: CircularProgressIndicator(),
              ),
            )
          
          // Error State
          else if (_hasError)
            Expanded(
              child: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(
                      Icons.error_outline,
                      size: 64,
                      color: AppColors.error,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'Error: $_errorMessage',
                      textAlign: TextAlign.center,
                      style: const TextStyle(color: AppColors.error),
                    ),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: _loadData,
                      child: const Text('Coba Lagi'),
                    ),
                  ],
                ),
              ),
            )
          
          // Empty State
          else if (_filteredDevices.isEmpty)
            Expanded(
              child: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(
                      Icons.sensors_off,
                      size: 64,
                      color: Colors.grey,
                    ),
                    const SizedBox(height: 16),
                    const Text(
                      'Tidak ada device ditemukan',
                      style: TextStyle(
                        fontSize: 16,
                        color: Colors.grey,
                      ),
                    ),
                    const SizedBox(height: 8),
                    if (_searchController.text.isNotEmpty)
                      TextButton(
                        onPressed: () {
                          _searchController.clear();
                          _filterDevices('');
                        },
                        child: const Text('Reset Pencarian'),
                      ),
                  ],
                ),
              ),
            )
          
          // Data State
          else
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.all(16),
                itemCount: _filteredDevices.length,
                itemBuilder: (context, index) {
                  final device = _filteredDevices[index];
                  return _buildDeviceCard(device);
                },
              ),
            ),
          
          // Footer
          Container(
            padding: const EdgeInsets.all(16),
            child: Text(
              'Total: ${_filteredDevices.length} device',
              style: const TextStyle(
                fontSize: 14,
                color: Colors.grey,
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildDeviceCard(IoTDevice device) {
    // final timeAgo = device.lastUpdate != null 
        // ? Helpers.formatTimeAgo(device.lastUpdate!)
        // : 'Belum pernah update';
    
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        device.name,
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: device.statusColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(20),
                    border: Border.all(color: device.statusColor),
                  ),
                  child: Text(
                    device.displayStatus,
                    style: TextStyle(
                      fontSize: 12,
                      color: device.statusColor,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ],
            ),
            
            if (device.description != null && device.description!.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 8),
                child: Text(
                  device.description!,
                  style: const TextStyle(
                    fontSize: 14,
                    color: Colors.grey,
                  ),
                ),
              ),
            
            Padding(
              padding: const EdgeInsets.only(top: 8),
              child: Text(
                'Endpoint: ${device.apiEndpoint}',
                style: const TextStyle(
                  fontSize: 12,
                  color: Colors.blue,
                  fontFamily: 'monospace',
                ),
                overflow: TextOverflow.ellipsis,
              ),
            ),
            
            Padding(
              padding: const EdgeInsets.only(top: 12),
              child: Row(
                children: [
                  Icon(
                    Icons.circle,
                    size: 10,
                    color: device.isActive ? Colors.green : Colors.grey,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    device.isActive ? 'â— Aktif' : 'â—‹ Tidak Aktif',
                    style: TextStyle(
                      fontSize: 12,
                      color: device.isActive ? Colors.green : Colors.grey,
                    ),
                  ),
                  const SizedBox(width: 16),
                  const Icon(
                    Icons.update,
                    size: 14,
                    color: Colors.grey,
                  ),
                  const SizedBox(width: 4),
                  // Text(
                  //   'Update: $timeAgo',
                  //   style: const TextStyle(
                  //     fontSize: 12,
                  //     color: Colors.grey,
                  //   ),
                  // ),
                ],
              ),
            ),
            
            const SizedBox(height: 16),
            
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _navigateToEditDevice(device),
                    icon: const Icon(Icons.edit, size: 16),
                    label: const Text('Edit'),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: AppColors.primary,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _deleteDevice(device.id),
                    icon: const Icon(Icons.delete, size: 16),
                    label: const Text('Hapus'),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: AppColors.error,
                      side: const BorderSide(color: AppColors.error),
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class AddEditIoTDeviceScreen extends StatefulWidget {
  final IoTDevice? device;
  final VoidCallback onDeviceSaved;
  
  const AddEditIoTDeviceScreen({
    super.key,
    this.device,
    required this.onDeviceSaved,
  });
  
  bool get isEditing => device != null;
  
  @override
  State<AddEditIoTDeviceScreen> createState() => _AddEditIoTDeviceScreenState();
}

class _AddEditIoTDeviceScreenState extends State<AddEditIoTDeviceScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _endpointController = TextEditingController();
  final IoTDeviceRepository _deviceRepository = IoTDeviceRepository();
  
  bool _isActive = true;
  bool _isLoading = false;
  
  @override
  void initState() {
    super.initState();
    
    // Prefill fields if editing
    if (widget.isEditing) {
      final device = widget.device!;
      _nameController.text = device.name;
      _descriptionController.text = device.description ?? '';
      _endpointController.text = device.apiEndpoint;
      _isActive = device.isActive;
    }
  }
  
  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    _endpointController.dispose();
    super.dispose();
  }
  
  Future<void> _saveDevice() async {
    if (!_formKey.currentState!.validate()) return;
    
    setState(() => _isLoading = true);
    
    try {
      if (widget.isEditing) {
        await _deviceRepository.updateDevice(
          id: widget.device!.id,
          name: _nameController.text.trim(),
          description: _descriptionController.text.trim().isEmpty ? null : _descriptionController.text.trim(),
          apiEndpoint: _endpointController.text.trim(),
          isActive: _isActive,
        );
        Helpers.showSnackBar(context, 'Device berhasil diperbarui');
      } else {
        await _deviceRepository.createDevice(
          name: _nameController.text.trim(),
          description: _descriptionController.text.trim().isEmpty ? null : _descriptionController.text.trim(),
          apiEndpoint: _endpointController.text.trim(),
          isActive: _isActive,
        );
        Helpers.showSnackBar(context, 'Device berhasil ditambahkan');
      }
      
      widget.onDeviceSaved();
      
      if (mounted) {
        Navigator.pop(context);
      }
    } catch (e) {
      Helpers.showSnackBar(context, 'Gagal menyimpan device: $e', isError: true);
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.isEditing ? 'Edit Device IoT' : 'Tambah Device IoT'),
        actions: [
          if (_isLoading)
            const Padding(
              padding: EdgeInsets.all(16),
              child: SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
            ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Nama Device*',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(
                  hintText: 'Contoh: Device 1 - Gedung H',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Nama device wajib diisi';
                  }
                  return null;
                },
              ),
              
              const SizedBox(height: 16),
              
              const Text(
                'Deskripsi',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              TextFormField(
                controller: _descriptionController,
                decoration: const InputDecoration(
                  hintText: 'Deskripsi device (opsional)',
                  border: OutlineInputBorder(),
                ),
                maxLines: 2,
              ),
              
              const SizedBox(height: 16),
              
              const Text(
                'Endpoint API*',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              TextFormField(
                controller: _endpointController,
                decoration: const InputDecoration(
                  hintText: 'https://example.com/api/sensor-data',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Endpoint API wajib diisi';
                  }
                  // Basic URL validation
                  try {
                    Uri.parse(value);
                  } catch (e) {
                    return 'Format URL tidak valid';
                  }
                  return null;
                },
              ),
              
              const SizedBox(height: 16),
              
              // Status
              Row(
                children: [
                  const Text(
                    'Status: ',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(width: 16),
                  ChoiceChip(
                    label: const Text('Aktif'),
                    selected: _isActive,
                    onSelected: (selected) {
                      setState(() => _isActive = true);
                    },
                  ),
                  const SizedBox(width: 8),
                  ChoiceChip(
                    label: const Text('Tidak Aktif'),
                    selected: !_isActive,
                    onSelected: (selected) {
                      setState(() => _isActive = false);
                    },
                  ),
                ],
              ),
              
              const SizedBox(height: 32),
              
              SizedBox(
                width: double.infinity,
                height: 50,
                child: ElevatedButton(
                  onPressed: _isLoading ? null : _saveDevice,
                  child: Text(
                    widget.isEditing ? 'SIMPAN PERUBAHAN' : 'SIMPAN DEVICE',
                    style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/admin/profile_management.dart:



---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/admin/room_management.dart:

import 'package:flutter/material.dart';
import '../../../data/repositories/room_repository.dart';
import '../../../data/repositories/building_repository.dart';
import '../../../data/models/room.dart';
import '../../../data/models/building.dart';
import '../../../core/utils/helpers.dart';
import '../../../core/constants/colors.dart';
import '../../../data/repositories/iot_device_repository.dart';
import '../../../data/models/iot_device.dart';

class RoomManagementScreen extends StatefulWidget {
  const RoomManagementScreen({super.key});

  @override
  State<RoomManagementScreen> createState() => _RoomManagementScreenState();
}

class _RoomManagementScreenState extends State<RoomManagementScreen> {
  final RoomRepository _roomRepository = RoomRepository();
  final BuildingRepository _buildingRepository = BuildingRepository();
  final TextEditingController _searchController = TextEditingController();
  
  List<Room> _rooms = [];
  List<Room> _filteredRooms = [];
  List<Building> _buildings = [];
  String _selectedBuildingFilter = 'Semua Gedung';
  bool _isLoading = false;
  bool _hasError = false;
  String _errorMessage = '';
  
  @override
  void initState() {
    super.initState();
    _loadData();
  }
  
  Future<void> _loadData() async {
  setState(() {
    _isLoading = true;
    _hasError = false;
  });
  
  try {
    final List<Object> results = await Future.wait([
      _roomRepository.getRooms(),
      _buildingRepository.getBuildings(),
    ]);
    
    // Cast hasil ke tipe yang sesuai
    final List<Room> rooms = results[0] as List<Room>;
    final List<Building> buildings = results[1] as List<Building>;
    
    setState(() {
      _rooms = rooms;
      _filteredRooms = rooms;
      _buildings = buildings;
    });
  } catch (e) {
    setState(() {
      _hasError = true;
      _errorMessage = e.toString();
    });
    Helpers.showSnackBar(context, 'Gagal memuat data ruangan: $e', isError: true);
  } finally {
    setState(() => _isLoading = false);
  }
}
  
  void _filterRooms() {
    List<Room> filtered = _rooms;
    
    // Filter by building
    if (_selectedBuildingFilter != 'Semua Gedung') {
      filtered = filtered.where((room) => 
        room.buildingName == _selectedBuildingFilter
      ).toList();
    }
    
    // Filter by search query
    if (_searchController.text.isNotEmpty) {
      final query = _searchController.text.toLowerCase();
      filtered = filtered.where((room) =>
        room.name.toLowerCase().contains(query) ||
        room.buildingName.toLowerCase().contains(query)
      ).toList();
    }
    
    setState(() => _filteredRooms = filtered);
  }
  
  Future<void> _deleteRoom(String roomId) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Hapus Ruangan'),
        content: const Text('Apakah Anda yakin ingin menghapus ruangan ini?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Batal'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Hapus', style: TextStyle(color: AppColors.error)),
          ),
        ],
      ),
    );
    
    if (confirmed != true) return;
    
    try {
      await _roomRepository.deleteRoom(roomId);
      await _loadData();
      Helpers.showSnackBar(context, 'Ruangan berhasil dihapus');
    } catch (e) {
      Helpers.showSnackBar(context, 'Gagal menghapus ruangan: $e', isError: true);
    }
  }

  
  
  void _navigateToAddRoom() {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => AddEditRoomScreen(
          buildings: _buildings,
          onRoomSaved: _loadData,
        ),
      ),
    );
  }
  
  void _navigateToEditRoom(Room room) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => AddEditRoomScreen(
          room: room,
          buildings: _buildings,
          onRoomSaved: _loadData,
        ),
      ),
    );
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Kelola Ruangan'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadData,
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: Column(
        children: [
          // Search and Filter
          Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: [
                TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: 'ðŸ” Cari ruangan...',
                    filled: true,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide.none,
                    ),
                    suffixIcon: _searchController.text.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear),
                            onPressed: () {
                              _searchController.clear();
                              _filterRooms();
                            },
                          )
                        : null,
                  ),
                  onChanged: (value) => _filterRooms(),
                ),
                const SizedBox(height: 12),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: AppColors.border),
                  ),
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      value: _selectedBuildingFilter,
                      isExpanded: true,
                      icon: const Icon(Icons.arrow_drop_down),
                      onChanged: (value) {
                        setState(() {
                          _selectedBuildingFilter = value!;
                          _filterRooms();
                        });
                      },
                      items: [
                        'Semua Gedung',
                        ..._buildings.map((b) => b.name).toSet(),
                      ].map((building) {
                        return DropdownMenuItem(
                          value: building,
                          child: Text(building),
                        );
                      }).toList(),
                    ),
                  ),
                ),
              ],
            ),
          ),
          
          // Add Button
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _navigateToAddRoom,
                icon: const Icon(Icons.add),
                label: const Text('TAMBAH RUANGAN'),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
              ),
            ),
          ),
          
          const SizedBox(height: 16),
          
          // Loading State
          if (_isLoading)
            const Expanded(
              child: Center(
                child: CircularProgressIndicator(),
              ),
            )
          
          // Error State
          else if (_hasError)
            Expanded(
              child: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(
                      Icons.error_outline,
                      size: 64,
                      color: AppColors.error,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'Error: $_errorMessage',
                      textAlign: TextAlign.center,
                      style: const TextStyle(color: AppColors.error),
                    ),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: _loadData,
                      child: const Text('Coba Lagi'),
                    ),
                  ],
                ),
              ),
            )
          
          // Empty State
          else if (_filteredRooms.isEmpty)
            Expanded(
              child: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(
                      Icons.meeting_room_outlined,
                      size: 64,
                      color: Colors.grey,
                    ),
                    const SizedBox(height: 16),
                    const Text(
                      'Tidak ada ruangan ditemukan',
                      style: TextStyle(
                        fontSize: 16,
                        color: Colors.grey,
                      ),
                    ),
                    const SizedBox(height: 8),
                    if (_searchController.text.isNotEmpty || _selectedBuildingFilter != 'Semua Gedung')
                      TextButton(
                        onPressed: () {
                          _searchController.clear();
                          _selectedBuildingFilter = 'Semua Gedung';
                          _filterRooms();
                        },
                        child: const Text('Reset Filter'),
                      ),
                  ],
                ),
              ),
            )
          
          // Data State
          else
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.all(16),
                itemCount: _filteredRooms.length,
                itemBuilder: (context, index) {
                  final room = _filteredRooms[index];
                  return _buildRoomCard(room);
                },
              ),
            ),
          
          // Footer
          Container(
            padding: const EdgeInsets.all(16),
            child: Text(
              'Total: ${_filteredRooms.length} ruangan',
              style: const TextStyle(
                fontSize: 14,
                color: Colors.grey,
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildRoomCard(Room room) {
    final aqiColor = Helpers.getAQIColor(room.currentAQI);
    // final timeAgo = Helpers.formatTimeAgo(room.currentData.updatedAt);
    
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '${room.name} - ${room.buildingName}',
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Container(
                            width: 8,
                            height: 8,
                            decoration: BoxDecoration(
                              color: room.isActive ? Colors.green : Colors.grey,
                              shape: BoxShape.circle,
                            ),
                          ),
                          const SizedBox(width: 6),
                          Text(
                            room.isActive ? 'â— Aktif' : 'â—‹ Tidak Aktif',
                            style: TextStyle(
                              color: room.isActive ? Colors.green : Colors.grey,
                              fontSize: 12,
                            ),
                          ),
                          const SizedBox(width: 12),
                          Text(
                            'Sumber: ${room.dataSource == 'iot' ? 'Device IoT' : 'Simulasi'}',
                            style: const TextStyle(
                              fontSize: 12,
                              color: Colors.grey,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: aqiColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(20),
                    border: Border.all(color: aqiColor),
                  ),
                  child: Text(
                    'AQI: ${room.currentAQI}',
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w600,
                      color: aqiColor,
                    ),
                  ),
                ),
              ],
            ),
            
            const SizedBox(height: 12),
            
            // Last Update
            // Text(
            //   'Update: $timeAgo',
            //   style: const TextStyle(
            //     fontSize: 12,
            //     color: Colors.grey,
            //   ),
            // ),
            
            const SizedBox(height: 16),
            
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _navigateToEditRoom(room),
                    icon: const Icon(Icons.edit, size: 16),
                    label: const Text('Edit'),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: AppColors.primary,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _deleteRoom(room.id),
                    icon: const Icon(Icons.delete, size: 16),
                    label: const Text('Hapus'),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: AppColors.error,
                      side: const BorderSide(color: AppColors.error),
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class AddEditRoomScreen extends StatefulWidget {
  final Room? room;
  final List<Building> buildings;
  final VoidCallback onRoomSaved;
  
  const AddEditRoomScreen({
    super.key,
    this.room,
    required this.buildings,
    required this.onRoomSaved,
  });
  
  bool get isEditing => room != null;
  
  @override
  State<AddEditRoomScreen> createState() => _AddEditRoomScreenState();
}


class _AddEditRoomScreenState extends State<AddEditRoomScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final RoomRepository _roomRepository = RoomRepository();
  final IoTDeviceRepository _iotDeviceRepository = IoTDeviceRepository();
  
  String? _selectedBuildingId;
  String _selectedDataSource = 'simulation';
  String? _selectedIotDeviceId;
  bool _isActive = true;
  bool _isLoading = false;
  List<IoTDevice> _iotDevices = [];
  
  @override
  void initState() {
    super.initState();
    
    // Prefill fields if editing
    if (widget.isEditing) {
      final room = widget.room!;
      _nameController.text = room.name;
      _selectedBuildingId = room.buildingId;
      _selectedDataSource = room.dataSource;
      _selectedIotDeviceId = room.iotDeviceId;
      _isActive = room.isActive;
    } else if (widget.buildings.isNotEmpty) {
      // Default to first building
      _selectedBuildingId = widget.buildings.first.id;
    }
    
    // Load IoT devices
    _loadIoTDevices();
  }
  
  Future<void> _loadIoTDevices() async {
    try {
      final devices = await _iotDeviceRepository.getDevices();
      setState(() => _iotDevices = devices);
    } catch (e) {
      print('Error loading IoT devices: $e');
    }
  }
  
  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }
  
  Future<void> _saveRoom() async {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedBuildingId == null) {
      Helpers.showSnackBar(context, 'Pilih gedung terlebih dahulu', isError: true);
      return;
    }
    
    // Validasi khusus untuk IoT data source
    if (_selectedDataSource == 'iot' && _selectedIotDeviceId == null) {
      Helpers.showSnackBar(context, 'Pilih device IoT terlebih dahulu', isError: true);
      return;
    }
    
    setState(() => _isLoading = true);
    
    try {
      if (widget.isEditing) {
        await _roomRepository.updateRoom(
          id: widget.room!.id,
          name: _nameController.text.trim(),
          buildingId: _selectedBuildingId!,
          dataSource: _selectedDataSource,
          iotDeviceId: _selectedDataSource == 'iot' ? _selectedIotDeviceId : null,
          isActive: _isActive,
        );
        Helpers.showSnackBar(context, 'Ruangan berhasil diperbarui');
      } else {
        await _roomRepository.createRoom(
          name: _nameController.text.trim(),
          buildingId: _selectedBuildingId!,
          dataSource: _selectedDataSource,
          iotDeviceId: _selectedDataSource == 'iot' ? _selectedIotDeviceId : null,
          isActive: _isActive,
        );
        Helpers.showSnackBar(context, 'Ruangan berhasil ditambahkan');
      }
      
      widget.onRoomSaved();
      
      if (mounted) {
        Navigator.pop(context);
      }
    } catch (e) {
      Helpers.showSnackBar(context, 'Gagal menyimpan ruangan: $e', isError: true);
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.isEditing ? 'Edit Ruangan' : 'Tambah Ruangan'),
        actions: [
          if (_isLoading)
            const Padding(
              padding: EdgeInsets.all(16),
              child: SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
            ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Nama Ruangan*',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(
                  hintText: 'Contoh: H17, Lab Komputer, Ruang Baca',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Nama ruangan wajib diisi';
                  }
                  return null;
                },
              ),
              
              const SizedBox(height: 16),
              
              const Text(
                'Gedung*',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 12),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.grey.shade300),
                ),
                child: DropdownButtonHideUnderline(
                  child: DropdownButton<String>(
                    value: _selectedBuildingId,
                    isExpanded: true,
                    icon: const Icon(Icons.arrow_drop_down),
                    hint: const Text('Pilih Gedung'),
                    onChanged: (value) {
                      setState(() => _selectedBuildingId = value);
                    },
                    items: widget.buildings.map((building) {
                      return DropdownMenuItem(
                        value: building.id,
                        child: Text(building.displayName),
                      );
                    }).toList(),
                  ),
                ),
              ),
              
              const SizedBox(height: 16),
              
              const Text(
                'Sumber Data',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              Column(
                children: [
                  // Simulation Option
                  ListTile(
                    contentPadding: EdgeInsets.zero,
                    leading: Radio(
                      value: 'simulation',
                      groupValue: _selectedDataSource,
                      onChanged: (value) {
                        setState(() => _selectedDataSource = value!);
                      },
                    ),
                    title: const Text('Simulasi'),
                    subtitle: const Text('Data acak setiap 1 menit'),
                    dense: true,
                  ),
                  
                  // IoT Option
                  ListTile(
                    contentPadding: EdgeInsets.zero,
                    leading: Radio(
                      value: 'iot',
                      groupValue: _selectedDataSource,
                      onChanged: (value) {
                        setState(() => _selectedDataSource = value!);
                      },
                    ),
                    title: const Text('Device IoT'),
                    subtitle: const Text('Data dari sensor fisik'),
                    dense: true,
                  ),
                  
                  // IoT Device Selection (only show if IoT is selected)
                  if (_selectedDataSource == 'iot')
                    Padding(
                      padding: const EdgeInsets.only(left: 40, top: 8),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text(
                            'Pilih Device IoT:',
                            style: TextStyle(
                              fontSize: 14,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          const SizedBox(height: 8),
                          Container(
                            padding: const EdgeInsets.symmetric(horizontal: 12),
                            decoration: BoxDecoration(
                              color: Colors.white,
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(color: Colors.grey.shade300),
                            ),
                            child: DropdownButtonHideUnderline(
                              child: DropdownButton<String>(
                                value: _selectedIotDeviceId,
                                isExpanded: true,
                                icon: const Icon(Icons.arrow_drop_down),
                                hint: const Text('Pilih Device IoT'),
                                onChanged: (value) {
                                  setState(() => _selectedIotDeviceId = value);
                                },
                                items: _iotDevices.map((device) {
                                  return DropdownMenuItem(
                                    value: device.id,
                                    child: Text(device.name),
                                  );
                                }).toList(),
                              ),
                            ),
                          ),
                          if (_selectedDataSource == 'iot' && _selectedIotDeviceId == null)
                            const Padding(
                              padding: EdgeInsets.only(top: 4),
                              child: Text(
                                'Device IoT wajib dipilih untuk sumber data IoT',
                                style: TextStyle(
                                  fontSize: 12,
                                  color: Colors.red,
                                ),
                              ),
                            ),
                        ],
                      ),
                    ),
                ],
              ),
              
              const SizedBox(height: 16),
              
              // Status
              Row(
                children: [
                  const Text(
                    'Status: ',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(width: 16),
                  ChoiceChip(
                    label: const Text('Aktif'),
                    selected: _isActive,
                    onSelected: (selected) {
                      setState(() => _isActive = true);
                    },
                  ),
                  const SizedBox(width: 8),
                  ChoiceChip(
                    label: const Text('Tidak Aktif'),
                    selected: !_isActive,
                    onSelected: (selected) {
                      setState(() => _isActive = false);
                    },
                  ),
                ],
              ),
              
              const SizedBox(height: 32),
              
              SizedBox(
                width: double.infinity,
                height: 50,
                child: ElevatedButton(
                  onPressed: _isLoading ? null : _saveRoom,
                  child: Text(
                    widget.isEditing ? 'SIMPAN PERUBAHAN' : 'SIMPAN RUANGAN',
                    style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/auth/admin_login_screen.dart:

import 'package:flutter/material.dart';
import '../../../core/constants/colors.dart';
import '../../../core/utils/helpers.dart';
import '../../../core/utils/validators.dart';
import '../../../presentation/providers/auth_provider.dart';
import 'package:provider/provider.dart';
import 'forgot_password_screen.dart';

class AdminLoginScreen extends StatefulWidget {
  const AdminLoginScreen({super.key});

  @override
  State<AdminLoginScreen> createState() => _AdminLoginScreenState();
}

class _AdminLoginScreenState extends State<AdminLoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _usernameController = TextEditingController();
  final _passwordController = TextEditingController();
  
  bool _isLoading = false;
  bool _obscurePassword = true;

  @override
  void dispose() {
    _usernameController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleLogin() async {
  if (!_formKey.currentState!.validate()) return;

  setState(() => _isLoading = true);

  try {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    await authProvider.login(
      _usernameController.text.trim(),
      _passwordController.text.trim(),
      'admin',
    );

    if (mounted) {
      // Navigate to admin dashboard
      Navigator.pushReplacementNamed(context, '/admin-dashboard');
    }
  } catch (e) {
    if (mounted) {
      Helpers.showSnackBar(context, 'Login gagal: $e', isError: true);
    }
  } finally {
    if (mounted) {
      setState(() => _isLoading = false);
    }
  }
}

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.pop(context),
        ),
        title: const Text('UNILA Air Quality Index'),
        centerTitle: true,
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            children: [
              // Logo
              Container(
              width: 120,
              height: 120,
              decoration: BoxDecoration(
                color: Colors.white,
                shape: BoxShape.circle,
                border: Border.all(
                  color: AppColors.background,
                  width: 2,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.white,
                    blurRadius: 8,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: Padding(
                padding: const EdgeInsets.all(8.0), // Padding untuk memberi ruang
                child: Image.asset(
                  'assets/images/logo_unila.png',
                  width: 104, // 120 - (8*2) = 104
                  height: 104,
                  fit: BoxFit.contain, // Gunakan contain agar tidak terpotong
                ),
              ),
            ),
              const SizedBox(height: 16),
              // Title
              Text(
                'LOGIN ADMIN',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                      fontWeight: FontWeight.w700,
                      color: AppColors.primary,
                    ),
              ),
              const SizedBox(height: 32),
              // Login Form
              Form(
                key: _formKey,
                child: Column(
                  children: [
                    // Username Field
                    TextFormField(
                      controller: _usernameController,
                      decoration: const InputDecoration(
                        labelText: 'Username',
                        prefixIcon: Icon(Icons.person),
                        border: OutlineInputBorder(),
                      ),
                      validator: (value) =>
                          Validators.validateRequired(value, 'Username'),
                      textInputAction: TextInputAction.next,
                    ),
                    const SizedBox(height: 16),
                    // Password Field
                    TextFormField(
                      controller: _passwordController,
                      decoration: InputDecoration(
                        labelText: 'Password',
                        prefixIcon: const Icon(Icons.lock),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscurePassword
                                ? Icons.visibility_off
                                : Icons.visibility,
                          ),
                          onPressed: () {
                            setState(() => _obscurePassword = !_obscurePassword);
                          },
                        ),
                        border: const OutlineInputBorder(),
                      ),
                      obscureText: _obscurePassword,
                      validator: Validators.validatePassword,
                      textInputAction: TextInputAction.done,
                    ),
                    const SizedBox(height: 24),
                    // Login Button
                    SizedBox(
                      width: double.infinity,
                      height: 50,
                      child: ElevatedButton(
                        onPressed: _isLoading ? null : _handleLogin,
                        child: _isLoading
                            ? const SizedBox(
                                width: 24,
                                height: 24,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  color: Colors.white,
                                ),
                              )
                            : const Text(
                                'LOGIN',
                                style: TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                      ),
                    ),
                    const SizedBox(height: 16),
                    // Forgot Password Link
                    TextButton(
                      onPressed: () {
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                            builder: (context) => const ForgotPasswordScreen(),
                          ),
                        );
                      },
                      child: const Text(
                        'LUPA PASSWORD?',
                        style: TextStyle(
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                    const SizedBox(height: 24),
                    // Contact Information
                    const Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Untuk bantuan, hubungi:',
                          style: TextStyle(
                            fontSize: 14,
                            color: AppColors.textSecondary,
                          ),
                        ),
                        SizedBox(height: 8),
                        Text(
                          'â€¢ Email: admin@unila-aqi.ac.id',
                          style: TextStyle(
                            fontSize: 14,
                            color: AppColors.textSecondary,
                          ),
                        ),
                        Text(
                          'â€¢ Telepon: (0721) 123-4567',
                          style: TextStyle(
                            fontSize: 14,
                            color: AppColors.textSecondary,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/auth/forgot_password_screen.dart:

import 'package:flutter/material.dart';
import '../../../core/constants/colors.dart';
import '../../../core/utils/validators.dart';
import 'reset_password_screen.dart';

class ForgotPasswordScreen extends StatefulWidget {
  const ForgotPasswordScreen({super.key});

  @override
  State<ForgotPasswordScreen> createState() => _ForgotPasswordScreenState();
}

class _ForgotPasswordScreenState extends State<ForgotPasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  
  bool _isLoading = false;

  @override
  void dispose() {
    _emailController.dispose();
    super.dispose();
  }

  Future<void> _handleSendResetLink() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    // Simulasi delay network
    await Future.delayed(const Duration(seconds: 2));

    if (mounted) {
      setState(() => _isLoading = false);
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => ResetPasswordScreen(
            email: _emailController.text.trim(),
          ),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.pop(context),
        ),
        title: const Text('UNILA Air Quality Index'),
        centerTitle: true,
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            children: [
              // Logo
              Container(
                width: 80,
                height: 80,
                decoration: const BoxDecoration(
                  color: AppColors.primary,
                  shape: BoxShape.circle,
                ),
                child: const Icon(
                  Icons.lock_reset,
                  size: 40,
                  color: Colors.white,
                ),
              ),
              const SizedBox(height: 16),
              // Title
              Text(
                'LUPA PASSWORD',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                      fontWeight: FontWeight.w700,
                      color: AppColors.primary,
                    ),
              ),
              const SizedBox(height: 16),
              const Text(
                'Masukkan email admin yang terdaftar',
                style: TextStyle(
                  fontSize: 16,
                  color: AppColors.textSecondary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              // Email Form
              Form(
                key: _formKey,
                child: Column(
                  children: [
                    TextFormField(
                      controller: _emailController,
                      decoration: const InputDecoration(
                        labelText: 'Email',
                        prefixIcon: Icon(Icons.email),
                        border: OutlineInputBorder(),
                        hintText: 'admin@unila-aqi.ac.id',
                      ),
                      validator: Validators.validateEmail,
                      keyboardType: TextInputType.emailAddress,
                      textInputAction: TextInputAction.done,
                    ),
                    const SizedBox(height: 32),
                    // Send Button
                    SizedBox(
                      width: double.infinity,
                      height: 50,
                      child: ElevatedButton(
                        onPressed: _isLoading ? null : _handleSendResetLink,
                        child: _isLoading
                            ? const SizedBox(
                                width: 24,
                                height: 24,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  color: Colors.white,
                                ),
                              )
                            : const Text(
                                'KIRIM LINK RESET',
                                style: TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 32),
              // Alternative Contact Info
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: AppColors.surface,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: AppColors.border),
                ),
                child: const Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Atau hubungi super admin untuk reset password melalui:',
                      style: TextStyle(
                        fontSize: 14,
                        color: AppColors.textSecondary,
                      ),
                    ),
                    SizedBox(height: 12),
                    Row(
                      children: [
                        Icon(Icons.email, size: 16, color: AppColors.textHint),
                        SizedBox(width: 8),
                        Text(
                          'admin@unila-aqi.ac.id',
                          style: TextStyle(fontSize: 14),
                        ),
                      ],
                    ),
                    SizedBox(height: 8),
                    Row(
                      children: [
                        Icon(Icons.phone, size: 16, color: AppColors.textHint),
                        SizedBox(width: 8),
                        Text(
                          '(0721) 123-4567',
                          style: TextStyle(fontSize: 14),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/auth/mode_selection_screen.dart:

import 'package:flutter/material.dart';
import 'package:unila_aqi/presentation/pages/auth/admin_login_screen.dart';
import '../../../core/constants/app_constants.dart';
import '../../../core/constants/colors.dart';

class ModeSelectionScreen extends StatelessWidget {
  const ModeSelectionScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Logo dengan Asset Image
            Container(
              width: 150,
              height: 150,
              decoration: BoxDecoration(
                color: Colors.white,
                shape: BoxShape.circle,
                border: Border.all(
                  color: AppColors.background,
                  width: 2,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.white,
                    blurRadius: 8,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: Padding(
                padding: const EdgeInsets.all(8.0), // Padding untuk memberi ruang
                child: Image.asset(
                  'assets/images/logo_unila.png',
                  width: 104, // 120 - (8*2) = 104
                  height: 104,
                  fit: BoxFit.contain, // Gunakan contain agar tidak terpotong
                ),
              ),
            ),
              const SizedBox(height: 24),
              // App Title
              Text(
                AppConstants.appName,
                style: Theme.of(context).textTheme.displaySmall?.copyWith(
                      color: AppColors.primary,
                      fontWeight: FontWeight.w700,
                    ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
              const Text(
                'Sistem Monitoring Kualitas Udara',
                style: TextStyle(
                  fontSize: 16,
                  color: AppColors.textSecondary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 48),
              const Text(
                'Pilih Mode Akses:',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: AppColors.textPrimary,
                ),
              ),
              const SizedBox(height: 24),
              // User Mode Button
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () {
                    // Navigate to user dashboard
                    Navigator.pushReplacementNamed(context, '/dashboard');
                  },
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  child: const Text(
                    'User Mode',
                    style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                  ),
                ),
              ),
              const SizedBox(height: 16),
              // Admin Mode Button
              SizedBox(
                width: double.infinity,
                child: OutlinedButton(
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => const AdminLoginScreen(),
                      ),
                    );
                  },
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    side: const BorderSide(color: AppColors.primary, width: 2),
                  ),
                  child: const Text(
                    'Admin Mode',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                      color: AppColors.primary,
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 32),
              // Version Info
              const Text(
                'Versi ${AppConstants.appVersion}',
                style: TextStyle(
                  fontSize: 12,
                  color: AppColors.textHint,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/auth/reset_password_screen.dart:

import 'package:flutter/material.dart';
import '../../../core/constants/colors.dart';
import '../../../core/utils/helpers.dart';
import '../../../core/utils/validators.dart';

class ResetPasswordScreen extends StatefulWidget {
  final String email;

  const ResetPasswordScreen({super.key, required this.email});

  @override
  State<ResetPasswordScreen> createState() => _ResetPasswordScreenState();
}

class _ResetPasswordScreenState extends State<ResetPasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final List<TextEditingController> _codeControllers =
      List.generate(6, (index) => TextEditingController());
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final List<FocusNode> _codeFocusNodes = List.generate(6, (index) => FocusNode());

  bool _isLoading = false;
  bool _obscureNewPassword = true;
  bool _obscureConfirmPassword = true;
  int _countdown = 60;
  bool _canResend = false;

  @override
  void initState() {
    super.initState();
    _startCountdown();
    // Set up focus nodes to move to next field
    for (int i = 0; i < 5; i++) {
      _codeFocusNodes[i].addListener(() {
        if (!_codeFocusNodes[i].hasFocus && _codeControllers[i].text.length == 1) {
          FocusScope.of(context).requestFocus(_codeFocusNodes[i + 1]);
        }
      });
    }
  }

  @override
  void dispose() {
    for (var controller in _codeControllers) {
      controller.dispose();
    }
    for (var focusNode in _codeFocusNodes) {
      focusNode.dispose();
    }
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  void _startCountdown() {
    Future.delayed(const Duration(seconds: 1), () {
      if (mounted) {
        setState(() {
          if (_countdown > 0) {
            _countdown--;
            _startCountdown();
          } else {
            _canResend = true;
          }
        });
      }
    });
  }

  Future<void> _handleResetPassword() async {
    if (!_formKey.currentState!.validate()) return;

    // Combine code from 6 fields
    String code = '';
    for (var controller in _codeControllers) {
      code += controller.text;
    }

    if (code.length != 6) {
      Helpers.showSnackBar(context, 'Masukkan 6 digit kode dengan lengkap', isError: true);
      return;
    }

    setState(() => _isLoading = true);

    // Simulasi delay network
    await Future.delayed(const Duration(seconds: 2));

    if (mounted) {
      setState(() => _isLoading = false);
      // Tampilkan dialog sukses
      _showSuccessDialog();
    }
  }

  void _showSuccessDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.check_circle, color: AppColors.success),
            SizedBox(width: 8),
            Text('Berhasil'),
          ],
        ),
        content: const Text(
          'Password telah berhasil direset! Anda dapat login menggunakan password baru Anda.',
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context); // Tutup dialog
              Navigator.pop(context); // Kembali ke login
            },
            child: const Text('LOGIN SEKARANG'),
          ),
        ],
      ),
    );
  }

  void _resendCode() {
    if (!_canResend) return;

    setState(() {
      _canResend = false;
      _countdown = 60;
    });

    Helpers.showSnackBar(context, 'Kode verifikasi telah dikirim ulang');
    _startCountdown();
  }

  String _maskedEmail(String email) {
    final parts = email.split('@');
    if (parts.length != 2) return email;
    final username = parts[0];
    final domain = parts[1];
    if (username.length <= 3) return email;
    final masked = username.substring(0, 3) + '*' * (username.length - 3);
    return '$masked@$domain';
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.pop(context),
        ),
        title: const Text('UNILA Air Quality Index'),
        centerTitle: true,
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            children: [
              // Logo
              Container(
                width: 80,
                height: 80,
                decoration: const BoxDecoration(
                  color: AppColors.primary,
                  shape: BoxShape.circle,
                ),
                child: const Icon(
                  Icons.password,
                  size: 40,
                  color: Colors.white,
                ),
              ),
              const SizedBox(height: 16),
              // Title
              Text(
                'RESET PASSWORD',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                      fontWeight: FontWeight.w700,
                      color: AppColors.primary,
                    ),
              ),
              const SizedBox(height: 16),
              // Instruction
              const Text(
                'Kode verifikasi telah dikirim ke email:',
                style: TextStyle(
                  fontSize: 16,
                  color: AppColors.textSecondary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 4),
              Text(
                _maskedEmail(widget.email),
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: AppColors.primary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              // Form
              Form(
                key: _formKey,
                child: Column(
                  children: [
                    // Verification Code
                    const Text(
                      'Masukkan 6 digit kode verifikasi:',
                      style: TextStyle(fontSize: 16),
                    ),
                    const SizedBox(height: 16),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: List.generate(6, (index) {
                        return SizedBox(
                          width: 50,
                          child: TextFormField(
                            controller: _codeControllers[index],
                            focusNode: _codeFocusNodes[index],
                            decoration: InputDecoration(
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(8),
                              ),
                              counterText: '',
                              contentPadding: const EdgeInsets.symmetric(vertical: 12),
                            ),
                            textAlign: TextAlign.center,
                            keyboardType: TextInputType.number,
                            maxLength: 1,
                            onChanged: (value) {
                              if (value.length == 1 && index < 5) {
                                FocusScope.of(context).requestFocus(_codeFocusNodes[index + 1]);
                              }
                            },
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return '';
                              }
                              return null;
                            },
                          ),
                        );
                      }),
                    ),
                    const SizedBox(height: 32),
                    // New Password
                    TextFormField(
                      controller: _newPasswordController,
                      decoration: InputDecoration(
                        labelText: 'Password Baru*',
                        prefixIcon: const Icon(Icons.lock),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureNewPassword
                                ? Icons.visibility_off
                                : Icons.visibility,
                          ),
                          onPressed: () {
                            setState(() => _obscureNewPassword = !_obscureNewPassword);
                          },
                        ),
                        border: const OutlineInputBorder(),
                      ),
                      obscureText: _obscureNewPassword,
                      validator: Validators.validatePassword,
                    ),
                    const SizedBox(height: 16),
                    // Confirm Password
                    TextFormField(
                      controller: _confirmPasswordController,
                      decoration: InputDecoration(
                        labelText: 'Konfirmasi Password Baru*',
                        prefixIcon: const Icon(Icons.lock),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureConfirmPassword
                                ? Icons.visibility_off
                                : Icons.visibility,
                          ),
                          onPressed: () {
                            setState(() => _obscureConfirmPassword = !_obscureConfirmPassword);
                          },
                        ),
                        border: const OutlineInputBorder(),
                      ),
                      obscureText: _obscureConfirmPassword,
                      validator: (value) => Validators.validateConfirmPassword(
                        value, _newPasswordController.text,
                      ),
                    ),
                    const SizedBox(height: 32),
                    // Reset Button
                    SizedBox(
                      width: double.infinity,
                      height: 50,
                      child: ElevatedButton(
                        onPressed: _isLoading ? null : _handleResetPassword,
                        child: _isLoading
                            ? const SizedBox(
                                width: 24,
                                height: 24,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  color: Colors.white,
                                ),
                              )
                            : const Text(
                                'RESET PASSWORD',
                                style: TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 24),
              // Resend Code
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  TextButton(
                    onPressed: _canResend ? _resendCode : null,
                    child: Text(
                      _canResend ? 'Kirim ulang kode' : 'Kirim ulang kode (${_countdown}s)',
                      style: TextStyle(
                        color: _canResend ? AppColors.primary : AppColors.textDisabled,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 24),
              // Password Requirements
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: AppColors.surface,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: AppColors.border),
                ),
                child: const Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Ketentuan Password:',
                      style: TextStyle(
                        fontWeight: FontWeight.w600,
                        color: AppColors.textPrimary,
                      ),
                    ),
                    SizedBox(height: 8),
                    Text(
                      'â€¢ Minimal 8 karakter\nâ€¢ Kombinasi huruf dan angka\nâ€¢ Hindari penggunaan password yang mudah ditebak',
                      style: TextStyle(fontSize: 14, color: AppColors.textSecondary),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 16),
              // Support Contact
              const Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Jika mengalami masalah, hubungi:',
                    style: TextStyle(
                      fontSize: 14,
                      color: AppColors.textSecondary,
                    ),
                  ),
                  SizedBox(height: 8),
                  Text(
                    'admin@unila-aqi.ac.id\n(0721) 123-4567',
                    style: TextStyle(fontSize: 14),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/dashboard/dashboard_screen.dart:

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';
import 'package:unila_aqi/core/services/socket_service.dart';
import '../../../data/models/room.dart';
import '../../../presentation/providers/room_provider.dart';
import '../../../presentation/providers/auth_provider.dart';
import '../../../presentation/widgets/common/drawer.dart';
import '../../../presentation/widgets/common/building_section.dart';
import '../../../presentation/pages/room/room_detail_screen.dart';
import '../../../core/utils/helpers.dart';
import '../../../core/constants/colors.dart';
import '../../pages/info/aqi_info_screen.dart';

class DashboardScreen extends StatefulWidget {
  final bool isAdminMode;
  
  const DashboardScreen({
    super.key,
    this.isAdminMode = false,
  });

  @override
  State<DashboardScreen> createState() => _DashboardScreenState();
}

class _DashboardScreenState extends State<DashboardScreen> {
  final RefreshController _refreshController = RefreshController();
  final TextEditingController _searchController = TextEditingController();
  
  // Timer? _autoRefreshTimer;
  // int _autoRefreshCountdown = 10;
  bool _isMounted = false;

  @override
  void initState() {
  super.initState();
  _isMounted = true;
  
  // Delay initialization to avoid setState during build
  WidgetsBinding.instance.addPostFrameCallback((_) {
    if (_isMounted) {
      _loadInitialData();
      // _startAutoRefresh();
      _setupBuildingUpdateListener();
      _setupRoomNameUpdateListener(); // ðŸ”¥ BARU: Tambah listener untuk update nama ruangan
    }
  });
}

// ðŸ”¥ BARU: Setup listener untuk update nama ruangan
void _setupRoomNameUpdateListener() {
  Provider.of<RoomProvider>(context, listen: false);
  final socketService = SocketService();
  
  // Listen for room name updates
  socketService.on('room-name-changed', (data) {
    if (_isMounted) {
      print('ðŸ”„ Room name update received: ${data['oldName']} -> ${data['newName']}');
      
      // Refresh data untuk update tampilan
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_isMounted) {
          _refreshData();
          
          // Show notification
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Nama ruangan diperbarui: ${data['oldName']} -> ${data['newName']}'),
              backgroundColor: Colors.blue,
              duration: Duration(seconds: 2),
            ),
          );
        }
      });
    }
  });
  
  // Listen for dashboard-room-updated events
  socketService.on('dashboard-room-updated', (data) {
    if (_isMounted && data['action'] == 'updated') {
      print('ðŸ“¡ Dashboard room update received');
      
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_isMounted) {
          _refreshData();
        }
      });
    }
  });
}

void _setupBuildingUpdateListener() {
  Provider.of<RoomProvider>(context, listen: false);
  final socketService = SocketService();
  
  // Listen for building updates
  socketService.on('building-updated', (data) {
    if (_isMounted) {
      print('ðŸ¢ Building update received: ${data['action']}');
      
      // Jika building diedit, refresh data
      if (data['action'] == 'updated') {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (_isMounted) {
            _refreshData();
            
            // Show notification
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Data gedung diperbarui'),
                backgroundColor: Colors.green,
                duration: Duration(seconds: 2),
              ),
            );
          }
        });
      }
    }
  });
}
  
  @override
  @override
void dispose() {
  _isMounted = false;
  _refreshController.dispose();
  _searchController.dispose();
  // _autoRefreshTimer?.cancel();
  
  // Remove event listeners
  final socketService = SocketService();
  socketService.off('building-updated');
  socketService.off('room-name-changed'); // ðŸ”¥ BARU: Hapus listener nama ruangan
  socketService.off('dashboard-room-updated'); // ðŸ”¥ BARU: Hapus listener dashboard
  
  super.dispose();
}
  
 Future<void> _loadInitialData() async {
  if (!_isMounted) return;
  
  final roomProvider = Provider.of<RoomProvider>(context, listen: false);
  
  try {
    await roomProvider.loadRooms();
  } catch (e) {
    print('âŒ Error loading rooms: $e');
    
    // Tampilkan pesan error yang user-friendly
    if (e.toString().contains('401') || e.toString().contains('Access denied')) {
      Helpers.showSnackBar(
        context, 
        'Tidak bisa mengakses data. Silakan login sebagai admin atau hubungi administrator.',
        isError: true
      );
    }
  }
}

  
  Future<void> _refreshData() async {
    if (!_isMounted) return;
    
    final roomProvider = Provider.of<RoomProvider>(context, listen: false);
    await roomProvider.refresh();
    
    if (_isMounted) {
      _refreshController.refreshCompleted();
    }
  }
  
  void _handleRoomTap(Room room) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => RoomDetailScreen(room: room),
      ),
    );
  }
  
  void _handleLogout() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    await authProvider.logout();
    
    // Navigate back to mode selection
    Navigator.pushNamedAndRemoveUntil(
      context,
      '/',
      (route) => false,
    );
  }

   void _handleHelpTap() {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => const AQIInfoScreen(),
      ),
    );
  }
  
  @override
  Widget build(BuildContext context) {
    final roomProvider = Provider.of<RoomProvider>(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('UNILA Air Quality Index'),
        centerTitle: true,
        actions: [
  IconButton(
    icon: Icon(Icons.refresh),
    onPressed: _refreshData,
    tooltip: 'Refresh',
  ),

  Builder(
    builder: (context) => IconButton(
      icon: Icon(Icons.menu),
      onPressed: () => Scaffold.of(context).openDrawer(),
      tooltip: 'Menu',
    ),
  ),
],
      ),
      drawer: AppDrawer(
        isAdmin: widget.isAdminMode,
        onDashboardTap: () => Navigator.pop(context),
        onBuildingsTap: () {
          Navigator.pushNamed(context, '/admin/buildings');
        },
        onRoomsTap: () {
          Navigator.pushNamed(context, '/admin/rooms');
        },
        onDevicesTap: () {
          Navigator.pushNamed(context, '/admin/iot-devices');
        },
        onProfileTap: () {
          Helpers.showSnackBar(context, 'Profile management coming soon!');
        },
        onHelpTap: _handleHelpTap,
        onLogoutTap: _handleLogout,
      ),
      body: SmartRefresher(
        controller: _refreshController,
        onRefresh: _refreshData,
        header: const WaterDropHeader(
          waterDropColor: AppColors.primary,
        ),
        child: CustomScrollView(
          slivers: [
            // Search and Filter Section
            SliverToBoxAdapter(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  children: [
                    // Search Bar
                    TextField(
                      controller: _searchController,
                      decoration: InputDecoration(
                        hintText: 'ðŸ” Search...',
                        filled: true,
                        fillColor: Colors.white,
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide.none,
                        ),
                        contentPadding: const EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 12,
                        ),
                        suffixIcon: _searchController.text.isNotEmpty
                            ? IconButton(
                                icon: const Icon(Icons.clear),
                                onPressed: () {
                                  _searchController.clear();
                                  roomProvider.updateSearchQuery('');
                                },
                              )
                            : null,
                      ),
                      onChanged: (value) {
                        roomProvider.updateSearchQuery(value);
                      },
                    ),
                    const SizedBox(height: 16),
                    // Filter Row
                    Row(
                      children: [
                        Expanded(
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 12),
                            decoration: BoxDecoration(
                              color: Colors.white,
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(color: AppColors.border),
                            ),
                            child: _buildBuildingDropdown(roomProvider),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 12),
                            decoration: BoxDecoration(
                              color: Colors.white,
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(color: AppColors.border),
                            ),
                            child: _buildSortDropdown(roomProvider),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
            // Loading State
            if (roomProvider.isLoading)
              const SliverFillRemaining(
                child: Center(
                  child: CircularProgressIndicator(),
                ),
              )
            // Error State
            else if (roomProvider.hasError)
              SliverFillRemaining(
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(
                        Icons.error_outline,
                        size: 64,
                        color: AppColors.error,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'Error: ${roomProvider.errorMessage}',
                        style: const TextStyle(color: AppColors.error),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 16),
                      ElevatedButton(
                        onPressed: _refreshData,
                        child: const Text('Coba Lagi'),
                      ),
                    ],
                  ),
                ),
              )
            // Empty State
            else if (roomProvider.rooms.isEmpty)
              SliverFillRemaining(
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(
                        Icons.search_off,
                        size: 64,
                        color: Colors.grey,
                      ),
                      const SizedBox(height: 16),
                      const Text(
                        'Tidak ada ruangan ditemukan',
                        style: TextStyle(fontSize: 16, color: Colors.grey),
                      ),
                      const SizedBox(height: 8),
                      if (_searchController.text.isNotEmpty || 
                          roomProvider.selectedBuilding != 'Semua Gedung')
                        TextButton(
                          onPressed: () {
                            roomProvider.clearFilters();
                            _searchController.clear();
                          },
                          child: const Text('Reset Filter'),
                        ),
                    ],
                  ),
                ),
              )
            // Data State - Grouped by Building
            else
              SliverList(
                delegate: SliverChildBuilderDelegate(
                  (context, index) {
                    final buildingEntries = roomProvider.roomsByBuilding.entries.toList();
                    final buildingName = buildingEntries[index].key;
                    final rooms = buildingEntries[index].value;
                    
                    return Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      child: BuildingSection(
                        buildingName: buildingName,
                        rooms: rooms,
                        onRoomTap: _handleRoomTap,
                      ),
                    );
                  },
                  childCount: roomProvider.roomsByBuilding.length,
                ),
              ),
        
          ],
        ),
      ),
    );
  }
  
  Widget _buildBuildingDropdown(RoomProvider roomProvider) {
    // Remove duplicates from building list
    final uniqueBuildings = roomProvider.buildings.toSet().toList();
    
    // Log for debugging
    if (uniqueBuildings.length != roomProvider.buildings.length) {
      print('âš ï¸ Removed duplicate buildings. Original: ${roomProvider.buildings.length}, Unique: ${uniqueBuildings.length}');
      print('Duplicates: ${roomProvider.buildings.where((building) => roomProvider.buildings.where((b) => b == building).length > 1).toSet()}');
    }
    
    return DropdownButtonHideUnderline(
      child: DropdownButton<String>(
        value: roomProvider.selectedBuilding,
        isExpanded: true,
        icon: const Icon(Icons.arrow_drop_down),
        onChanged: (value) {
          if (value != null) {
            roomProvider.updateBuildingFilter(value);
          }
        },
        items: uniqueBuildings.map((building) {
          return DropdownMenuItem(
            value: building,
            child: Text(
              building,
              overflow: TextOverflow.ellipsis,
            ),
          );
        }).toList(),
      ),
    );
  }
  
  Widget _buildSortDropdown(RoomProvider roomProvider) {
    return DropdownButtonHideUnderline(
      child: DropdownButton<String>(
        value: roomProvider.sortBy,
        isExpanded: true,
        icon: const Icon(Icons.arrow_drop_down),
        onChanged: (value) {
          if (value != null) {
            roomProvider.updateSort(value);
          }
        },
        items: const [
          DropdownMenuItem(
            value: 'Terbaru',
            child: Text('Terbaru'),
          ),
          DropdownMenuItem(
            value: 'A-Z',
            child: Text('A-Z'),
          ),
          DropdownMenuItem(
            value: 'AQI Terbaik',
            child: Text('AQI Terbaik'),
          ),
          DropdownMenuItem(
            value: 'AQI Terburuk',
            child: Text('AQI Terburuk'),
          ),
        ],
      ),
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/pages/room/room_detail_screen.dart: 

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:unila_aqi/core/constants/colors.dart';
// import 'package:unila_aqi/core/services/api_service.dart';
import 'package:unila_aqi/core/services/socket_service.dart';
import 'package:unila_aqi/core/utils/helpers.dart';
import 'package:unila_aqi/data/models/room.dart';
import 'package:unila_aqi/presentation/widgets/chart/history_chart.dart';

class RoomDetailScreen extends StatefulWidget {
  final Room room;

  const RoomDetailScreen({
    super.key,
    required this.room,
  });

  @override
  State<RoomDetailScreen> createState() => _RoomDetailScreenState();
}

class _RoomDetailScreenState extends State<RoomDetailScreen> {
  // final ApiService _apiService = ApiService();
  final SocketService _socketService = SocketService();

  bool _isRefreshing = false;
  bool _isMounted = false;
  bool _socketConnected = false;
  late Room _currentRoomData;

  @override
  void initState() {
    super.initState();
    _isMounted = true;
    _currentRoomData = widget.room;

    // Join room for real-time updates
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _joinRoomForUpdates();
      _setupRealtimeListener();
      _setupBuildingUpdateListener();
      _setupRoomNameUpdateListener();
      _checkSocketConnection();
    });
  }

  void _setupRoomNameUpdateListener() {
    // Listen for room name updates
    _socketService.on('room-name-updated', (data) {
      if (_isMounted && data['roomId'] == widget.room.id) {
        final newName = data['newName'];
        final oldName = data['oldName'];

        print('ðŸ”„ Room name updated for this room: $oldName -> $newName');

        // Update room data dengan nama baru
        setState(() {
          _currentRoomData = Room(
            id: _currentRoomData.id,
            name: newName, // Update nama ruangan
            buildingId: _currentRoomData.buildingId,
            buildingName: _currentRoomData.buildingName,
            dataSource: _currentRoomData.dataSource,
            iotDeviceId: _currentRoomData.iotDeviceId,
            isActive: _currentRoomData.isActive,
            currentAQI: _currentRoomData.currentAQI,
            currentData: _currentRoomData.currentData,
            createdAt: _currentRoomData.createdAt,
            updatedAt: DateTime.now(),
          );
        });

        // Show notification
        _showNotification('Nama ruangan diperbarui: $oldName -> $newName', 'info');
      }
    });

    // Listen for room-updated events (general updates)
    _socketService.on('room-updated', (data) {
      if (_isMounted && data['room']['id'] == widget.room.id) {
        if (data['action'] == 'updated' && data['oldData']) {
          final newName = data['room']['name'];
          final oldName = data['oldData']['name'];

          if (newName != oldName) {
            print('ðŸ”„ Detected room name change in room-updated event');

            setState(() {
              _currentRoomData = Room(
                id: _currentRoomData.id,
                name: newName,
                buildingId: _currentRoomData.buildingId,
                buildingName: _currentRoomData.buildingName,
                dataSource: _currentRoomData.dataSource,
                iotDeviceId: _currentRoomData.iotDeviceId,
                isActive: _currentRoomData.isActive,
                currentAQI: _currentRoomData.currentAQI,
                currentData: _currentRoomData.currentData,
                createdAt: _currentRoomData.createdAt,
                updatedAt: DateTime.now(),
              );
            });

            _showNotification('Nama ruangan diperbarui: $oldName -> $newName', 'info');
          }
        }
      }
    });
  }

  void _setupBuildingUpdateListener() {
    // Listen for building name updates specific to this room
    _socketService.on('room-building-updated', (data) {
      if (_isMounted && data['buildingId'] == widget.room.buildingId) {
        final newBuildingName = data['newBuildingName'];

        print('ðŸ¢ Building name updated for this room: $newBuildingName');

        // Update room data with new building name
        setState(() {
          _currentRoomData = Room(
            id: _currentRoomData.id,
            name: _currentRoomData.name,
            buildingId: _currentRoomData.buildingId,
            buildingName: newBuildingName, // Update building name
            dataSource: _currentRoomData.dataSource,
            iotDeviceId: _currentRoomData.iotDeviceId,
            isActive: _currentRoomData.isActive,
            currentAQI: _currentRoomData.currentAQI,
            currentData: _currentRoomData.currentData,
            createdAt: _currentRoomData.createdAt,
            updatedAt: _currentRoomData.updatedAt,
          );
        });

        // Show notification
        _showNotification('Nama gedung diperbarui: $newBuildingName', 'info');
      }
    });
  }

  void _joinRoomForUpdates() {
    _socketService.joinRoom(widget.room.id);
  }

  void _setupRealtimeListener() {
    // Listen for room updates from SocketService
    _socketService.on('room-update', (data) {
      if (_isMounted && data['roomId'] == widget.room.id) {
        _handleRoomUpdate(data);
      }
    });

    // Listen for notifications
    _socketService.on('notification', (data) {
      if (_isMounted) {
        _showNotification(data['message'], data['type'] ?? 'info');
      }
    });

    // Update connection status
    _socketConnected = _socketService.isConnected;
  }

  void _handleRoomUpdate(dynamic data) {
    try {
      final roomData = data['data'];

      // ðŸ”¥ BARU: Check if name has changed
      final oldName = _currentRoomData.name;
      final newName = roomData['name'] ?? _currentRoomData.name;
      final nameChanged = oldName != newName;

      setState(() {
        _currentRoomData = Room(
          id: _currentRoomData.id,
          name: newName, // ðŸ”¥ BARU: Gunakan nama baru jika ada
          buildingId: _currentRoomData.buildingId,
          buildingName: _currentRoomData.buildingName,
          dataSource: _currentRoomData.dataSource,
          iotDeviceId: _currentRoomData.iotDeviceId,
          isActive: _currentRoomData.isActive,
          currentAQI: roomData['currentAQI'],
          currentData: RoomData(
            pm25: roomData['currentData']['pm25'].toDouble(),
            pm10: roomData['currentData']['pm10'].toDouble(),
            co2: roomData['currentData']['co2'].toDouble(),
            temperature: roomData['currentData']['temperature'].toDouble(),
            humidity: roomData['currentData']['humidity'].toDouble(),
            updatedAt: DateTime.parse(roomData['currentData']['updatedAt']),
          ),
          createdAt: _currentRoomData.createdAt,
          updatedAt: DateTime.parse(roomData['updatedAt']),
        );
      });

      // Show update notification
      if (nameChanged) {
        _showNotification('Nama ruangan diperbarui: $oldName -> $newName', 'info');
      }

      print('ðŸ”„ Real-time update: Room ${_currentRoomData.name} - AQI ${_currentRoomData.currentAQI}');
    } catch (e) {
      print('âŒ Error handling room update: $e');
    }
  }

  void _showNotification(String message, String type) {
    Color backgroundColor;
    IconData icon;

    switch (type) {
      case 'warning':
        backgroundColor = Colors.orange;
        icon = Icons.warning;
        break;
      case 'error':
        backgroundColor = Colors.red;
        icon = Icons.error;
        break;
      case 'success':
        backgroundColor = Colors.green;
        icon = Icons.check_circle;
        break;
      default:
        backgroundColor = Colors.blue;
        icon = Icons.info;
    }

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            Icon(icon, color: Colors.white),
            SizedBox(width: 8),
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: backgroundColor,
        duration: Duration(seconds: 3),
      ),
    );
  }

  void _checkSocketConnection() {
    setState(() {
      _socketConnected = _socketService.isConnected;
    });

    if (!_socketConnected && _isMounted) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _showNotification('Koneksi real-time terputus. Mencoba reconnect...', 'warning');
        _reconnectSocket();
      });
    }
  }

  Future<void> _reconnectSocket() async {
    try {
      await _socketService.connect();
      await Future.delayed(Duration(seconds: 2));
      if (_socketService.isConnected) {
        _joinRoomForUpdates();
        setState(() {
          _socketConnected = true;
        });
        _showNotification('Koneksi real-time berhasil dipulihkan', 'success');
      }
    } catch (e) {
      print('âŒ Failed to reconnect: $e');
    }
  }

  Future<void> _refreshData() async {
    if (!_isMounted) return;

    setState(() => _isRefreshing = true);
    
    // In a real app, you would refresh the current data
    await Future.delayed(Duration(seconds: 1)); // Simulate network delay

    if (_isMounted) {
      setState(() => _isRefreshing = false);
    }
  }

  Widget _buildParameterCard(String label, String value, String status, Color color) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: AppColors.cardBackground,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: AppColors.border),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        children: [
          Text(
            label,
            style: const TextStyle(
              fontSize: 12,
              color: AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            value,
            style: const TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.w600,
              color: AppColors.textPrimary,
            ),
          ),
          const SizedBox(height: 8),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: color.withOpacity(0.1),
              borderRadius: BorderRadius.circular(20),
              border: Border.all(color: color),
            ),
            child: Text(
              status,
              style: TextStyle(
                fontSize: 10,
                fontWeight: FontWeight.w500,
                color: color,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHealthRecommendations() {
    final aqi = _currentRoomData.currentAQI;
    final aqiColor = Helpers.getAQIColor(aqi);
    final recommendations = Helpers.getDetailedRecommendations(_currentRoomData);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: AppColors.cardBackground,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: AppColors.border),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.health_and_safety,
                color: aqiColor,
                size: 20,
              ),
              const SizedBox(width: 8),
              Text(
                'REKOMENDASI KESEHATAN:',
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                  color: aqiColor,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),

          // Parameter Status
          _buildParameterStatus(),
          const SizedBox(height: 12),

          // Recommendations List
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: recommendations.map((rec) => _buildRecommendationItem(rec)).toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildParameterStatus() {
    final data = _currentRoomData.currentData;

    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: [
        _buildStatusChip('PM2.5: ${data.pm25.toStringAsFixed(1)}', 
            Helpers.getPM25Color(data.pm25)),
        _buildStatusChip('PM10: ${data.pm10.toStringAsFixed(1)}', 
            Helpers.getPM25Color(data.pm10)),
        _buildStatusChip('COâ‚‚: ${data.co2.round()}', 
            Helpers.getCO2Color(data.co2)),
        _buildStatusChip('Suhu: ${data.temperature.toStringAsFixed(1)}Â°C', 
            Helpers.getTemperatureColor(data.temperature)),
        _buildStatusChip('Lembab: ${data.humidity.round()}%', 
            Helpers.getHumidityColor(data.humidity)),
      ],
    );
  }

  Widget _buildStatusChip(String text, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: color),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 11,
          color: color,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }

  Widget _buildRecommendationItem(String text) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Icon(
            Icons.arrow_right,
            size: 16,
            color: Colors.grey,
          ),
          const SizedBox(width: 4),
          Expanded(
            child: Text(
              text,
              style: const TextStyle(fontSize: 14),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildLastUpdateInfo() {
    final lastUpdateFormatted = Helpers.formatLastUpdateWithDate(_currentRoomData.currentData.updatedAt);

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: AppColors.surface,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        children: [
          Icon(
            Icons.update,
            size: 16,
            color: Colors.grey,
          ),
          SizedBox(width: 8),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Update terakhir',
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey,
                  ),
                ),
                Text(
                  lastUpdateFormatted,
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ),
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: _currentRoomData.isActive ? Colors.green.withOpacity(0.1) : Colors.grey.withOpacity(0.1),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Row(
              children: [
                Container(
                  width: 6,
                  height: 6,
                  decoration: BoxDecoration(
                    color: _currentRoomData.isActive ? Colors.green : Colors.grey,
                    shape: BoxShape.circle,
                  ),
                ),
                SizedBox(width: 4),
                Text(
                  _currentRoomData.isActive ? 'Aktif' : 'Nonaktif',
                  style: TextStyle(
                    fontSize: 10,
                    color: _currentRoomData.isActive ? Colors.green : Colors.grey,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildLegendItem(String label, Color color) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 12,
          height: 12,
          decoration: BoxDecoration(
            color: color,
            shape: BoxShape.circle,
          ),
        ),
        const SizedBox(width: 4),
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey.shade700,
          ),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    final aqiColor = Helpers.getAQIColor(_currentRoomData.currentAQI);
    final aqiLabel = Helpers.getAQILabel(_currentRoomData.currentAQI);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.pop(context),
        ),
        title: const Text('UNILA Air Quality Index'),
        centerTitle: true,
        actions: [
          IconButton(
            icon: _isRefreshing
                ? SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : Icon(Icons.refresh),
            onPressed: _refreshData,
            tooltip: 'Refresh manual',
          ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: _refreshData,
        child: SingleChildScrollView(
          physics: AlwaysScrollableScrollPhysics(),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Real-time connection status
                if (!_socketConnected)
                  Container(
                    padding: const EdgeInsets.all(12),
                    margin: const EdgeInsets.only(bottom: 16),
                    decoration: BoxDecoration(
                      color: Colors.orange.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.orange),
                    ),
                    child: Row(
                      children: [
                        Icon(Icons.wifi_off, size: 20, color: Colors.orange),
                        SizedBox(width: 12),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Koneksi real-time terputus',
                                style: TextStyle(
                                  fontWeight: FontWeight.w600,
                                  color: Colors.orange,
                                ),
                              ),
                              SizedBox(height: 4),
                              Text(
                                'Data mungkin tidak update secara real-time. Mencoba reconnect otomatis...',
                                style: TextStyle(
                                  fontSize: 12,
                                  color: Colors.orange,
                                ),
                              ),
                            ],
                          ),
                        ),
                        IconButton(
                          icon: Icon(Icons.refresh, size: 18),
                          onPressed: _reconnectSocket,
                          color: Colors.orange,
                        ),
                      ],
                    ),
                  ),

                // Room header with AQI
                Container(
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: AppColors.cardBackground,
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(color: AppColors.border),
                  ),
                  child: Row(
                    children: [
                      // AQI Circle
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          color: aqiColor.withOpacity(0.1),
                          shape: BoxShape.circle,
                          border: Border.all(
                            color: aqiColor,
                            width: 3,
                          ),
                        ),
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Text(
                              _currentRoomData.currentAQI.toString(),
                              style: TextStyle(
                                fontSize: 24,
                                fontWeight: FontWeight.w700,
                                color: aqiColor,
                              ),
                            ),
                            Text(
                              'AQI',
                              style: TextStyle(
                                fontSize: 12,
                                color: aqiColor,
                              ),
                            ),
                          ],
                        ),
                      ),

                      SizedBox(width: 16),

                      // Room info
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              _currentRoomData.name,
                              style: TextStyle(
                                fontSize: 18,
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                            SizedBox(height: 4),
                            Text(
                              _currentRoomData.buildingName,
                              style: TextStyle(
                                fontSize: 14,
                                color: Colors.grey,
                              ),
                            ),
                            SizedBox(height: 8),
                            Container(
                              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                              decoration: BoxDecoration(
                                color: aqiColor,
                                borderRadius: BorderRadius.circular(20),
                              ),
                              child: Text(
                                aqiLabel,
                                style: TextStyle(
                                  color: Colors.white,
                                  fontWeight: FontWeight.w600,
                                  fontSize: 12,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),

                      // Data source indicator
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color: _currentRoomData.dataSource == 'iot' 
                              ? Colors.blue.withOpacity(0.1) 
                              : Colors.purple.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Row(
                          children: [
                            Icon(
                              _currentRoomData.dataSource == 'iot' 
                                  ? Icons.sensors 
                                  : Icons.auto_awesome,
                              size: 12,
                              color: _currentRoomData.dataSource == 'iot' 
                                  ? Colors.blue 
                                  : Colors.purple,
                            ),
                            SizedBox(width: 4),
                            Text(
                              _currentRoomData.dataSource == 'iot' ? 'IoT' : 'Simulasi',
                              style: TextStyle(
                                fontSize: 10,
                                color: _currentRoomData.dataSource == 'iot' 
                                    ? Colors.blue 
                                    : Colors.purple,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),

                SizedBox(height: 16),

                // Last update info
                _buildLastUpdateInfo(),

                SizedBox(height: 24),

                // Parameter Cards
                const Text(
                  'PARAMETER KUALITAS UDARA:',
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 12),

                // First Row: PM2.5, PM10, CO2
                GridView.count(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  crossAxisCount: 3,
                  mainAxisSpacing: 12,
                  crossAxisSpacing: 12,
                  childAspectRatio: 0.85,
                  children: [
                    _buildParameterCard(
                      'PM2.5',
                      _currentRoomData.currentData.pm25.toStringAsFixed(1),
                      Helpers.getPM25Status(_currentRoomData.currentData.pm25),
                      Helpers.getPM25Color(_currentRoomData.currentData.pm25),
                    ),
                    _buildParameterCard(
                      'PM10',
                      _currentRoomData.currentData.pm10.toStringAsFixed(1),
                      Helpers.getPM25Status(_currentRoomData.currentData.pm10),
                      Helpers.getPM25Color(_currentRoomData.currentData.pm10),
                    ),
                    _buildParameterCard(
                      'COâ‚‚',
                      '${_currentRoomData.currentData.co2.round()}',
                      Helpers.getCO2Status(_currentRoomData.currentData.co2),
                      Helpers.getCO2Color(_currentRoomData.currentData.co2),
                    ),
                  ],
                ),

                SizedBox(height: 12),

                // Second Row: Temperature, Humidity
                GridView.count(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  crossAxisCount: 2,
                  mainAxisSpacing: 12,
                  crossAxisSpacing: 12,
                  childAspectRatio: 1.3,
                  children: [
                    _buildParameterCard(
                      'SUHU',
                      '${_currentRoomData.currentData.temperature.toStringAsFixed(1)}Â°C',
                      Helpers.getTemperatureStatus(_currentRoomData.currentData.temperature),
                      Helpers.getTemperatureColor(_currentRoomData.currentData.temperature),
                    ),
                    _buildParameterCard(
                      'KELEMBABAN',
                      '${_currentRoomData.currentData.humidity.round()}%',
                      Helpers.getHumidityStatus(_currentRoomData.currentData.humidity),
                      Helpers.getHumidityColor(_currentRoomData.currentData.humidity),
                    ),
                  ],
                ),

                SizedBox(height: 24),

                // Health Recommendations
                _buildHealthRecommendations(),

                SizedBox(height: 24),

                // History Chart Section
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(16),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          const Icon(
                            Icons.timeline,
                            color: Colors.blue,
                            size: 20,
                          ),
                          const SizedBox(width: 8),
                          const Text(
                            'GRAFIK HISTORIS 24 JAM',
                            style: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const Spacer(),
                          
                        ],
                      ),
                      const SizedBox(height: 4),
                    //  Container(
                    //         padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    //         decoration: BoxDecoration(
                    //           color: Colors.blue.withOpacity(0.1),
                    //           borderRadius: BorderRadius.circular(8),
                    //         ),
                    //         child: Row(
                    //           children: [
                    //             Container(
                    //               width: 8,
                    //               height: 8,
                    //               decoration: const BoxDecoration(
                    //                 color: Colors.blue,
                    //                 shape: BoxShape.circle,
                    //               ),
                    //             ),
                    //             const SizedBox(width: 4),
                    //             Text(
                    //               'Update setiap 30 menit',
                    //               style: TextStyle(
                    //                 fontSize: 10,
                    //                 color: Colors.blue.shade700,
                    //                 fontWeight: FontWeight.w500,
                    //               ),
                    //             ),
                    //           ],
                    //         ),
                    //       ),
                      
                      
                      // Chart Widget
                      HistoryChart(
                        roomId: _currentRoomData.id,
                        roomName: _currentRoomData.name,
                        buildingName: _currentRoomData.buildingName,
                      ),
                      
                      const SizedBox(height: 16),
                      
                      // Chart Legend
                      Wrap(
                        spacing: 12,
                        runSpacing: 8,
                        children: [
                          _buildLegendItem('AQI', Colors.blue),
                          _buildLegendItem('PM2.5', Colors.red),
                          _buildLegendItem('PM10', Colors.orange),
                          _buildLegendItem('COâ‚‚', Colors.green),
                          _buildLegendItem('Suhu', Colors.purple),
                          _buildLegendItem('Kelembaban', Colors.teal),
                        ],
                      ),
                      
                      const SizedBox(height: 8),
                      
                      
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _isMounted = false;

    // Leave room
    _socketService.leaveRoom(widget.room.id);

    // Remove event listeners
    _socketService.off('room-update');
    _socketService.off('notification');
    _socketService.off('room-building-updated');
    _socketService.off('room-name-updated');
    _socketService.off('room-updated');

    super.dispose();
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/providers/auth_provider.dart:

import 'package:flutter/material.dart';
import '../../core/services/auth_service.dart';

class AuthProvider with ChangeNotifier {
  final AuthService _authService = AuthService();
  
  Map<String, dynamic>? _currentUser;
  bool _isLoggedIn = false;
  bool _isLoading = false;
  
  Map<String, dynamic>? get currentUser => _currentUser;
  bool get isLoggedIn => _isLoggedIn;
  bool get isLoading => _isLoading;
  bool get isAdmin => _currentUser?['role'] == 'admin';
  
  // Initialize auth state
  Future<void> initialize() async {
    _isLoading = true;
    notifyListeners();
    
    try {
      _isLoggedIn = await _authService.isLoggedIn();
      if (_isLoggedIn) {
        _currentUser = await _authService.getCurrentUser();
      }
    } catch (e) {
      _isLoggedIn = false;
      _currentUser = null;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
  
  // Login
  Future<void> login(String username, String password, String role) async {
    _isLoading = true;
    notifyListeners();
    
    try {
      final response = await _authService.loginAdmin(username, password);
      
      if (response['success'] == true) {
        _currentUser = response['user'];
        _isLoggedIn = true;
      } else {
        throw Exception(response['message'] ?? 'Login failed');
      }
    } catch (e) {
      rethrow;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
  
  // Logout
  Future<void> logout() async {
    _isLoading = true;
    notifyListeners();
    
    try {
      await _authService.logout();
      _currentUser = null;
      _isLoggedIn = false;
    } catch (e) {
      rethrow;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
  
  // Change password
  Future<void> changePassword(String oldPassword, String newPassword) async {
    _isLoading = true;
    notifyListeners();
    
    try {
      await _authService.changePassword(oldPassword, newPassword);
    } catch (e) {
      rethrow;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/providers/building_provider.dart:

import 'package:flutter/material.dart';
import '../../data/models/building.dart';
import '../../core/services/api_service.dart';

class BuildingProvider with ChangeNotifier {
  final ApiService _apiService = ApiService();
  
  List<Building> _buildings = [];
  bool _isLoading = false;
  bool _hasError = false;
  String _errorMessage = '';
  
  // Getters
  List<Building> get buildings => _buildings;
  bool get isLoading => _isLoading;
  bool get hasError => _hasError;
  String get errorMessage => _errorMessage;
  
  // Load buildings
  Future<void> loadBuildings() async {
  _isLoading = true;
  _hasError = false;
  notifyListeners();

  try {
    final response = await _apiService.getTestBuildings();
    
    if (response['success'] == true) {
      final List<dynamic> data = response['data'];
      _buildings = data.map((json) => Building.fromJson(json)).toList();
    } else {
      throw Exception('Failed to load buildings: ${response['message']}');
    }
  } catch (e) {
    _hasError = true;
    _errorMessage = e.toString();
    print('Error loading buildings: $e');
  } finally {
    _isLoading = false;
    notifyListeners();
  }
}
  
  // Get building by ID
  Building? getBuildingById(String buildingId) {
    try {
      return _buildings.firstWhere((building) => building.id == buildingId);
    } catch (e) {
      return null;
    }
  }
  
  // Add building (will be implemented in Phase 2)
  Future<void> addBuilding({
    required String name,
    String? code,
    String? description,
  }) async {
    // TODO: Implement in Phase 2
    notifyListeners();
  }
  
  // Update building (will be implemented in Phase 2)
  Future<void> updateBuilding({
    required String buildingId,
    required String name,
    String? code,
    String? description,
  }) async {
    // TODO: Implement in Phase 2
    notifyListeners();
  }
  
  // Delete building (will be implemented in Phase 2)
  Future<void> deleteBuilding(String buildingId) async {
    // TODO: Implement in Phase 2
    notifyListeners();
  }
  
  // Clear error
  void clearError() {
    _hasError = false;
    _errorMessage = '';
    notifyListeners();
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/providers/room_provider.dart:

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:unila_aqi/data/repositories/room_repository.dart';
import 'package:unila_aqi/core/services/socket_service.dart';
import 'package:unila_aqi/core/services/storage_service.dart';
import '../../data/models/room.dart';
 
class RoomProvider with ChangeNotifier {
  final RoomRepository _roomRepository = RoomRepository();
  final SocketService _socketService = SocketService();
  final StorageService _storageService = StorageService();
 
  List<Room> _rooms = [];
  List<Room> _filteredRooms = [];
  String _selectedBuilding = 'Semua Gedung';
  String _sortBy = 'Terbaru';
  String _searchQuery = '';
 
  bool _isLoading = false;
  bool _hasError = false;
  String _errorMessage = '';
  bool _socketConnected = false;
  bool _isRefreshing = false;
 
  // Timer for periodic refresh
  // Timer? _refreshTimer;
  // final Duration _refreshInterval = Duration(seconds: 60); // Refresh every 60 seconds
  DateTime _lastUpdate = DateTime.now();
 
  // Stream subscriptions
  StreamSubscription? _socketSubscription;
  StreamSubscription? _dataSubscription;
 
  // Getters
  List<Room> get rooms => _filteredRooms;
  List<Room> get allRooms => _rooms;
  bool get isLoading => _isLoading;
  bool get isRefreshing => _isRefreshing;
  bool get hasError => _hasError;
  String get errorMessage => _errorMessage;
  String get selectedBuilding => _selectedBuilding;
  String get sortBy => _sortBy;
  String get searchQuery => _searchQuery;
  bool get socketConnected => _socketConnected;
  DateTime get lastUpdate => _lastUpdate;
 
  // Get unique buildings for filter
  List<String> get buildings {
    final buildingSet = <String>{'Semua Gedung'};
 
    for (final room in _rooms) {
      if (room.buildingName.isNotEmpty) {
        buildingSet.add(room.buildingName);
      }
    }
 
    return buildingSet.toList();
  }
 
  // Initialize socket connection and start periodic refresh
  Future<void> initSocket() async {
  try {
    // Get auth token
    final token = await _storageService.getString('auth_token');
    
    // Connect to WebSocket
    await _socketService.connect(token: token);
    
    // Setup connection listener
    _socketSubscription = _socketService.connectionStream.listen((connected) {
      _socketConnected = connected;
      notifyListeners();
    });
    
    // Setup data listener
    _dataSubscription = _socketService.dataStream.listen(_handleSocketData);
    
    // Setup listeners
    _setupSocketListeners();
    
    // Update status
    _socketConnected = _socketService.isConnected;
    await _storageService.setSocketConnected(_socketConnected);
    
    if (_socketConnected) {
      print('âœ… Socket.io initialized and connected');
    }
    
    notifyListeners();
  } catch (e) {
    print('âŒ Error initializing socket: $e');
    _socketConnected = false;
  }
}

void _setupSocketListeners() {
  _socketService.on('room-update', _handleRoomUpdate);
  _socketService.on('dashboard-update', _handleDashboardUpdate);
  _socketService.on('room-name-changed', (data) {
    handleRoomNameChanged(data);
  });
  _socketService.on('room-building-changed', (data) {
    handleBuildingNameChanged(data);
  });
}
 
  // Start periodic refresh timer
  // void _startPeriodicRefresh() {
  //   if (_refreshTimer != null && _refreshTimer!.isActive) {
  //     _refreshTimer!.cancel();
  //   }
 
  //   _refreshTimer = Timer.periodic(_refreshInterval, (timer) {
  //     if (_socketConnected) {
  //       // Use socket for real-time updates
  //       _socketService.requestRefresh();
  //     } else {
  //       // Fallback to API refresh
  //       _refreshData();
  //     }
  //   });
 
  //   print('ðŸ”„ Started periodic refresh every ${_refreshInterval.inSeconds}s');
  // }
 
  // Stop periodic refresh timer
  // void _stopPeriodicRefresh() {
  //   if (_refreshTimer != null) {
  //     _refreshTimer!.cancel();
  //     _refreshTimer = null;
  //     print('â¹ï¸ Stopped periodic refresh');
  //   }
  // }
 
  // Handle socket data stream
  void _handleSocketData(Map<String, dynamic> data) {
    final type = data['type'];
    final payload = data['data'];
 
    switch (type) {
      case 'room-update':
        _handleRoomUpdate(payload);
        break;
      case 'dashboard-update':
        _handleDashboardUpdate(payload);
        break;
    }
  }
 
  // Handle room update from WebSocket
  void _handleRoomUpdate(dynamic data) {
  try {
    final roomId = data['roomId'];
    final roomData = data['data'];
    final source = data['source'] ?? 'unknown';
    final action = data['action']; // ðŸ”¥ BARU: Tambah handling untuk action

    print('ðŸ”„ Processing ${source.toUpperCase()} update for room: $roomId (action: ${action})');

    // Jika ada action 'updated' dan ada oldData, cek apakah nama berubah
    if (action == 'updated' && data['oldData'] != null) {
      final oldData = data['oldData'];
      final newName = roomData['name'];
      final oldName = oldData['name'];
      
      if (newName != oldName) {
        print('ðŸ”„ Detected name change in update: $oldName -> $newName');
        // Panggil handleRoomNameChanged untuk update nama
        handleRoomNameChanged({
          'roomId': roomId,
          'newName': newName,
          'oldName': oldName,
          'buildingName': roomData['buildingName']
        });
        return; // Keluar karena sudah dihandle oleh handleRoomNameChanged
      }
    }

    // Find room index
    final roomIndex = _rooms.indexWhere((room) => room.id == roomId);

    if (roomIndex != -1) {
      // Create updated room data
      final updatedRoom = Room(
        id: _rooms[roomIndex].id,
        name: roomData['name'] ?? _rooms[roomIndex].name, // ðŸ”¥ BARU: Ambil nama dari data baru
        buildingId: _rooms[roomIndex].buildingId,
        buildingName: roomData['buildingName'] ?? _rooms[roomIndex].buildingName, // ðŸ”¥ BARU: Ambil buildingName dari data baru
        dataSource: _rooms[roomIndex].dataSource,
        iotDeviceId: _rooms[roomIndex].iotDeviceId,
        isActive: _rooms[roomIndex].isActive,
        currentAQI: roomData['currentAQI'],
        currentData: RoomData(
          pm25: roomData['currentData']['pm25'].toDouble(),
          pm10: roomData['currentData']['pm10'].toDouble(),
          co2: roomData['currentData']['co2'].toDouble(),
          temperature: roomData['currentData']['temperature'].toDouble(),
          humidity: roomData['currentData']['humidity'].toDouble(),
          updatedAt: DateTime.parse(roomData['currentData']['updatedAt']),
        ),
        createdAt: _rooms[roomIndex].createdAt,
        updatedAt: DateTime.parse(roomData['updatedAt']),
      );

      // Update room in list
      _rooms[roomIndex] = updatedRoom;

      // Update last update time
      _lastUpdate = DateTime.now();

      // Reapply filters
      _applyFilters();

      // Notify listeners
      notifyListeners();

      print('âœ… Room ${_rooms[roomIndex].name} updated via ${source.toUpperCase()}: AQI ${updatedRoom.currentAQI}');
    }
  } catch (e) {
    print('âŒ Error handling room update: $e');
  }
}
 
  // Handle dashboard update
  void _handleDashboardUpdate(dynamic data) {
  try {
    final type = data['type'];
    
    switch (type) {
      case 'room-data-updated':
        // Trigger a refresh of all data
        _refreshData();
        break;
      
      case 'building-name-changed':
        // Handle building name change
        handleBuildingNameChanged(data);
        break;
        
      case 'room-name-changed':
        // ðŸ”¥ BARU: Handle room name change
        handleRoomNameChanged(data);
        break;
        
      default:
        print('â„¹ï¸ Unknown dashboard update type: $type');
    }
  } catch (e) {
    print('âŒ Error handling dashboard update: $e');
  }
}



// ðŸ”¥ BARU: Handle room name change
void handleRoomNameChanged(Map<String, dynamic> data) {
  try {
    final roomId = data['roomId'];
    final newName = data['newName'];
    final oldName = data['oldName'];
    final buildingName = data['buildingName'];
    
    print('ðŸ”„ Processing room name change: $oldName -> $newName ($roomId)');
    
    // Cari room di list
    final roomIndex = _rooms.indexWhere((room) => room.id == roomId);
    
    if (roomIndex != -1) {
      // Update room dengan nama baru
      final updatedRoom = Room(
        id: _rooms[roomIndex].id,
        name: newName, // Update nama room
        buildingId: _rooms[roomIndex].buildingId,
        buildingName: buildingName,
        dataSource: _rooms[roomIndex].dataSource,
        iotDeviceId: _rooms[roomIndex].iotDeviceId,
        isActive: _rooms[roomIndex].isActive,
        currentAQI: _rooms[roomIndex].currentAQI,
        currentData: _rooms[roomIndex].currentData,
        createdAt: _rooms[roomIndex].createdAt,
        updatedAt: DateTime.now(),
      );
      
      _rooms[roomIndex] = updatedRoom;
      
      // Reapply filters
      _applyFilters();
      
      // Update last update time
      _lastUpdate = DateTime.now();
      
      // Notify listeners
      notifyListeners();
      
      print('âœ… Room name updated: $oldName -> $newName');
    } else {
      print('âš ï¸ Room not found in local list: $roomId');
      // Jika room tidak ditemukan, refresh data
      _refreshData();
    }
  } catch (e) {
    print('âŒ Error handling room name change: $e');
  }
}
 
  // Join room for real-time updates
  void joinRoom(String roomId) {
    _socketService.joinRoom(roomId);
    _storageService.addSubscribedRoom(roomId);
  }
 
  // Leave room
  void leaveRoom(String roomId) {
    _socketService.leaveRoom(roomId);
    _storageService.removeSubscribedRoom(roomId);
  }
 
  // Check socket connection
  Future<void> checkSocketConnection() async {
    final isConnected = await _socketService.checkConnection();
    _socketConnected = isConnected;
    await _storageService.setSocketConnected(isConnected);
    notifyListeners();
  }
 
  // Reconnect socket
  Future<void> reconnectSocket() async {
    await initSocket();
  }
 
  // Initialize and load rooms
  Future<void> loadRooms() async {
    _isLoading = true;
    _hasError = false;
    notifyListeners();
 
    try {
      print('ðŸ”„ Loading rooms from database...');
 
      // Initialize socket on first load
      if (!_socketConnected) {
        await initSocket();
      }
 
      _rooms = await _roomRepository.getRooms();
      _applyFilters();
 
      print('âœ… Loaded ${_rooms.length} rooms from database');
 
    } catch (e) {
      _hasError = true;
      _errorMessage = e.toString();
      print('âŒ Error loading rooms: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
 
  // Refresh data with loading indicator
  Future<void> refresh() async {
    if (_isRefreshing) return;
 
    _isRefreshing = true;
    _hasError = false;
    notifyListeners();
 
    try {
      print('ðŸ”„ Manual refresh initiated');
 
      // Force refresh from API
      _rooms = await _roomRepository.getRooms();
      _applyFilters();
 
      // Update last update time
      _lastUpdate = DateTime.now();
 
      print('âœ… Manual refresh completed: ${_rooms.length} rooms');
 
    } catch (e) {
      _hasError = true;
      _errorMessage = e.toString();
      print('âŒ Error during refresh: $e');
    } finally {
      _isRefreshing = false;
      notifyListeners();
    }
  }
 
  // Internal refresh without loading indicator (for periodic updates)
  Future<void> _refreshData() async {
    try {
      print('ðŸ”„ Background refresh initiated');
 
      final newRooms = await _roomRepository.getRooms();
 
      // Check if data has actually changed
      bool hasChanges = false;
      if (newRooms.length != _rooms.length) {
        hasChanges = true;
      } else {
        for (int i = 0; i < newRooms.length; i++) {
          if (newRooms[i].currentAQI != _rooms[i].currentAQI ||
              newRooms[i].updatedAt != _rooms[i].updatedAt) {
            hasChanges = true;
            break;
          }
        }
      }
 
      if (hasChanges) {
        _rooms = newRooms;
        _applyFilters();
        _lastUpdate = DateTime.now();
 
        print('âœ… Background refresh completed with changes');
        notifyListeners();
      } else {
        print('â„¹ï¸ Background refresh: no changes detected');
      }
 
    } catch (e) {
      print('âŒ Error during background refresh: $e');
    }
  }
 
  // Apply all filters and sorting
  void _applyFilters() {
    // Start with all rooms
    List<Room> result = List.from(_rooms);
 
    // Apply building filter
    if (_selectedBuilding != 'Semua Gedung') {
      result = result.where((room) => room.buildingName == _selectedBuilding).toList();
    }
 
    // Apply search query
    if (_searchQuery.isNotEmpty) {
      final query = _searchQuery.toLowerCase();
      result = result.where((room) =>
        room.name.toLowerCase().contains(query) ||
        room.buildingName.toLowerCase().contains(query)
      ).toList();
    }
 
    // Apply sorting
    switch (_sortBy) {
      case 'Terbaru':
        result.sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
        break;
      case 'A-Z':
        result.sort((a, b) => a.name.compareTo(b.name));
        break;
      case 'AQI Terbaik':
        result.sort((a, b) => a.currentAQI.compareTo(b.currentAQI));
        break;
      case 'AQI Terburuk':
        result.sort((a, b) => b.currentAQI.compareTo(a.currentAQI));
        break;
    }
 
    _filteredRooms = result;
  }
 
  // Update filters
  void updateBuildingFilter(String building) {
    _selectedBuilding = building;
    _applyFilters();
    notifyListeners();
  }
 
  void updateSort(String sortBy) {
    _sortBy = sortBy;
    _applyFilters();
    notifyListeners();
  }
 
  void updateSearchQuery(String query) {
    _searchQuery = query;
    _applyFilters();
    notifyListeners();
  }
 
  // Get rooms by building
  Map<String, List<Room>> get roomsByBuilding {
    final Map<String, List<Room>> result = {};
 
    for (final room in _filteredRooms) {
      final buildingName = room.buildingName;
      if (!result.containsKey(buildingName)) {
        result[buildingName] = [];
      }
      result[buildingName]!.add(room);
    }
 
    return result;
  }
 
  // Clear filters
  void clearFilters() {
    _selectedBuilding = 'Semua Gedung';
    _sortBy = 'Terbaru';
    _searchQuery = '';
    _applyFilters();
    notifyListeners();
  }
 
  // Get room by ID
  Room? getRoomById(String roomId) {
    try {
      return _rooms.firstWhere((room) => room.id == roomId);
    } catch (e) {
      return null;
    }
  }

  void handleBuildingNameChanged(Map<String, dynamic> data) {
  try {
    final buildingId = data['buildingId'];
    final newBuildingName = data['newBuildingName'];
    final affectedRooms = List<String>.from(data['affectedRooms'] ?? []);
    
    print('ðŸ”„ Processing building name change: $buildingId -> $newBuildingName');
    print('ðŸ“‹ Affected rooms: $affectedRooms');
    
    // Update all rooms that belong to this building
    bool hasChanges = false;
    for (int i = 0; i < _rooms.length; i++) {
      if (_rooms[i].buildingId == buildingId) {
        // Create updated room
        final updatedRoom = Room(
          id: _rooms[i].id,
          name: _rooms[i].name,
          buildingId: _rooms[i].buildingId,
          buildingName: newBuildingName, // Update building name
          dataSource: _rooms[i].dataSource,
          iotDeviceId: _rooms[i].iotDeviceId,
          isActive: _rooms[i].isActive,
          currentAQI: _rooms[i].currentAQI,
          currentData: _rooms[i].currentData,
          createdAt: _rooms[i].createdAt,
          updatedAt: DateTime.now(),
        );
        
        _rooms[i] = updatedRoom;
        hasChanges = true;
        
        print('âœ… Updated room ${_rooms[i].name}: building name -> $newBuildingName');
      }
    }
    
    if (hasChanges) {
      // Reapply filters
      _applyFilters();
      
      // Update last update time
      _lastUpdate = DateTime.now();
      
      // Notify listeners
      notifyListeners();
      
      print('ðŸŽ¯ Building name update completed. Affected rooms updated.');
    }
  } catch (e) {
    print('âŒ Error handling building name change: $e');
  }
}
 
  // Dispose
  @override
  void dispose() {
    // Stop refresh timer
    // _stopPeriodicRefresh();
 
    // Cancel subscriptions
    _socketSubscription?.cancel();
    _dataSubscription?.cancel();
 
    // Disconnect socket
    _socketService.disconnect();
 
    // Remove event listeners
    _socketService.off('room-update');
    _socketService.off('dashboard-update');
 
    super.dispose();
  }
}
---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/widgets/chart/history_chart.dart:

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:intl/intl.dart';
import 'package:unila_aqi/data/models/sensor_data.dart';

class HistoryChart extends StatefulWidget {
  final String roomId;
  final String roomName;
  final String buildingName;
  
  const HistoryChart({
    super.key,
    required this.roomId,
    required this.roomName,
    required this.buildingName,
  });

  @override
  _HistoryChartState createState() => _HistoryChartState();
}

class _HistoryChartState extends State<HistoryChart> {
  // State variables
  List<SensorData> _historyData = [];
  DateTime _selectedDate = DateTime.now();
  String _selectedParameter = 'aqi';
  bool _isLoading = false;
  String _error = '';
  final ScrollController _scrollController = ScrollController();
  
  // Parameter options
  final List<String> _parameters = ['aqi', 'pm25', 'pm10', 'co2', 'temperature', 'humidity'];
  final Map<String, String> _parameterLabels = {
    'aqi': 'AQI',
    'pm25': 'PM2.5',
    'pm10': 'PM10',
    'co2': 'COâ‚‚',
    'temperature': 'Suhu',
    'humidity': 'Kelembaban',
  };
  
  // Color for each parameter
  final Map<String, Color> _parameterColors = {
    'aqi': Colors.blue,
    'pm25': Colors.red,
    'pm10': Colors.orange,
    'co2': Colors.green,
    'temperature': Colors.purple,
    'humidity': Colors.teal,
  };
  
  @override
  void initState() {
    super.initState();
    _loadHistoryData();
    // Auto scroll ke data terbaru setelah data dimuat
    WidgetsBinding.instance.addPostFrameCallback((_) {
      Future.delayed(Duration(milliseconds: 300), () {
        if (_scrollController.hasClients) {
          _scrollController.animateTo(
            _scrollController.position.maxScrollExtent,
            duration: Duration(milliseconds: 500),
            curve: Curves.easeOut,
          );
        }
      });
    });
  }
  
  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }
  
  Future<void> _loadHistoryData() async {
    if (mounted) {
      setState(() {
        _isLoading = true;
        _error = '';
      });
    }
    
    try {
      await _generateSampleData();
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = 'Error loading data: $e';
        });
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
  
  // Helper function untuk mendapatkan kategori AQI
  String _getAQICategory(int aqi) {
    if (aqi <= 50) return 'baik';
    if (aqi <= 100) return 'sedang';
    if (aqi <= 150) return 'tidak_sehat';
    if (aqi <= 200) return 'sangat_tidak_sehat';
    if (aqi <= 300) return 'berbahaya';
    return 'error';
  }
  
  Future<void> _generateSampleData() async {
    // Simulasi data dari 00:00 sampai 23:30 setiap 30 menit
    final now = DateTime.now();
    final startDate = DateTime(now.year, now.month, now.day);
    final data = <SensorData>[];
    
    for (int hour = 0; hour < 24; hour++) {
      for (int minute = 0; minute < 60; minute += 30) {
        final timestamp = startDate.add(Duration(hours: hour, minutes: minute));
        
        final randomFactor = (DateTime.now().millisecond % 20) - 10;
        
        final aqiValue = (30 + hour * 2 + randomFactor).toInt();
        
        final sensorData = SensorData(
          id: '${timestamp.millisecondsSinceEpoch}',
          roomId: widget.roomId,
          roomName: widget.roomName,
          buildingName: widget.buildingName,
          aqi: aqiValue,
          pm25: 15.0 + hour * 1.5 + randomFactor.toDouble(),
          pm10: 25.0 + hour * 2.0 + randomFactor.toDouble(),
          co2: 400.0 + hour * 20.0 + randomFactor * 5.0,
          temperature: 22.0 + hour * 0.5 + randomFactor * 0.2,
          humidity: 50.0 + hour * 1.0 + randomFactor * 2.0,
          category: _getAQICategory(aqiValue),
          timestamp: timestamp,
        );
        
        data.add(sensorData);
      }
    }
    
    if (mounted) {
      setState(() {
        _historyData = data;
      });
    }
  }
  
  Future<void> _selectDate(BuildContext context) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime.now().subtract(const Duration(days: 30)),
      lastDate: DateTime.now(),
    );
    
    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
      await _loadHistoryData();
    }
  }
  
  List<FlSpot> _getDataPoints() {
    final spots = <FlSpot>[];
    
    for (int i = 0; i < _historyData.length; i++) {
      final data = _historyData[i];
      final x = i.toDouble(); // Menggunakan index sebagai x untuk spacing konsisten
      
      double y;
      switch (_selectedParameter) {
        case 'aqi':
          y = data.aqi.toDouble();
          break;
        case 'pm25':
          y = data.pm25;
          break;
        case 'pm10':
          y = data.pm10;
          break;
        case 'co2':
          y = data.co2;
          break;
        case 'temperature':
          y = data.temperature;
          break;
        case 'humidity':
          y = data.humidity;
          break;
        default:
          y = 0;
      }
      
      spots.add(FlSpot(x, y));
    }
    
    return spots;
  }
  
  SideTitles _getBottomTitles() {
    return SideTitles(
      showTitles: true,
      reservedSize: 30,
      interval: 2, // Tampilkan setiap 2 data point (setiap jam)
      getTitlesWidget: (value, meta) {
        if (value < 0 || value >= _historyData.length) return const SizedBox.shrink();
        
        final data = _historyData[value.toInt()];
        final hour = data.timestamp.hour;
        final minute = data.timestamp.minute;
        
        // Hanya tampilkan label setiap jam (00 menit)
        if (minute == 0) {
          final hourLabel = hour == 0 ? '00' : hour.toString().padLeft(2, '0');
          return Padding(
            padding: const EdgeInsets.only(top: 8.0),
            child: Text(
              '$hourLabel:00',
              style: const TextStyle(
                fontSize: 10,
                color: Colors.grey,
              ),
            ),
          );
        }
        return const SizedBox.shrink();
      },
    );
  }
  
  Widget _buildChart() {
    final spots = _getDataPoints();
    final color = _parameterColors[_selectedParameter]!;
    
    // Hitung lebar chart berdasarkan jumlah data
    final chartWidth = _historyData.length * 60.0;
    final minChartWidth = MediaQuery.of(context).size.width * 1.5;
    final actualChartWidth = chartWidth > minChartWidth ? chartWidth : minChartWidth;
    
    return Container(
      height: 350,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        children: [
          // Chart Header
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Grafik ${_parameterLabels[_selectedParameter]}',
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Container(
                      width: 12,
                      height: 12,
                      decoration: BoxDecoration(
                        color: color,
                        shape: BoxShape.circle,
                      ),
                    ),
                    const SizedBox(width: 4),
                    Text(
                      _parameterLabels[_selectedParameter]!,
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.w500,
                        color: color,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          
          // Scrollable Chart Area
          Expanded(
            child: SingleChildScrollView(
              controller: _scrollController,
              scrollDirection: Axis.horizontal,
              child: Container(
                width: actualChartWidth,
                child: LineChart(
                  LineChartData(
                    gridData: FlGridData(
                      show: true,
                      drawVerticalLine: true,
                      drawHorizontalLine: false, // HAPUS: garis horizontal Y
                      horizontalInterval: 20,
                      getDrawingHorizontalLine: (value) {
                        return FlLine(
                          color: Colors.transparent, // HAPUS: transparan
                          strokeWidth: 0,
                        );
                      },
                      getDrawingVerticalLine: (value) {
                        if (value % 2 == 0) { // Setiap 2 data point (setiap jam)
                          return FlLine(
                            color: Colors.grey.withOpacity(0.1),
                            strokeWidth: 0.5,
                          );
                        }
                        return FlLine(
                          color: Colors.transparent,
                          strokeWidth: 0,
                        );
                      },
                    ),
                    titlesData: FlTitlesData(
                      show: true,
                      rightTitles: const AxisTitles(
                        sideTitles: SideTitles(showTitles: false),
                      ),
                      topTitles: const AxisTitles(
                        sideTitles: SideTitles(showTitles: false),
                      ),
                      bottomTitles: AxisTitles(
                        sideTitles: _getBottomTitles(),
                      ),
                      leftTitles: AxisTitles(
                        sideTitles: SideTitles(
                          showTitles: false, // HAPUS: label sumbu Y
                        ),
                      ),
                    ),
                    borderData: FlBorderData(
                      show: false, // HAPUS: border chart
                    ),
                    minX: 0,
                    maxX: _historyData.length > 0 ? (_historyData.length - 1).toDouble() : 0,
                    minY: _getMinY(),
                    maxY: _getMaxY(),
                    lineBarsData: [
                      LineChartBarData(
                        spots: spots,
                        isCurved: true,
                        color: color,
                        barWidth: 2.5,
                        isStrokeCapRound: true,
                        dotData: FlDotData(
                          show: true,
                          getDotPainter: (spot, percent, barData, index) {
                            return FlDotCirclePainter(
                              radius: 3.5,
                              color: color,
                              strokeWidth: 2,
                              strokeColor: Colors.white,
                            );
                          },
                        ),
                        belowBarData: BarAreaData(
                          show: true,
                          gradient: LinearGradient(
                            begin: Alignment.topCenter,
                            end: Alignment.bottomCenter,
                            colors: [
                              color.withOpacity(0.3),
                              color.withOpacity(0.1),
                              Colors.transparent,
                            ],
                            stops: const [0.0, 0.5, 1.0],
                          ),
                        ),
                      ),
                    ],
                    lineTouchData: LineTouchData(
                      enabled: true,
                      touchTooltipData: LineTouchTooltipData(
                        tooltipBgColor: Colors.white,
                        tooltipRoundedRadius: 8,
                        tooltipPadding: const EdgeInsets.all(12),
                        fitInsideHorizontally: true,
                        fitInsideVertically: true,
                        maxContentWidth: MediaQuery.of(context).size.width * 0.7,
                        getTooltipItems: (List<LineBarSpot> touchedSpots) {
                          return touchedSpots.map((spot) {
                            final index = spot.spotIndex;
                            if (index < 0 || index >= _historyData.length) {
                              return null;
                            }
                            
                            final data = _historyData[index];
                            final hour = data.timestamp.hour;
                            final minute = data.timestamp.minute;
                            final time = '${hour.toString().padLeft(2, '0')}:${minute.toString().padLeft(2, '0')}';
                            
                            // Get all values for this time point
                            final values = {
                              'AQI': '${data.aqi}',
                              'PM2.5': '${data.pm25.toStringAsFixed(1)} Î¼g/mÂ³',
                              'PM10': '${data.pm10.toStringAsFixed(1)} Î¼g/mÂ³',
                              'COâ‚‚': '${data.co2.round()} ppm',
                              'Suhu': '${data.temperature.toStringAsFixed(1)}Â°C',
                              'Kelembaban': '${data.humidity.round()}%',
                            };
                            
                            return LineTooltipItem(
                              'Waktu: $time\n\n${values.entries.map((e) => '${e.key}: ${e.value}').join('\n')}',
                              const TextStyle(
                                color: Colors.black87,
                                fontWeight: FontWeight.w500,
                                fontSize: 12,
                              ),
                            );
                          }).where((element) => element != null).cast<LineTooltipItem>().toList();
                        },
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
          
          const SizedBox(height: 8),
        ],
      ),
    );
  }
  
  double _getMinY() {
    if (_historyData.isEmpty) return 0.0;
    
    double minValue = double.infinity;
    for (var data in _historyData) {
      double value;
      switch (_selectedParameter) {
        case 'aqi':
          value = data.aqi.toDouble();
          break;
        case 'pm25':
          value = data.pm25;
          break;
        case 'pm10':
          value = data.pm10;
          break;
        case 'co2':
          value = data.co2;
          break;
        case 'temperature':
          value = data.temperature;
          break;
        case 'humidity':
          value = data.humidity;
          break;
        default:
          value = 0.0;
      }
      if (value < minValue) minValue = value;
    }
    
    return minValue - (minValue * 0.1);
  }
  
  double _getMaxY() {
    if (_historyData.isEmpty) return 100.0;
    
    double maxValue = double.negativeInfinity;
    for (var data in _historyData) {
      double value;
      switch (_selectedParameter) {
        case 'aqi':
          value = data.aqi.toDouble();
          break;
        case 'pm25':
          value = data.pm25;
          break;
        case 'pm10':
          value = data.pm10;
          break;
        case 'co2':
          value = data.co2;
          break;
        case 'temperature':
          value = data.temperature;
          break;
        case 'humidity':
          value = data.humidity;
          break;
        default:
          value = 0.0;
      }
      if (value > maxValue) maxValue = value;
    }
    
    return maxValue + (maxValue * 0.1);
  }
  
  Widget _buildParameterSelector() {
    return Container(
      height: 50,
      margin: const EdgeInsets.only(bottom: 16),
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: _parameters.length,
        itemBuilder: (context, index) {
          final parameter = _parameters[index];
          final isSelected = _selectedParameter == parameter;
          final color = _parameterColors[parameter]!;
          
          return GestureDetector(
            onTap: () {
              setState(() {
                _selectedParameter = parameter;
              });
            },
            child: Container(
              margin: const EdgeInsets.only(right: 8),
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                color: isSelected ? color : color.withOpacity(0.1),
                borderRadius: BorderRadius.circular(25),
                border: Border.all(
                  color: isSelected ? color : Colors.transparent,
                  width: 2,
                ),
              ),
              child: Row(
                children: [
                  Container(
                    width: 12,
                    height: 12,
                    decoration: BoxDecoration(
                      color: isSelected ? Colors.white : color,
                      shape: BoxShape.circle,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    _parameterLabels[parameter]!,
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w600,
                      color: isSelected ? Colors.white : color,
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
  
  Widget _buildDateSelector() {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
             
              const SizedBox(height: 4),
              Text(
                DateFormat('EEEE, dd MMMM yyyy').format(_selectedDate),
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
          IconButton(
            onPressed: () => _selectDate(context),
            icon: const Icon(Icons.calendar_today),
            tooltip: 'Pilih tanggal lain',
          ),
        ],
      ),
    );
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildDateSelector(),
        
        _buildParameterSelector(),
        
        if (_isLoading)
          Container(
            height: 350,
            alignment: Alignment.center,
            child: const CircularProgressIndicator(),
          )
        else if (_error.isNotEmpty)
          Container(
            height: 350,
            alignment: Alignment.center,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(
                  Icons.error_outline,
                  size: 48,
                  color: Colors.red,
                ),
                const SizedBox(height: 16),
                Text(
                  _error,
                  textAlign: TextAlign.center,
                  style: const TextStyle(color: Colors.red),
                ),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: _loadHistoryData,
                  child: const Text('Coba Lagi'),
                ),
              ],
            ),
          )
        else if (_historyData.isEmpty)
          Container(
            height: 350,
            alignment: Alignment.center,
            child: const Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.insert_chart_outlined,
                  size: 48,
                  color: Colors.grey,
                ),
                SizedBox(height: 16),
                Text(
                  'Tidak ada data history untuk tanggal ini',
                  style: TextStyle(color: Colors.grey),
                ),
              ],
            ),
          )
        else
          _buildChart(),
      ],
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/widgets/common/building_section.dart:

import 'package:flutter/material.dart';
import '../../../data/models/room.dart';
import 'room_card.dart';

class BuildingSection extends StatelessWidget {
  final String buildingName;
  final List<Room> rooms;
  final Function(Room)? onRoomTap;
  
  const BuildingSection({
    super.key,
    required this.buildingName,
    required this.rooms,
    this.onRoomTap,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Building Header
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            decoration: BoxDecoration(
              color: Theme.of(context).primaryColor.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Row(
              children: [
                const Icon(Icons.location_city, size: 20),
                const SizedBox(width: 8),
                Text(
                  buildingName,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(width: 8),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                  decoration: BoxDecoration(
                    color: Theme.of(context).primaryColor,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '${rooms.length} ruangan',
                    style: const TextStyle(
                      fontSize: 12,
                      color: Colors.white,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 12),
          // Rooms List
          ListView.separated(
            physics: const NeverScrollableScrollPhysics(),
            shrinkWrap: true,
            itemCount: rooms.length,
            separatorBuilder: (context, index) => const SizedBox(height: 12),
            itemBuilder: (context, index) {
              final room = rooms[index];
              return RoomCard(
                room: room,
                onTap: () {
                  if (onRoomTap != null) {
                    onRoomTap!(room);
                  }
                },
              );
            },
          ),
        ],
      ),
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/widgets/common/drawer.dart:

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../presentation/providers/auth_provider.dart';
import '../../../core/constants/colors.dart';

class AppDrawer extends StatelessWidget {
  final bool isAdmin;
  final VoidCallback? onDashboardTap;
  final VoidCallback? onBuildingsTap;
  final VoidCallback? onRoomsTap;
  final VoidCallback? onDevicesTap;
  final VoidCallback? onProfileTap;
  final VoidCallback? onLogoutTap;
  final VoidCallback? onHelpTap; 
  
  
  const AppDrawer({
    super.key,
    required this.isAdmin,
    this.onDashboardTap,
    this.onBuildingsTap,
    this.onRoomsTap,
    this.onDevicesTap,
    this.onProfileTap,
    this.onLogoutTap,
    this.onHelpTap,
  });

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final currentUser = authProvider.currentUser;
    
    return Drawer(
      child: Column(
        children: [
          // Header
          Container(
            padding: const EdgeInsets.fromLTRB(16, 48, 16, 24),
            color: AppColors.primary,
            child: Column(
              children: [
                Container(
              width: 100,
              height: 100,
              decoration: BoxDecoration(
                color: AppColors.primary,
                shape: BoxShape.circle,
                border: Border.all(
                  color: AppColors.primary,
                  width: 2,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.white,
                    blurRadius: 1.5,
                    offset: const Offset(1, 2),
                  ),
                ],
              ),
              child: Padding(
                padding: const EdgeInsets.all(8.0), // Padding untuk memberi ruang
                child: Image.asset(
                  'assets/images/logo_unila.png',
                  width: 104, // 120 - (8*2) = 104
                  height: 104,
                  fit: BoxFit.contain, // Gunakan contain agar tidak terpotong
                ),
              ),
            ),
                const SizedBox(height: 16),
                Text(
                  'UNILA Air Quality Index',
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    color: Colors.white,
                    fontWeight: FontWeight.w600,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
          // User Info
          Container(
            padding: const EdgeInsets.all(16),
            decoration: const BoxDecoration(
              color: AppColors.surface,
              border: Border(
                bottom: BorderSide(color: AppColors.border),
              ),
            ),
            child: Row(
              children: [
                Container(
                  width: 40,
                  height: 40,
                  decoration: const BoxDecoration(
                    color: AppColors.primary,
                    shape: BoxShape.circle,
                  ),
                  child: Icon(
                    isAdmin ? Icons.admin_panel_settings : Icons.person,
                    color: Colors.white,
                    size: 20,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        currentUser?['username'] ?? (isAdmin ? 'Admin' : 'Pengunjung'),
                        style: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Container(
                            width: 8,
                            height: 8,
                            decoration: const BoxDecoration(
                              color: Colors.green,
                              shape: BoxShape.circle,
                            ),
                          ),
                          const SizedBox(width: 6),
                          Text(
                            isAdmin ? 'â— Online' : 'Pengguna',
                            style: const TextStyle(
                              fontSize: 12,
                              color: Colors.grey,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          // Menu Items
          Expanded(
            child: ListView(
              padding: EdgeInsets.zero,
               children: [
                _buildMenuItem(
                  icon: Icons.dashboard,
                  label: 'DASHBOARD',
                  onTap: onDashboardTap,
                ),
                if (isAdmin) ...[
                  const Divider(indent: 16, endIndent: 16),
                  _buildMenuItem(
                    icon: Icons.location_city,
                    label: 'KELOLA GEDUNG',
                    onTap: onBuildingsTap,
                  ),
                  _buildMenuItem(
                    icon: Icons.meeting_room,
                    label: 'KELOLA RUANGAN',
                    onTap: onRoomsTap,
                  ),
                  _buildMenuItem(
                    icon: Icons.sensors,
                    label: 'KELOLA DEVICE IOT',
                    onTap: onDevicesTap,
                  ),
                  _buildMenuItem(
                    icon: Icons.person,
                    label: 'EDIT PROFILE ADMIN',
                    onTap: onProfileTap,
                  ),
                ],
                // âœ… TAMBAH: Menu Help untuk semua user
                const Divider(indent: 16, endIndent: 16),
                _buildMenuItem(
                  icon: Icons.help_outline,
                  label: 'BANTUAN & INFORMASI',
                  onTap: onHelpTap,
                ),
              ],
              
            ),
          ),

          // Logout Button
          Container(
            padding: const EdgeInsets.all(16),
            decoration: const BoxDecoration(
              border: Border(
                top: BorderSide(color: AppColors.border),
              ),
            ),
            child: SizedBox(
              width: double.infinity,
              child: OutlinedButton.icon(
                onPressed: onLogoutTap,
                icon: const Icon(Icons.logout),
                label: const Text('LOGOUT'),
                style: OutlinedButton.styleFrom(
                  foregroundColor: AppColors.error,
                  side: const BorderSide(color: AppColors.error),
                ),
              ),
            ),
          ),
          // Version Info
          Padding(
            padding: const EdgeInsets.all(16),
            child: Text(
              'v1.0.0',
              style: TextStyle(
                fontSize: 12,
                color: Colors.grey[600],
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildMenuItem({
    required IconData icon,
    required String label,
    VoidCallback? onTap,
  }) {
    return ListTile(
      leading: Icon(icon),
      title: Text(
        label,
        style: const TextStyle(
          fontWeight: FontWeight.w500,
        ),
      ),
      onTap: onTap,
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/presentation/widgets/common/room_card.dart:

import 'package:flutter/material.dart';
import '../../../data/models/room.dart';
import '../../../core/utils/helpers.dart';

class RoomCard extends StatelessWidget {
  final Room room;
  final VoidCallback? onTap;
  
  
  const RoomCard({
    super.key,
    required this.room,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final aqiColor = Helpers.getAQIColor(room.currentAQI);
    final aqiLabel = Helpers.getAQILabel(room.currentAQI);
    
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8, horizontal: 0),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header Row - Room name and building
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          room.name,
                          style: const TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.w700,
                            color: Color(0xFF212529),
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 2),
                        Text(
                          room.buildingName,
                          style: const TextStyle(
                            fontSize: 12,
                            color: Color(0xFF6C757D),
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ],
                    ),
                  ),
                  // Status indicator
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: aqiColor.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(20),
                      border: Border.all(color: aqiColor),
                    ),
                    child: Text(
                      aqiLabel,
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.w600,
                        color: aqiColor,
                      ),
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: 16),
              
              // AQI Large Display - CENTERED
              Center(
                child: Column(
                  children: [
                    // Large AQI number
                    Text(
                      room.currentAQI.toString(),
                      style: TextStyle(
                        fontSize: 64,
                        fontWeight: FontWeight.w800,
                        color: aqiColor,
                        height: 0.9,
                      ),
                    ),
                    const SizedBox(height: 4),
                    // AQI Label
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 6),
                      decoration: BoxDecoration(
                        color: aqiColor,
                        borderRadius: BorderRadius.circular(20),
                      ),
                      child: Text(
                        'INDEKS KUALITAS UDARA',
                        style: const TextStyle(
                          color: Colors.white,
                          fontWeight: FontWeight.w700,
                          fontSize: 12,
                          letterSpacing: 0.5,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              
              const SizedBox(height: 20),
              
              // Parameter Grid - 2 rows, 3 columns
              GridView.count(
                physics: const NeverScrollableScrollPhysics(),
                shrinkWrap: true,
                crossAxisCount: 3,
                mainAxisSpacing: 12,
                crossAxisSpacing: 12,
                childAspectRatio: 1.1,
                children: [
                  // PM2.5
                  _buildParameterCell(
                    label: 'PM2.5',
                    value: '${room.currentData.pm25.toStringAsFixed(1)}',
                    unit: 'Âµg/mÂ³',
                    status: Helpers.getPM25Status(room.currentData.pm25),
                    color: Helpers.getPM25Color(room.currentData.pm25),
                  ),
                  
                  // PM10
                  _buildParameterCell(
                    label: 'PM10',
                    value: '${room.currentData.pm10.toStringAsFixed(1)}',
                    unit: 'Âµg/mÂ³',
                    status: Helpers.getPM25Status(room.currentData.pm10),
                    color: Helpers.getPM25Color(room.currentData.pm10),
                  ),
                  
                  // CO2
                  _buildParameterCell(
                    label: 'COâ‚‚',
                    value: '${room.currentData.co2.round()}',
                    unit: 'ppm',
                    status: Helpers.getCO2Status(room.currentData.co2),
                    color: Helpers.getCO2Color(room.currentData.co2),
                  ),
                  
                  // Temperature
                  _buildParameterCell(
                    label: 'SUHU',
                    value: '${room.currentData.temperature.toStringAsFixed(1)}',
                    unit: 'Â°C',
                    status: Helpers.getTemperatureStatus(room.currentData.temperature),
                    color: Helpers.getTemperatureColor(room.currentData.temperature),
                  ),
                  
                  // Humidity
                  _buildParameterCell(
                    label: 'LEMBAB',
                    value: '${room.currentData.humidity.round()}',
                    unit: '%',
                    status: Helpers.getHumidityStatus(room.currentData.humidity),
                    color: Helpers.getHumidityColor(room.currentData.humidity),
                  ),
                  
                  // Last Update
                  Container(
                    decoration: BoxDecoration(
                      color: const Color(0xFFF8F9FA),
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(color: const Color(0xFFE9ECEF)),
                    ),
                    child: Padding(
                      padding: const EdgeInsets.all(10),
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          
                          const SizedBox(height: 4),
                          Text(
                            'UPDATE',
                            style: TextStyle(
                              fontSize: 10,
                              fontWeight: FontWeight.w600,
                              color: Colors.grey[700],
                            ),
                          ),
                          const SizedBox(height: 4),
                          Row(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.baseline,
              textBaseline: TextBaseline.alphabetic,
              children: [
                Text(
                  Helpers.formatLastUpdate(room.currentData.updatedAt),
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                    color: Color(0xFF212529),
                  ),
                ),
                const SizedBox(width: 2),
              ],
            ),
                         
                        ],
                      ),
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: 12),
              
              // Footer - Data source and additional info
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // Data source indicator
                  if (room.isIot)
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                      decoration: BoxDecoration(
                        color: const Color(0xFFE3F2FD),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.sensors,
                            size: 12,
                            color: Colors.blue[700],
                          ),
                          const SizedBox(width: 4),
                          Text(
                            'Device IoT',
                            style: TextStyle(
                              fontSize: 10,
                              fontWeight: FontWeight.w600,
                              color: Colors.blue[700],
                            ),
                          ),
                        ],
                      ),
                    )
                  else
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                      decoration: BoxDecoration(
                        color: const Color(0xFFF3E5F5),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.auto_awesome,
                            size: 12,
                            color: Colors.purple[700],
                          ),
                          const SizedBox(width: 4),
                          Text(
                            'Simulasi',
                            style: TextStyle(
                              fontSize: 10,
                              fontWeight: FontWeight.w600,
                              color: Colors.purple[700],
                            ),
                          ),
                        ],
                      ),
                    ),
                  
                  // Room status
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                    decoration: BoxDecoration(
                      color: room.isActive 
                          ? const Color(0xFFE8F5E9) 
                          : const Color(0xFFF5F5F5),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Container(
                          width: 6,
                          height: 6,
                          decoration: BoxDecoration(
                            color: room.isActive ? Colors.green : Colors.grey,
                            shape: BoxShape.circle,
                          ),
                        ),
                        const SizedBox(width: 4),
                        Text(
                          room.isActive ? 'Aktif' : 'Nonaktif',
                          style: TextStyle(
                            fontSize: 10,
                            fontWeight: FontWeight.w600,
                            color: room.isActive ? Colors.green : Colors.grey,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildParameterCell({
    required String label,
    required String value,
    required String unit,
    required String status,
    required Color color,
  }) {
    return Container(
      decoration: BoxDecoration(
        color: const Color(0xFFF8F9FA),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: const Color(0xFFE9ECEF)),
      ),
      child: Padding(
        padding: const EdgeInsets.all(10),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // Label
            Text(
              label,
              style: TextStyle(
                fontSize: 10,
                fontWeight: FontWeight.w600,
                color: Colors.grey[700],
              ),
            ),
            
            const SizedBox(height: 4),
            
            // Value and Unit
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.baseline,
              textBaseline: TextBaseline.alphabetic,
              children: [
                Text(
                  value,
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                    color: Color(0xFF212529),
                  ),
                ),
                const SizedBox(width: 2),
                Text(
                  unit,
                  style: TextStyle(
                    fontSize: 9,
                    color: Colors.grey[600],
                  ),
                ),
              ],
            ),
            
            const SizedBox(height: 6),
            
            // Status chip
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: color.withOpacity(0.1),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Text(
                status.length > 10 ? '${status.substring(0, 10)}...' : status,
                style: TextStyle(
                  fontSize: 9,
                  fontWeight: FontWeight.w600,
                  color: color,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
lib/main.dart:

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:unila_aqi/presentation/pages/admin/building_management.dart';
import 'package:unila_aqi/presentation/pages/admin/iot_management.dart';
import 'package:unila_aqi/presentation/pages/admin/room_management.dart';
import 'core/themes/app_theme.dart';
import 'presentation/providers/auth_provider.dart';
import 'presentation/providers/room_provider.dart';
import 'presentation/providers/building_provider.dart';
import 'presentation/pages/auth/mode_selection_screen.dart';
import 'presentation/pages/dashboard/dashboard_screen.dart';
import 'core/services/storage_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Initialize services
  await StorageService().init();
  
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => AuthProvider()),
        ChangeNotifierProvider(create: (_) => RoomProvider()),
        ChangeNotifierProvider(create: (_) => BuildingProvider()),
      ],
      child: const MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    // Initialize socket connection when app starts
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final roomProvider = Provider.of<RoomProvider>(context, listen: false);
      roomProvider.initSocket();
    });

    return MaterialApp(
      title: 'UNILA Air Quality Index',
      debugShowCheckedModeBanner: false,
      theme: AppTheme.lightTheme,
      initialRoute: '/',
      routes: {
        '/': (context) => const ModeSelectionScreen(),
        '/dashboard': (context) => const DashboardScreen(isAdminMode: false),
        '/admin-dashboard': (context) => const DashboardScreen(isAdminMode: true),
        '/admin/buildings': (context) => const BuildingManagementScreen(),
        '/admin/rooms': (context) => const RoomManagementScreen(),
        '/admin/iot-devices': (context) => const IoTManagementScreen(),
      },
      // Enable smooth scrolling
      scrollBehavior: const MaterialScrollBehavior().copyWith(
        physics: const BouncingScrollPhysics(),
      ),
      builder: (context, child) {
        return MediaQuery(
          data: MediaQuery.of(context).copyWith(
            textScaler: const TextScaler.linear(1.0),
          ),
          child: child ?? const SizedBox(),
        );
      },
    );
  }
}

---------------------------------------------------------------------------------------------------------------------------------------
pubspec.yaml:

name: unila_aqi
description: UNILA Air Quality Index Monitoring System
version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  http: ^1.2.0
  provider: ^6.1.1
  socket_io_client: ^2.0.3
  shared_preferences: ^2.2.2
  intl: ^0.18.1
  flutter_svg: ^2.0.10
  fl_chart: ^0.66.0
  cached_network_image: ^3.3.0
  pull_to_refresh: ^2.0.0
  url_launcher: ^6.2.1
  connectivity_plus: ^5.0.1
  flutter_secure_storage: ^9.0.0
  permission_handler: ^11.2.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0

flutter:
  uses-material-design: true
  assets:
    - assets/images/logo_unila.png
    - assets/images/
    - assets/fonts/
  fonts:
    - family: Inter
      fonts:
        - asset: assets/fonts/Inter-Regular.ttf
        - asset: assets/fonts/Inter-Medium.ttf
          weight: 500
        - asset: assets/fonts/Inter-SemiBold.ttf
          weight: 600
        - asset: assets/fonts/Inter-Bold.ttf
          weight: 700